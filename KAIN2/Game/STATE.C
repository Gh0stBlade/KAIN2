#include "CORE.H"
#include "STATE.H"
#include "PLAYER.H"
#include "G2/ANMG2ILF.H"
#include "G2/INSTNCG2.H"
#include "G2/ANIMG2.H"
#include "MEMPACK.H"
#include "Game/GENERIC.H"

struct _G2AnimAlphaTable_Type* G2AlphaTables[7] = {
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
};

char circBuf[4096];

void* circWhere = &circBuf[92];

void InitMessageQueue(struct __MessageQueue* In)
{
	In->Head = 0;
	In->Tail = 0;
}

struct __Event* DeMessageQueue(struct __MessageQueue* In)//Matching - 100%
{
	int head = In->Head;

	if (In->Head == In->Tail)
	{
		return NULL;
	}
	else if (++In->Head == 16)
	{
		In->Head = 0;
	}

	return &In->Queue[head];
}

void PurgeMessageQueue(struct __MessageQueue* In)
{
	In->Tail = 0;
	In->Head = 0;
}

struct __Event* PeekMessageQueue(struct __MessageQueue* In)//Matching - 100%
{
	if (In->Head == In->Tail)
	{
		return NULL;
	}

	return &In->Queue[In->Head];
}

void EnMessageQueue(struct __MessageQueue* In, struct __Event* Element)
{ 
	EnMessageQueueData(In, Element->ID, Element->Data);
}

void EnMessageQueueData(struct __MessageQueue* In, int ID, int Data)//Matching - 100%
{
	int i;

	In->Queue[In->Tail].ID = ID;
	In->Queue[In->Tail].Data = Data;

	if (++In->Tail == 16)
	{
		In->Tail = 0;
	}

	i = In->Head;

	if (i == In->Tail)
	{
		do
		{
			if (++i == 0x10)
			{
				i = 0;
			}

		} while (i != In->Tail);
	}
}


void* CIRC_Alloc(int size)
{
	void* ret;
	
	size = (size + 3) & -4;

	if (&circBuf[sizeof(circBuf)] < (char*)circWhere + size)
	{
		ret = &circBuf[0];

		circWhere = (char*)circWhere + size;

		return ret;
	}
	else
	{
		ret = circWhere;

		circWhere = (char*)circWhere + size;

		return circWhere;
	}
}

uintptr_t SetMonsterHitData(struct _Instance* Sender, struct _Instance* lastHit, int Power, int knockBackDistance, int knockBackFrames) { //Matching 100%
	struct evMonsterHitData* Ptr;
	Ptr = (struct evMonsterHitData*)CIRC_Alloc(sizeof(struct evMonsterHitData));
	Ptr->sender = Sender;
	Ptr->lastHit = lastHit;
	Ptr->power = Power;

	Ptr->knockBackDistance = knockBackDistance;
	Ptr->knockBackDuration = knockBackFrames;
	return (uintptr_t)Ptr;
}

// autogenerated function stub: 
// int /*$ra*/ SetMonsterThrownData(struct _Instance *Sender /*$s1*/, struct _Rotation *Direction /*$s0*/, int Power /*$s2*/)
intptr_t SetMonsterThrownData(struct _Instance *Sender, struct _Rotation *Direction, int Power)
{ // line 332, offset 0x8007094c
	/* begin block 1 */
		// Start line: 333
		// Start offset: 0x8007094C
		// Variables:
			struct evMonsterThrownData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x8007094C
	// End Line: 333

	/* begin block 2 */
		// Start line: 562
	/* end block 2 */
	// End Line: 563
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetMonsterAlarmData(struct _Instance *sender /*$s1*/, _Position *position /*$s0*/, int type /*$s2*/)
intptr_t SetMonsterAlarmData(struct _Instance *sender, _Position *position, int type)
{ // line 348, offset 0x800709b4
	/* begin block 1 */
		// Start line: 349
		// Start offset: 0x800709B4
		// Variables:
			struct evMonsterAlarmData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x800709B4
	// End Line: 349

	/* begin block 2 */
		// Start line: 595
	/* end block 2 */
	// End Line: 596
			UNIMPLEMENTED();
	return 0;
}

intptr_t SetMonsterSoulSuckData(struct _Instance* Sender, int x, int y, int z)//Matching - 99.78%
{
	struct evMonsterSoulSuckData* Ptr;

	Ptr = (struct evMonsterSoulSuckData*)CIRC_Alloc(sizeof(struct evMonsterSoulSuckData));

	Ptr->sender = Sender;

	Ptr->Destination.x = x;
	Ptr->Destination.y = y;
	Ptr->Destination.z = z;

	return (intptr_t)Ptr;
}


// autogenerated function stub: 
// int /*$ra*/ SetMonsterImpaleData(struct _Instance *weapon /*$s2*/, struct _Rotation *direction /*$s0*/, _Position *position /*$s1*/, int distance /*$s3*/)
intptr_t SetMonsterImpaleData(struct _Instance *weapon, struct _Rotation *direction, _Position *position, int distance)
{ // line 382, offset 0x80070a78
	/* begin block 1 */
		// Start line: 383
		// Start offset: 0x80070A78
		// Variables:
			struct evMonsterImpaleData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80070A78
	// End Line: 383

	/* begin block 2 */
		// Start line: 664
	/* end block 2 */
	// End Line: 665
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetObjectData(int x /*$s1*/, int y /*$s2*/, int PathNumber /*$s3*/, struct _Instance *Force /*$s4*/, int node /*stack 16*/)
intptr_t SetObjectData(int x, int y, int PathNumber, struct _Instance *Force, int node)
{ // line 403, offset 0x80070b10
	/* begin block 1 */
		// Start line: 404
		// Start offset: 0x80070B10
		// Variables:
			struct evObjectData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80070B10
	// End Line: 404

	/* begin block 2 */
		// Start line: 707
	/* end block 2 */
	// End Line: 708
			UNIMPLEMENTED();
	return 0;
}

intptr_t SetPositionData(int x, int y, int z)
{
	struct evPositionData* Ptr;
	
	Ptr = (struct evPositionData*)CIRC_Alloc(sizeof(struct evPositionData));

	Ptr->x = x;
	Ptr->y = y;
	Ptr->z = z;

	return (intptr_t)Ptr;
}

intptr_t SetPhysicsGravityData(int UpperOffset, int LowerOffset, int x, int y, int z, int slope)
{
	struct evPhysicsGravityData* Ptr;
	
	Ptr = (struct evPhysicsGravityData*)CIRC_Alloc(sizeof(struct evPhysicsGravityData));
	Ptr->UpperOffset = UpperOffset;
	Ptr->LowerOffset = LowerOffset;
	Ptr->x = x;
	Ptr->y = y;
	Ptr->z = z;
	Ptr->slipSlope = slope;
	
	return (intptr_t)Ptr;
}

intptr_t SetPhysicsEdgeData(int UpperOffset, int ForwardOffset, int AboveOffset, int x, int y, int z, struct _SVector* Normal1, struct _SVector* Normal2, struct _SVector* Delta)
{
	struct evPhysicsEdgeData* Ptr;

	Ptr = (struct evPhysicsEdgeData*)CIRC_Alloc(sizeof(evPhysicsEdgeData));

	Ptr->UpperOffset = UpperOffset;

	Ptr->ForwardOffset = ForwardOffset;

	Ptr->AboveOffset = AboveOffset;

	Ptr->XDistance = x;
	
	Ptr->YDistance = y;
	
	Ptr->ZDistance = z;

	Ptr->Normal1 = Normal1;
	
	Ptr->Normal2 = Normal2;

	Ptr->Delta = Delta;
	
	return (intptr_t)Ptr;
}

intptr_t SetPhysicsSwimData(int CheckDepth, struct _SVector* iVelocity, int SwimDepth, int WadeDepth, int TreadDepth)
{
	struct evPhysicsSwimData* Ptr;

	Ptr = (struct evPhysicsSwimData*)CIRC_Alloc(sizeof(struct evPhysicsSwimData));

	Ptr->CheckDepth = CheckDepth;
	Ptr->iVelocity = iVelocity;
	Ptr->SwimDepth = SwimDepth;
	Ptr->WadeDepth = WadeDepth;
	Ptr->TreadDepth = TreadDepth;
	
	return (intptr_t)Ptr;
}

intptr_t SetPhysicsDropOffData(int xOffset, int yOffset, int DropOffset, int slipSlope, int UpperOffset)
{
	struct evPhysicsDropOffData* Ptr;

	Ptr = (struct evPhysicsDropOffData*)CIRC_Alloc(sizeof(struct evPhysicsDropOffData));

	Ptr->xOffset = xOffset;

	Ptr->yOffset = yOffset;

	Ptr->DropOffset = DropOffset;

	Ptr->slipSlope = slipSlope;

	Ptr->UpperOffset = UpperOffset;

	return (intptr_t)Ptr;
}


// autogenerated function stub: 
// int /*$ra*/ SetPhysicsSlideData(int Segment /*$s3*/, int ForwardVectorX /*$s4*/, int ForwardVectorY /*$s5*/, int ForwardVectorZ /*$s6*/, int DropOffset /*stack 16*/, int UpperOffset /*stack 20*/, int Height /*stack 24*/)
intptr_t SetPhysicsSlideData(int Segment, int ForwardVectorX, int ForwardVectorY, int ForwardVectorZ, int DropOffset, int UpperOffset, int Height)
{ // line 523, offset 0x80070dc8
	/* begin block 1 */
		// Start line: 524
		// Start offset: 0x80070DC8
		// Variables:
			struct evPhysicsSlideData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80070DC8
	// End Line: 524

	/* begin block 2 */
		// Start line: 947
	/* end block 2 */
	// End Line: 948
			UNIMPLEMENTED();
	return 0;
}

intptr_t SetPhysicsWallCrawlData(int Segment, int Length, int ForwardOffset, int NormalDistance)//Matching - 99.78%
{
	struct evPhysicsWallCrawlData* Ptr;

	Ptr = (struct evPhysicsWallCrawlData*)CIRC_Alloc(sizeof(struct evPhysicsWallCrawlData));

	Ptr->Segment = Segment;
	Ptr->Length = Length;
	Ptr->ForwardOffset = ForwardOffset;
	Ptr->NormalDistance = NormalDistance;

	return (intptr_t)Ptr;
}


// autogenerated function stub: 
// int /*$ra*/ SetPhysicsLinkedMoveData(struct _Instance *instance /*$s1*/, int segment /*$s0*/, struct _SVector *posDelta /*$s2*/, struct _SVector *rotDelta /*$s3*/)
intptr_t SetPhysicsLinkedMoveData(struct _Instance *instance, int segment, struct _SVector *posDelta, struct _SVector *rotDelta)
{ // line 561, offset 0x80070eb0
	/* begin block 1 */
		// Start line: 562
		// Start offset: 0x80070EB0
		// Variables:
			struct evPhysicsLinkedMoveData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80070F34
	// End Line: 574

	/* begin block 2 */
		// Start line: 1023
	/* end block 2 */
	// End Line: 1024
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetPhysicsDropHeightData(_Position *offset /*$s0*/, int dropOffset /*$s1*/, int mode /*$s2*/)
intptr_t SetPhysicsDropHeightData(_Position *offset, int dropOffset, int mode)
{ // line 582, offset 0x80070f50
	/* begin block 1 */
		// Start line: 583
		// Start offset: 0x80070F50
		// Variables:
			struct evPhysicsDropHeightData *ptr; // $v0
	/* end block 1 */
	// End offset: 0x80070F50
	// End Line: 583

	/* begin block 2 */
		// Start line: 1065
	/* end block 2 */
	// End Line: 1066
			UNIMPLEMENTED();
	return 0;
}

intptr_t SetAnimationControllerDoneData(struct _Instance* instance, long segment, long type, int data)//Matching - 99.78%
{
	struct evAnimationControllerDoneData* Ptr;

	Ptr = (struct evAnimationControllerDoneData*)CIRC_Alloc(sizeof(struct evAnimationControllerDoneData));

	Ptr->instance = instance;
	Ptr->segment = segment;
	Ptr->type = type;
	Ptr->data = data;

	return (intptr_t)Ptr;
}


// autogenerated function stub: 
// int /*$ra*/ SetAnimationInstanceSwitchData(struct _Instance *instance /*$s1*/, int anim /*$s2*/, int frame /*$s3*/, int frames /*$s4*/, int mode /*stack 16*/)
intptr_t SetAnimationInstanceSwitchData(struct _Instance *instance, int anim, int frame, int frames, int mode)
{ // line 620, offset 0x8007101c
	/* begin block 1 */
		// Start line: 621
		// Start offset: 0x8007101C
		// Variables:
			struct evAnimationInstanceSwitchData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x8007101C
	// End Line: 621

	/* begin block 2 */
		// Start line: 1141
	/* end block 2 */
	// End Line: 1142
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetFXHitData(struct _Instance *hitter /*$s2*/, int segment /*$s3*/, int amount /*$s0*/, int type /*$s1*/)
intptr_t SetFXHitData(struct _Instance *hitter, int segment, int amount, int type)
{ // line 639, offset 0x80071088
	/* begin block 1 */
		// Start line: 640
		// Start offset: 0x80071088
		// Variables:
			struct evFXHitData *Ptr; // $a1
	/* end block 1 */
	// End offset: 0x80071164
	// End Line: 656

	/* begin block 2 */
		// Start line: 1179
	/* end block 2 */
	// End Line: 1180
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetObjectThrowData(void *target /*$s2*/, struct _SVector *angularVel /*$s7*/, unsigned short type /*$s0*/, unsigned short spinType /*$s1*/, int speed /*stack 16*/, int gravity /*stack 20*/, int zVel /*stack 24*/, int initialXRot /*stack 28*/)
intptr_t SetObjectThrowData(void *target, struct _SVector *angularVel, unsigned short type, unsigned short spinType, int speed, int gravity, int zVel, int initialXRot)
{ // line 693, offset 0x80071184
	/* begin block 1 */
		// Start line: 694
		// Start offset: 0x80071184
		// Variables:
			struct evObjectThrowData *Ptr; // $a0
	/* end block 1 */
	// End offset: 0x800712B0
	// End Line: 746

	/* begin block 2 */
		// Start line: 1386
	/* end block 2 */
	// End Line: 1387
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ SetObjectBreakOffData(struct _Instance *force /*$s3*/, short node /*$a1*/, short distance /*$a2*/, short animation /*$a3*/, int frame /*stack 16*/, int type /*stack 20*/, int action /*stack 24*/)
intptr_t SetObjectBreakOffData(struct _Instance *force, short node, short distance, short animation, int frame, int type, int action)
{ // line 750, offset 0x800712f0
	/* begin block 1 */
		// Start line: 751
		// Start offset: 0x800712F0
		// Variables:
			struct evObjectBreakOffData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x800712F0
	// End Line: 751

	/* begin block 2 */
		// Start line: 1369
	/* end block 2 */
	// End Line: 1370
			UNIMPLEMENTED();
	return 0;
}

intptr_t SetControlInitHangData(struct _Instance* instance, long frame, long frames)
{
	struct evControlInitHangData* Ptr;
	
	Ptr = (struct evControlInitHangData*)CIRC_Alloc(sizeof(struct evControlInitHangData));

	Ptr->instance = instance;
	Ptr->frame = frame;
	Ptr->frames = frames;
	
	return (intptr_t)Ptr;
}

intptr_t SetControlInitIdleData(int mode, long frame, long frames)
{
	struct evControlInitIdleData* Ptr;

	Ptr = (struct evControlInitIdleData*)CIRC_Alloc(sizeof(struct evControlInitIdleData));
	
	Ptr->mode = mode;
	Ptr->frame = frame;
	Ptr->frames = frames;

	return (intptr_t)Ptr;
}


// autogenerated function stub: 
// int /*$ra*/ SetObjectDraftData(short force /*$a0*/, unsigned short radius /*$a1*/, unsigned short radiusCoef /*$a2*/, unsigned short height /*$a3*/, int maxVelocity /*stack 16*/)
intptr_t SetObjectDraftData(short force, unsigned short radius, unsigned short radiusCoef, unsigned short height, int maxVelocity)
{ // line 795, offset 0x80071414
	/* begin block 1 */
		// Start line: 796
		// Start offset: 0x80071414
		// Variables:
			struct evObjectDraftData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80071414
	// End Line: 796

	/* begin block 2 */
		// Start line: 1459
	/* end block 2 */
	// End Line: 1460
			UNIMPLEMENTED();
	return 0;
}

intptr_t SetObjectAbsorbData(struct _Instance* force, unsigned short node, unsigned short steps)
{
	struct evObjectAbsorbData* Ptr;

	Ptr = (struct evObjectAbsorbData*)CIRC_Alloc(sizeof(struct evObjectAbsorbData));

	Ptr->force = force;
	Ptr->node = node;
	Ptr->steps = steps;

	return (intptr_t)Ptr;
}

intptr_t SetControlSaveDataData(long length, void* data)
{
	struct evControlSaveDataData* Ptr;
	
	Ptr = (struct evControlSaveDataData*)CIRC_Alloc(sizeof(struct evControlSaveDataData));

	Ptr->length = length;
	Ptr->data = data;

	return (intptr_t)Ptr;
}

intptr_t SetObjectIdleData(long mode, struct _Instance* instance)
{
	struct evObjectIdleData* Ptr;
	
	Ptr = (struct evObjectIdleData*)CIRC_Alloc(sizeof(struct evObjectIdleData));

	Ptr->mode = mode;
	Ptr->instance = instance;
	
	return (intptr_t)Ptr;
}


// autogenerated function stub: 
// int /*$ra*/ SetActionPlayHostAnimationData(struct _Instance *instance /*$s2*/, struct _Instance *host /*$s3*/, int newAnim /*$s4*/, int newFrame /*$s5*/, int frames /*stack 16*/, int mode /*stack 20*/)
intptr_t SetActionPlayHostAnimationData(struct _Instance *instance, struct _Instance *host, int newAnim, int newFrame, int frames, int mode)
{ // line 869, offset 0x80071544
	/* begin block 1 */
		// Start line: 870
		// Start offset: 0x80071544
		// Variables:
			struct evActionPlayHostAnimationData *Ptr; // $v0
	/* end block 1 */
	// End offset: 0x80071544
	// End Line: 870

	/* begin block 2 */
		// Start line: 1738
	/* end block 2 */
	// End Line: 1739
			UNIMPLEMENTED();
	return 0;
}

intptr_t SetObjectBirthProjectileData(struct _Instance* instance, int joint, int type)
{
	struct evObjectBirthProjectileData* Ptr;

	Ptr = (struct evObjectBirthProjectileData*)CIRC_Alloc(sizeof(struct evObjectBirthProjectileData));

	Ptr->instance = instance;

	Ptr->joint = joint;

	Ptr->type = type;

	Ptr->birthInstance = 0;

	return (intptr_t)Ptr;
}

intptr_t SetShadowSegmentData(unsigned long total)
{
	struct evShadowSegmentData* Ptr;
	
	Ptr = (struct evShadowSegmentData*)CIRC_Alloc(sizeof(struct evShadowSegmentData));

	Ptr->totalShadowSegments = total;

	return (intptr_t)Ptr;
}

void G2EmulationInit()//Matching - 98.37%
{
	G2AlphaTables[0] = NULL;

	if (G2AlphaTables[1] == NULL)
	{
		G2AlphaTables[1] = (struct _G2AnimAlphaTable_Type*)MEMPACK_Malloc(0x12, 0x19);
		G2AlphaTables[1]->size = 4;
		G2AlphaTables[1]->data[0] = 0;
		G2AlphaTables[1]->data[1] = 256;
		G2AlphaTables[1]->data[2] = 1024;
		G2AlphaTables[1]->data[3] = 4096;
	}

	if (G2AlphaTables[2] == NULL)
	{
		G2AlphaTables[2] = (struct _G2AnimAlphaTable_Type*)MEMPACK_Malloc(0x12, 0x19);
		G2AlphaTables[2]->size = 4;
		G2AlphaTables[2]->data[0] = 0;
		G2AlphaTables[2]->data[1] = 3072;
		G2AlphaTables[2]->data[2] = 3840;
		G2AlphaTables[2]->data[3] = 4096;
	}

	if (G2AlphaTables[3] == NULL)
	{
		G2AlphaTables[3] = (struct _G2AnimAlphaTable_Type*)MEMPACK_Malloc(0x6, 0x19);
		G2AlphaTables[3]->size = 1;
		G2AlphaTables[3]->data[0] = 4096;
	}

	if (G2AlphaTables[4] == NULL)
	{
		G2AlphaTables[4] = (struct _G2AnimAlphaTable_Type*)MEMPACK_Malloc(0x12, 0x19);
		G2AlphaTables[4]->size = 4;
		G2AlphaTables[4]->data[0] = 0;
		G2AlphaTables[4]->data[1] = 256;
		G2AlphaTables[4]->data[2] = 3840;
		G2AlphaTables[4]->data[3] = 4096;
	}

	if (G2AlphaTables[5] == NULL)
	{
		G2AlphaTables[5] = (struct _G2AnimAlphaTable_Type*)MEMPACK_Malloc(0x12, 0x19);
		G2AlphaTables[5]->size = 4;
		G2AlphaTables[5]->data[0] = 0;
		G2AlphaTables[5]->data[1] = 128;
		G2AlphaTables[5]->data[2] = 512;
		G2AlphaTables[5]->data[3] = 4096;
	}

	if (G2AlphaTables[6] == NULL)
	{
		G2AlphaTables[6] = (struct _G2AnimAlphaTable_Type*)MEMPACK_Malloc(0x12, 0x19);
		G2AlphaTables[6]->size = 4;
		G2AlphaTables[6]->data[0] = 0;
		G2AlphaTables[6]->data[1] = 3584;
		G2AlphaTables[6]->data[2] = 3968;
		G2AlphaTables[6]->data[3] = 4096;
	}
}

void G2EmulationInstancePlayAnimation(struct _Instance* instance)
{
	int i;
	struct _G2Anim_Type* anim;
	
	anim = &instance->anim;

	for (i = 0; i < anim->sectionCount; i++)
	{
		G2AnimSection_NextKeyframe(&anim->section[i]);
	}
}

void G2EmulatePlayAnimation(struct __CharacterState* In)
{
	G2EmulationInstancePlayAnimation(In->CharacterInstance);
}


// autogenerated function stub: 
// void /*$ra*/ G2EmulationInstanceToInstanceSwitchAnimation(struct _Instance *instance /*$a0*/, struct _Instance *host /*$a1*/, int CurrentSection /*$a2*/, int NewAnim /*$s2*/, int NewFrame /*stack 16*/, int Frames /*stack 20*/, int Mode /*stack 24*/)
void G2EmulationInstanceToInstanceSwitchAnimation(struct _Instance *instance, struct _Instance *host, int CurrentSection, int NewAnim, int NewFrame, int Frames, int Mode)
{ // line 1006, offset 0x800718b4
	/* begin block 1 */
		// Start line: 1007
		// Start offset: 0x800718B4
		// Variables:
			struct _G2AnimSection_Type *animSection; // $s4
			struct _G2AnimKeylist_Type *keylist; // $s1
	/* end block 1 */
	// End offset: 0x80071988
	// End Line: 1028

	/* begin block 2 */
		// Start line: 1880
	/* end block 2 */
	// End Line: 1881
			UNIMPLEMENTED();
}

void G2EmulationInstanceSwitchAnimation(struct _Instance* instance, int CurrentSection, int NewAnim, int NewFrame, int Frames, int Mode)//Matching - 99.43%
{
	struct _G2AnimSection_Type* animSection;
	struct _G2AnimKeylist_Type* keylist;

	animSection = &instance->anim.section[CurrentSection];

	keylist = G2Instance_GetKeylist(instance, NewAnim);

	G2AnimSection_SetAlphaTable(animSection, NULL);

	G2AnimSection_InterpToKeylistFrame(animSection, keylist, NewAnim, NewFrame, (short)(Frames * 100));

	if (Mode == 0)
	{
		G2AnimSection_SetPaused(animSection);
	}
	else
	{
		G2AnimSection_SetUnpaused(animSection);

		if (Mode == 2)
		{
			G2AnimSection_SetLooping(animSection);
		}
		else
		{
			G2AnimSection_SetNoLooping(animSection);
		}
	}
}

void G2EmulationInstanceSwitchAnimationAlpha(struct _Instance* instance, int CurrentSection, int NewAnim, int NewFrame, int Frames, int Mode, int AlphaTable)
{
	struct _G2AnimSection_Type* animSection;

	animSection = &instance->anim.section[CurrentSection];

	G2EmulationInstanceSwitchAnimation(instance, CurrentSection, NewAnim, NewFrame, Frames, Mode);

	G2AnimSection_SetAlphaTable(animSection, G2AlphaTables[AlphaTable]);
}

void G2EmulationSwitchAnimation(struct __CharacterState* In, int CurrentSection, int NewAnim, int NewFrame, int Frames, int Mode)
{
	if (NewAnim < 0)
	{
		NewAnim = 0;
	}

	G2EmulationInstanceSwitchAnimation(In->CharacterInstance, CurrentSection, NewAnim, NewFrame, Frames, Mode);
}

void G2EmulationSwitchAnimationAlpha(struct __CharacterState* In, int CurrentSection, int NewAnim, int NewFrame, int Frames, int Mode, int AlphaTable)//Matching - 93.79%
{
	struct _G2AnimSection_Type* animSection;

	animSection = &In->CharacterInstance->anim.section[(char)CurrentSection];

	G2EmulationInstanceSwitchAnimation(In->CharacterInstance, CurrentSection, NewAnim, NewFrame, Frames, Mode);

	G2AnimSection_SetAlphaTable(animSection, G2AlphaTables[AlphaTable]);
}


// autogenerated function stub: 
// void /*$ra*/ G2EmulationSwitchAnimationSync(struct __CharacterState *In /*stack 0*/, int SlaveSectionID /*$fp*/, int MasterSectionID /*$a2*/, int Frames /*stack 12*/)
void G2EmulationSwitchAnimationSync(struct __CharacterState *In, int SlaveSectionID, int MasterSectionID, int Frames)
{ // line 1093, offset 0x80071bc4
	/* begin block 1 */
		// Start line: 1094
		// Start offset: 0x80071BC4
		// Variables:
			struct _Instance *instance; // $a1
			struct _G2AnimSection_Type *masterAnimSection; // $s6
			struct _G2AnimSection_Type *slaveAnimSection; // $s5
			struct _G2AnimKeylist_Type *keylist; // $s1
			int keylistID; // $s3
			struct __State *masterSection; // $s7
			struct __State *slaveSection; // $s2
	/* end block 1 */
	// End offset: 0x80071D34
	// End Line: 1130

	/* begin block 2 */
		// Start line: 2097
	/* end block 2 */
	// End Line: 2098
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ G2EmulationInstanceToInstanceSwitchAnimationCharacter(struct _Instance *instance /*$s0*/, struct _Instance *host /*$a1*/, int NewAnim /*$s2*/, int NewFrame /*$s3*/, int Frames /*stack 16*/, int Mode /*stack 20*/)
void G2EmulationInstanceToInstanceSwitchAnimationCharacter(struct _Instance *instance, struct _Instance *host, int NewAnim, int NewFrame, int Frames, int Mode)
{ // line 1137, offset 0x80071d90
	/* begin block 1 */
		// Start line: 1138
		// Start offset: 0x80071D90
		// Variables:
			struct _G2AnimKeylist_Type *keylist1; // $s0
	/* end block 1 */
	// End offset: 0x80071E58
	// End Line: 1160

	/* begin block 2 */
		// Start line: 2208
	/* end block 2 */
	// End Line: 2209
			UNIMPLEMENTED();
}

void G2EmulationSwitchAnimationCharacter(struct __CharacterState* In, int NewAnim, int NewFrame, int Frames, int Mode)//Matching - 99.43%
{
	struct _Instance* instance;
	struct _G2AnimKeylist_Type* keylist;

	if (NewAnim < 0)
	{
		NewAnim = 0;
	}

	instance = In->CharacterInstance;
	keylist = G2Instance_GetKeylist(instance, NewAnim);
	
	G2Anim_SetAlphaTable(&instance->anim, 0);
	G2Anim_InterpToKeylistFrame(&instance->anim, keylist, NewAnim, NewFrame, (short)(100 * Frames));
	
	if (Mode == 0)
	{
		G2Anim_SetPaused(&instance->anim);
	}
	else
	{
		G2Anim_SetUnpaused(&instance->anim);
		if (Mode == 2)
		{
			G2Anim_SetLooping(&instance->anim);
		}
		else
		{
			G2Anim_SetNoLooping(&instance->anim);
		}
	}
}

void G2EmulationInstanceSetAnimation(struct _Instance *instance, int CurrentSection, int NewAnim, int NewFrame, int Frames)
{
	struct _G2AnimSection_Type *animSection;
	struct _G2AnimKeylist_Type *keylist;

	animSection = &instance->anim.section[CurrentSection];
	
	keylist = G2Instance_GetKeylist(instance, NewAnim);
	
	G2AnimSection_SetAlphaTable(animSection, NULL);
	
	G2AnimSection_InterpToKeylistFrame(animSection, keylist, NewAnim, NewFrame, Frames * 100);
}

void G2EmulationSetAnimation(struct __CharacterState *In, int CurrentSection, int NewAnim, int NewFrame, int Frames)
{
#if defined(PSX_VERSION)

	if (NewAnim < 0)
	{
		NewAnim = 0;
	}
	
	G2EmulationInstanceSetAnimation(In->CharacterInstance, CurrentSection, NewAnim, NewFrame, Frames);
#endif
}

void G2EmulationInstanceSetMode(struct _Instance* instance, int CurrentSection, int Mode)//Matching - 99.38%
{
	struct _G2AnimSection_Type* animSection;

	animSection = &instance->anim.section[(char)CurrentSection];

	if (Mode == 0)
	{
		G2AnimSection_SetPaused(animSection);
	}
	else
	{
		G2AnimSection_SetUnpaused(animSection);

		if (Mode == 1)
		{
			G2AnimSection_SetNoLooping(animSection);
		}
		else
		{
			G2AnimSection_SetLooping(animSection);
		}
	}
}

void G2EmulationSetMode(struct __CharacterState *In, int CurrentSection, int Mode)
{ 
	G2EmulationInstanceSetMode(In->CharacterInstance, CurrentSection, Mode);
}

void G2EmulationInstanceSetAnimSpeed(struct _Instance* instance, int CurrentSection, int speed)
{
	struct _G2AnimSection_Type* animSection;

	animSection = &instance->anim.section[CurrentSection];

	animSection->speedAdjustment = speed;
}

int G2EmulationInstanceQueryAnimation(struct _Instance* instance, int CurrentSection)
{
	struct _G2AnimSection_Type* animSection;
	
	animSection = &instance->anim.section[CurrentSection];

	return animSection->keylistID;
}

int G2EmulationQueryAnimation(struct __CharacterState* In, int CurrentSection)
{
	return G2EmulationInstanceQueryAnimation(In->CharacterInstance, CurrentSection);
}

int G2EmulationInstanceQueryFrame(struct _Instance* instance, int CurrentSection)
{
	return G2AnimSection_GetKeyframeNumber(&instance->anim.section[CurrentSection]);
}

int G2EmulationInstanceQueryLastFrame(struct _Instance* instance, int CurrentSection)
{
	return G2AnimSection_GetStoredKeyframeNumber(&instance->anim.section[CurrentSection]);
}


// autogenerated function stub: 
// int /*$ra*/ G2EmulationInstanceQueryPassedFrame(struct _Instance *instance /*$s2*/, int CurrentSection /*$a1*/, int frame /*$s1*/)
int G2EmulationInstanceQueryPassedFrame(struct _Instance *instance, int CurrentSection, int frame)
{ // line 1314, offset 0x800721bc
	/* begin block 1 */
		// Start line: 1315
		// Start offset: 0x800721BC
		// Variables:
			struct _G2AnimSection_Type *animSection; // $s0
	/* end block 1 */
	// End offset: 0x8007224C
	// End Line: 1329

	/* begin block 2 */
		// Start line: 2594
	/* end block 2 */
	// End Line: 2595
			UNIMPLEMENTED();
	return 0;
}

int G2EmulationQueryFrame(struct __CharacterState* In, int CurrentSection)
{
	return G2EmulationInstanceQueryFrame(In->CharacterInstance, CurrentSection);
}

int G2EmulationInstanceQueryMode(struct _Instance* instance, int CurrentSection)
{
	struct _G2AnimSection_Type* animSection;
	
	animSection = &instance->anim.section[CurrentSection];

	if (!(animSection->flags & 0x1) && !(animSection->flags & 0x2))
	{
		return 1;
	}
	
	return 0;
}

int G2EmulationQueryMode(struct __CharacterState* In, int CurrentSection)
{
	return G2EmulationInstanceQueryMode(In->CharacterInstance, CurrentSection);
}

void G2EmulationInstanceSetStartAndEndSegment(struct _Instance *instance, int CurrentSection, short Start, short End)
{
	struct _G2AnimSection_Type *animSection;
	
	animSection = &instance->anim.section[CurrentSection];
	animSection->firstSeg = Start;
	animSection->segCount = (End - Start) + 1;
}

void G2EmulationSetStartAndEndSegment(struct __CharacterState *In, int CurrentSection, short Start, short End)
{ 
	G2EmulationInstanceSetStartAndEndSegment(In->CharacterInstance, CurrentSection, Start, End);
}

void G2EmulationInstanceSetTotalSections(struct _Instance *instance, short Total)
{
	struct _G2Anim_Type *anim;
	
	anim = &instance->anim;
	
	while (anim->sectionCount < Total)
	{
		G2Anim_AddSection(anim, 0, 0);
	}

	G2Anim_SetCallback(anim, INSTANCE_DefaultAnimCallback, instance);
}

void G2EmulationSetTotalSections(struct __CharacterState* In, short Total)
{
	In->TotalSections = Total;
	
	G2EmulationInstanceSetTotalSections(In->CharacterInstance, In->TotalSections);
}

void G2EmulationInstanceInitSection(struct _Instance* instance, int CurrentSection, void* callback, void* data)
{
	struct _G2AnimSection_Type* animSection;

	typedef unsigned long fn(struct _G2Anim_Type*, int, enum _G2AnimCallbackMsg_Enum, long, long, struct _Instance*);

	animSection = &instance->anim.section[CurrentSection & 0xFF];

	animSection->callback = (fn*)callback;

	animSection->callbackData = data;
}


// autogenerated function stub: 
// void /*$ra*/ G2EmulationSetInterpController_Vector(struct _Instance *instance /*$a0*/, long segment /*$a1*/, long type /*$a2*/, struct _G2SVector3_Type *vec /*$a3*/, int Frames /*stack 16*/, int Data /*stack 20*/)
void G2EmulationSetInterpController_Vector(struct _Instance *instance, long segment, long type, struct _G2SVector3_Type *vec, int Frames, int Data)
{ // line 1440, offset 0x80072428
	/* begin block 1 */
		// Start line: 2880
	/* end block 1 */
	// End Line: 2881
	UNIMPLEMENTED();
}


void StateSwitchStateDataDefault(struct __CharacterState *In, int CurrentSection, void (*NewProcess)(struct __CharacterState* In, int CurrentSection, int Data), int Data)
{
	void(*process)(struct __CharacterState*, int, int);

	process = In->SectionList[CurrentSection].Process;

	StateSwitchStateData(In, CurrentSection, NewProcess, Data);

	process(In, CurrentSection, 0);
}

void StateSwitchStateCharacterDataDefault(struct __CharacterState* In, void (*NewProcess)(struct __CharacterState* In, int CurrentSection, int Data), int Data)
{
	int i;

	for (i = 0; i < In->TotalSections; i++)
	{
		StateSwitchStateDataDefault(In, i, NewProcess, Data);
	}
}

void StateSwitchStateData(struct __CharacterState* In, int CurrentSection, void (*NewProcess)(struct __CharacterState* In, int CurrentSection, int Data), int Data)//Matching - 99.61%
{
	PurgeMessageQueue(&In->SectionList[CurrentSection].Event);
	EnMessageQueueData(&In->SectionList[CurrentSection].Event, 0x100001, Data);

	In->SectionList[CurrentSection].Process = NewProcess;
	In->SectionList[CurrentSection].Process(In, CurrentSection, 0);

	EnMessageQueueData(&In->SectionList[CurrentSection].Event, 0x100004, 0);
	EnMessageQueueData(&In->SectionList[CurrentSection].Event, 0x100004, 0);
}

void StateSwitchStateCharacterData(struct __CharacterState* In, void (*NewProcess)(struct __CharacterState* In, int CurrentSection, int Data), int Data)//Matching - 99.67%
{
	int i;
	typedef void (*func)(struct __CharacterState* In, int CurrentSection, int Data);
	func callbackProc;

	for (i = 0; i < In->TotalSections; i++)
	{
		PurgeMessageQueue(&In->SectionList[i].Event);

		EnMessageQueueData(&In->SectionList[i].Event, 0x100004, 0);

		callbackProc = (func)In->SectionList[i].Process;
		callbackProc(In, i, 0);

		PurgeMessageQueue(&In->SectionList[i].Event);

		EnMessageQueueData(&In->SectionList[i].Event, 0x100001, Data);

		In->SectionList[i].Process = NewProcess;

		callbackProc = (func)In->SectionList[i].Process;
		callbackProc(In, i, 0);
	}
}

void StateGovernState(struct __CharacterState* In, int Frames)//Matching - 90.26%
{
	struct __State* pSectionA;
	struct __State* pSectionB;
	struct _G2AnimSection_Type* animSectionA;
	struct _G2AnimSection_Type* animSectionB;
	struct _G2AnimKeylist_Type* keylist;
	int keylistID;
	int i;

	for (i = 1; i < 3; i++)
	{
		pSectionA = &In->SectionList[i - 1];
		pSectionB = &In->SectionList[i];

		if (pSectionA->Process == pSectionB->Process)
		{
			animSectionA = &In->CharacterInstance->anim.section[(char)(i - 1)];
			animSectionB = &In->CharacterInstance->anim.section[(char)i];

			if (animSectionA->keylistID == animSectionB->keylistID)
			{
				if (!(G2AnimSection_IsInInterpolation(animSectionA)) && !(G2AnimSection_IsInInterpolation(animSectionB)))
				{
					if (G2AnimSection_GetKeyframeNumber(animSectionA) != G2AnimSection_GetKeyframeNumber(animSectionB))
					{
						keylist = animSectionA->keylist;
						keylistID = animSectionA->keylistID;

						G2AnimSection_InterpToKeylistFrame(animSectionB, keylist, keylistID, (G2AnimSection_GetKeyframeNumber(animSectionA) + Frames) % G2AnimKeylist_GetKeyframeCount(keylist), (short)(Frames * 100));
					}
				}
			}
		}
	}
}
