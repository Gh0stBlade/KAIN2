#include "CORE.H"
#include "GAMELOOP.H"
#include "SOUND.H"
#include "PSX/AADSFX.H"
#include "PSX/AADLIB.H"
#include "STRMLOAD.H"
#include "FONT.H"
#include "MEMPACK.H"
#include "STREAM.H"
#include "Game/CAMERA.H"
#include "Game/MATH3D.H"

char soundBuffer[sizeof(struct AadMemoryStruct) + (sizeof(struct _AadSequenceSlot) * 4)];

struct MusicLoadInfo musicInfo; // offset 0x800D1510

int gSramFreeBlocks; // offset 0x800D1500

int gSramFullAlarm; // offset 0x800CEA88

int gSramFullMsgCnt; // offset 0x800CEA8C

int gSramLargestFree; // offset 0x800D12BC

int gSramTotalFree; // offset 0x800D150C

int gSramTotalUsed; // offset 0x800D1508

int gSramUsedBlocks; // offset 0x800D1504

struct SoundEffectChannel soundEffectChannelTbl[16];

struct SoundEffectChannel* SndOpenSfxChannel(unsigned char* channelNum)
{
#if defined(PSX_VERSION)
	int i;
	
	for (i = 0; i < 16; i++)
	{
		if (soundEffectChannelTbl[i].inUse == 1)
		{
			soundEffectChannelTbl[i].inUse = 255;
			soundEffectChannelTbl[i].pitchChangeTime = 0;
			soundEffectChannelTbl[i].volumeChangeTime = 0;

			channelNum[0] = i;

			return &soundEffectChannelTbl[i];
		}
	}

	return NULL;

#elif defined(PC_VERSION)
	int v1; // ecx
	SoundEffectChannel* v2; // eax
	struct SoundEffectChannel* result; // eax
	int v4; // edx

	v1 = 0;
	v2 = soundEffectChannelTbl;
	while (v2->inUse)
	{
		++v2;
		++v1;
		if (v1 >= 16)
			return 0;
	}
	v4 = v1;
	result = &soundEffectChannelTbl[v1];
	result->inUse = -1;
	soundEffectChannelTbl[v4].pitchChangeTime = 0;
	soundEffectChannelTbl[v4].volumeChangeTime = 0;
	*channelNum = v1;
	return result;
#endif
}

void SndCloseSfxChannel(int channelNum)
{
#if defined(PSX_VERSION)
	if (channelNum < 16)
	{
		soundEffectChannelTbl[channelNum].inUse = 0;
	}
#elif defined(PC_VERSION)
	if (channelNum < 16)
		soundEffectChannelTbl[channelNum].inUse = 0;
#endif
}

struct SoundEffectChannel* SndGetSfxChannel(int channelNum)
{
#if defined(PSX_VERSION)
	if (channelNum < 16)
	{
		return &soundEffectChannelTbl[channelNum];
	}

	return NULL;
#elif defined(PC_VERSION)
	if (channelNum >= 16)
		return 0;
	else return &soundEffectChannelTbl[channelNum];
#endif
}

void SOUND_ProcessInstanceSounds(unsigned char* sfxFileData, struct SoundInstance* soundInstTbl, struct _Position* position, int livesInOnePlace, int inSpectral, int hidden, int burning, long* triggerFlags)//Matching - 84.70%
{
#if defined(PSX_VERSION)

	int numSounds;
	int numSfxIDs;
	int i;

	if (gameTrackerX.gameMode != 6 && sfxFileData != NULL && soundInstTbl != NULL &&
		*sfxFileData++ == 190 && *sfxFileData++ == 239)
	{
		numSounds = *sfxFileData;

		sfxFileData += 2;

		for (i = 0; i < numSounds; i++)
		{
			switch (*sfxFileData)
			{
			default:
			{
				sfxFileData += 3;
			}
			break;
			case 0:
			{
				processPeriodicSound(position, livesInOnePlace, inSpectral, hidden, burning, soundInstTbl, (struct ObjectPeriodicSound*)sfxFileData);

				numSfxIDs = (sfxFileData[1] * 2) + 18;

				break;
			}
			case 1:
			{
				processEventSound(position, soundInstTbl, (struct ObjectEventSound*)sfxFileData);

				numSfxIDs = (sfxFileData[1] * 2) + 14;

				break;
			}
			case 2:
			case 3:
			case 4:
			{
				processOneShotSound(position, hidden, burning, triggerFlags, soundInstTbl, (struct ObjectOneShotSound*)sfxFileData);

				numSfxIDs = (sfxFileData[1] * 2) + 14;

				break;
			}
			}

			sfxFileData += numSfxIDs;

			soundInstTbl++;
		}
	}

#elif defined(PC_VERSION)
	struct SoundInstance* v8; // edi
	unsigned __int8* v9; // esi
	unsigned __int8* sfxFileDataa; // [esp+Ch] [ebp+4h]

	if (gameTrackerX.gameMode != 6)
	{
		if (sfxFileData)
		{
			v8 = soundInstTbl;
			if (soundInstTbl)
			{
				if (*sfxFileData == 0xBE && sfxFileData[1] == 0xEF)
				{
					v9 = sfxFileData + 4;
					if (sfxFileData[2])
					{
						sfxFileDataa = (unsigned __int8*)sfxFileData[2];
						do
						{
							switch (*v9)
							{
							case 0u:
								processPeriodicSound(position, livesInOnePlace, inSpectral, hidden, burning, v8, v9);
								v9 += 2 * v9[1] + 18;
								break;
							case 1u:
								processEventSound(position, v8, v9);
								goto LABEL_12;
							case 2u:
							case 3u:
							case 4u:
								processOneShotSound(position, hidden, burning, triggerFlags, v8, v9);
							LABEL_12:
								v9 += 2 * v9[1] + 14;
								break;
							default:
								break;
							}
							++v8;
							--sfxFileDataa;
						} while (sfxFileDataa);
					}
				}
			}
		}
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ SOUND_EndInstanceSounds(unsigned char *sfxFileData /*$s0*/, struct SoundInstance *soundInstTbl /*$a1*/)
void SOUND_EndInstanceSounds(unsigned char *sfxFileData, struct SoundInstance *soundInstTbl)
{ // line 149, offset 0x8003e86c
#if defined(PC_VERSION)
	struct SoundInstance* v2; // esi
	unsigned __int8* v3; // edi
	int v4; // ebp
	SoundEffectChannel* v5; // eax
	unsigned int channel; // eax
	SoundEffectChannel* v7; // ecx

	if (sfxFileData)
	{
		v2 = soundInstTbl;
		if (soundInstTbl)
		{
			if (*sfxFileData == 0xBE && sfxFileData[1] == 0xEF)
			{
				v3 = sfxFileData + 4;
				if (sfxFileData[2])
				{
					v4 = sfxFileData[2];
					do
					{
						switch (*v3)
						{
						case 0u:
							v3 += 2 * v3[1] + 18;
							goto LABEL_10;
						case 1u:
							v3 += 2 * v3[1] + 14;
						LABEL_10:
							if (v2->channel >= 0x10u)
								v5 = 0;
							else
								v5 = &soundEffectChannelTbl[v2->channel];
							if (!v5)
								goto LABEL_23;
							aadStopSfx(v5->handle);
							if (v2->channel < 0x10u)
								soundEffectChannelTbl[v2->channel].inUse = 0;
							break;
						case 2u:
						case 3u:
						case 4u:
							v3 += 2 * v3[1] + 14;
							channel = v2->channel;
							if (channel >= 0x10)
								v7 = 0;
							else
								v7 = &soundEffectChannelTbl[channel];
							if (!v7)
								goto LABEL_23;
							if (v2->channel < 0x10u)
								soundEffectChannelTbl[channel].inUse = 0;
							break;
						default:
							goto LABEL_23;
						}
						v2->channel = -1;
						v2->state = 0;
					LABEL_23:
						++v2;
						--v4;
					} while (v4);
				}
			}
		}
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// int /*$ra*/ isOkayToPlaySound(int flags /*$s0*/, int spectralPlane /*$s1*/, int hidden /*$s2*/, int burning /*$s3*/)
int isOkayToPlaySound(int flags, int spectralPlane, int hidden, int burning)
{ // line 218, offset 0x8003e9d8
	int v4; // eax
	int v5; // eax
	int v6; // eax
	int result; // eax
#if defined(PC_VERSION)
	if ((flags & 0xF) != 0)
	{
		v4 = GAMELOOP_GetTimeOfDay() - 600;
		if (v4)
		{
			v5 = v4 - 1200;
			if (v5)
				v6 = v5 == 100 ? 8 : 2;
			else
				v6 = 4;
		}
		else
		{
			v6 = 1;
		}
		if ((v6 & flags) == 0)
			return 0;
	}
	result = spectralPlane;
	if ((flags & 0x10) == 0 || spectralPlane)
		return ((flags & 0x20) == 0 || !spectralPlane)
		&& ((flags & 0x40) == 0 || !hidden)
		&& ((flags & 0x80u) == 0 || burning);
	return result;
#else
	UNIMPLEMENTED();
	return NULL;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ setPeriodicSoundStateOff(struct SoundInstance *soundInst /*$s0*/, struct ObjectPeriodicSound *sound /*$s1*/)
void setPeriodicSoundStateOff(struct SoundInstance *soundInst, struct ObjectPeriodicSound *sound)
{ // line 266, offset 0x8003eaec
#if defined(PC_VERSION)
	uchar offTimeVariation; // bl

	if (soundInst->channel < 0x10u)
		soundEffectChannelTbl[soundInst->channel].inUse = 0;
	soundInst->channel = -1;
	soundInst->state = 3;
	soundInst->delay = sound->offTime;
	if (sound->offTimeVariation)
	{
		offTimeVariation = sound->offTimeVariation;
		soundInst->delay += offTimeVariation - rand() % (2 * offTimeVariation);
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ processPeriodicSound(_Position *position /*$fp*/, int livesInOnePlane /*$s4*/, int inSpectral /*$s5*/, int hidden /*$s7*/, int burning /*stack 16*/, struct SoundInstance *soundInst /*stack 20*/, struct ObjectPeriodicSound *sound /*stack 24*/)
void processPeriodicSound(_Position *position, int livesInOnePlane, int inSpectral, int hidden, int burning, struct SoundInstance *soundInst, struct ObjectPeriodicSound *sound)
{ // line 280, offset 0x8003eb78
#if defined(PC_VERSION)
	int MorphType; // edi
	uchar initialDelayVariation; // bl
	SoundEffectChannel* v9; // ebp
	struct ObjectPeriodicSound* v10; // eax
	uchar offTimeVariation; // bl
	int flags; // ebx
	int v13; // eax
	int v14; // eax
	int v15; // eax
	uchar delay; // al
	uchar v17; // al
	uchar onTimeVariation; // bl
	uchar maxVolVariation; // bl
	ushort pitchVariation; // bx
	uchar state; // al
	uchar v22; // bl
	int v23; // ebx
	int v24; // eax
	int v25; // eax
	int v26; // eax
	uchar v27; // al
	int v28; // ecx
	SoundEffectChannel* v29; // eax
	SoundEffectChannel* v30; // edi
	uchar v31; // bl
	ushort v32; // bx
	int v33; // edx
	unsigned int v34; // eax
	uchar v35; // bl
	int v36; // eax
	int v37; // [esp+10h] [ebp-4h]

	MorphType = gameTrackerX.gameData.asmData.MorphType;
	v37 = gameTrackerX.gameData.asmData.MorphType;
	if ((soundInst->state & 0xF) != 1)
	{
		if ((soundInst->state & 0xF) != 2)
		{
			if ((soundInst->state & 0xF) != 3)
			{
				soundInst->channel = -1;
				soundInst->state = 1;
				soundInst->delay = sound->initialDelay;
				if (sound->initialDelayVariation)
				{
					initialDelayVariation = sound->initialDelayVariation;
					soundInst->delay += initialDelayVariation - rand() % (2 * initialDelayVariation);
				}
				return;
			}
			goto LABEL_68;
		}
		if (soundInst->channel >= 0x10u)
			v9 = 0;
		else
			v9 = &soundEffectChannelTbl[soundInst->channel];
		if (!v9)
			return;
		if (!aadIsSfxPlayingOrRequested(v9->handle))
			goto LABEL_16;
		if (!aadIsSfxPlaying(v9->handle))
			return;
		if (livesInOnePlane)
		{
			if (inSpectral)
			{
				if (!MorphType)
				{
					aadStopSfx(v9->handle);
				LABEL_16:
					if (soundInst->channel < 0x10u)
						soundEffectChannelTbl[soundInst->channel].inUse = 0;
					v10 = sound;
					soundInst->channel = -1;
					soundInst->state = 3;
					soundInst->delay = sound->offTime;
				LABEL_23:
					if (v10->offTimeVariation)
					{
						offTimeVariation = v10->offTimeVariation;
						soundInst->delay += offTimeVariation - rand() % (2 * offTimeVariation);
					}
					return;
				}
			}
			else if (MorphType)
			{
				aadStopSfx(v9->handle);
				if (soundInst->channel < 0x10u)
					soundEffectChannelTbl[soundInst->channel].inUse = 0;
				v10 = sound;
				soundInst->channel = -1;
				soundInst->state = 3;
				soundInst->delay = sound->offTime;
				goto LABEL_23;
			}
		}
		flags = sound->flags;
		if ((flags & 0xF) != 0
			&& ((v13 = GAMELOOP_GetTimeOfDay() - 600) == 0
				? (v15 = 1)
				: (v14 = v13 - 1200) == 0
				? (v15 = 4)
				: v14 == 100
				? (v15 = 8)
				: (v15 = 2),
				(flags & v15) == 0)
			|| (flags & 0x10) != 0 && !v37
			|| (flags & 0x20) != 0 && v37
			|| (flags & 0x40) != 0 && hidden
			|| (flags & 0x80u) != 0 && !burning)
		{
			aadStopSfx(v9->handle);
			if (soundInst->channel < 0x10u)
				soundEffectChannelTbl[soundInst->channel].inUse = 0;
			soundInst->channel = -1;
			soundInst->state = 3;
			soundInst->delay = sound->offTime;
			goto LABEL_65;
		}
		delay = soundInst->delay;
		if (delay)
		{
			v17 = delay - 1;
		}
		else
		{
			if (sound->offTime)
			{
				aadStopSfx(v9->handle);
				if (soundInst->channel < 0x10u)
					soundEffectChannelTbl[soundInst->channel].inUse = 0;
				soundInst->channel = -1;
				soundInst->state = 3;
				soundInst->delay = sound->offTime;
				if (!sound->offTimeVariation)
					goto LABEL_60;
				onTimeVariation = sound->offTimeVariation;
			}
			else
			{
				if (sound->maxVolVariation)
				{
					v9->volume = sound->maxVolume;
					maxVolVariation = sound->maxVolVariation;
					v9->volume += maxVolVariation - (unsigned __int16)(rand() % (2 * maxVolVariation));
				}
				if (sound->pitchVariation)
				{
					v9->pitch = sound->pitch;
					pitchVariation = sound->pitchVariation;
					v9->pitch += pitchVariation - rand() % (2 * pitchVariation);
				}
				soundInst->delay = sound->onTime;
				if (!sound->onTimeVariation)
					goto LABEL_60;
				onTimeVariation = sound->onTimeVariation;
			}
			v17 = onTimeVariation - rand() % (2 * onTimeVariation) + soundInst->delay;
		}
		soundInst->delay = v17;
	LABEL_60:
		state = soundInst->state;
		if ((state & 0x10) == 0)
		{
			soundInst->state = state | 0x10;
			return;
		}
		soundInst->state = state & 0xEF;
		if (SOUND_Update3dSound(position, v9->handle, v9->pitch, v9->volume, sound->minVolDistance))
			return;
		aadStopSfx(v9->handle);
		if (soundInst->channel < 0x10u)
			soundEffectChannelTbl[soundInst->channel].inUse = 0;
		soundInst->channel = -1;
		soundInst->state = 3;
		soundInst->delay = sound->offTime;
	LABEL_65:
		if (sound->offTimeVariation)
		{
			v22 = sound->offTimeVariation;
			soundInst->delay += v22 - rand() % (2 * v22);
		}
		return;
	}
LABEL_68:
	if (livesInOnePlane)
	{
		if (inSpectral)
		{
			if (!gameTrackerX.gameData.asmData.MorphType)
				return;
		}
		else if (gameTrackerX.gameData.asmData.MorphType)
		{
			return;
		}
	}
	v23 = sound->flags;
	if ((v23 & 0xF) == 0
		|| ((v24 = GAMELOOP_GetTimeOfDay() - 600) == 0
			? (v26 = 1)
			: (v25 = v24 - 1200) == 0
			? (v26 = 4)
			: v25 == 100
			? (v26 = 8)
			: (v26 = 2),
			(v23 & v26) != 0))
	{
		if (((v23 & 0x10) == 0 || v37)
			&& ((v23 & 0x20) == 0 || !v37)
			&& ((v23 & 0x40) == 0 || !hidden)
			&& ((v23 & 0x80u) == 0 || burning))
		{
			v27 = soundInst->delay;
			if (v27)
			{
				soundInst->delay = v27 - 1;
			}
			else
			{
				v28 = 0;
				v29 = soundEffectChannelTbl;
				while (v29->inUse)
				{
					++v29;
					++v28;
					if ((int)v29 >= (int)&musicInfo)
					{
						v30 = 0;
						goto LABEL_96;
					}
				}
				v36 = v28;
				v30 = &soundEffectChannelTbl[v28];
				v30->inUse = -1;
				soundEffectChannelTbl[v36].pitchChangeTime = 0;
				soundEffectChannelTbl[v36].volumeChangeTime = 0;
				soundInst->channel = v28;
			LABEL_96:
				if (v30)
				{
					v30->volume = sound->maxVolume;
					if (sound->maxVolVariation)
					{
						v31 = sound->maxVolVariation;
						v30->volume += v31 - (unsigned __int16)(rand() % (2 * v31));
					}
					v30->pitch = sound->pitch;
					if (sound->pitchVariation)
					{
						v32 = sound->pitchVariation;
						v30->pitch += v32 - rand() % (2 * v32);
					}
					if (sound->numSfxIDs <= 1u)
						v33 = 0;
					else
						v33 = rand() % sound->numSfxIDs;
					v34 = SOUND_Play3dSound(
						position,
						*((unsigned __int16*)&sound[1].type + v33),
						v30->pitch,
						v30->volume,
						sound->minVolDistance);
					v30->handle = v34;
					if (v34)
					{
						soundInst->state = 2;
						soundInst->delay = sound->onTime;
						if (sound->onTimeVariation)
						{
							v35 = sound->onTimeVariation;
							soundInst->delay += v35 - rand() % (2 * v35);
						}
					}
					else
					{
						if (soundInst->channel < 0x10u)
							soundEffectChannelTbl[soundInst->channel].inUse = 0;
						soundInst->channel = -1;
					}
				}
			}
		}
	}
#else
UNIMPLEMENTED();
#endif
}

void processEventSound(struct _Position* position, struct SoundInstance* soundInst, struct ObjectEventSound* sound)//Matching - 88.07%
{
#if defined(PSX_VERSION)
	int spectralPlane;
	int sfxIDNum;
	struct SoundEffectChannel* channel;

	spectralPlane = gameTrackerX.gameData.asmData.MorphType;
	sfxIDNum = soundInst->state & 0xF;

	if (sfxIDNum != 1)
	{
		if (sfxIDNum < 2 || (soundInst->state & 0xF) != 2)
		{
			soundInst->channel = -1;
			soundInst->state = 1;
			soundInst->delay = 0;

			return;
		}
		
		channel = SndGetSfxChannel(soundInst->channel);

		if (channel)
		{
			if (!SndIsPlayingOrRequested(channel->handle))
			{
				SndCloseSfxChannel(soundInst->channel);

				soundInst->channel = -1;
				
				soundInst->state = 1;
				return;
			}

			if (SndIsPlaying(channel->handle))
			{
				if (channel->pitchChangeTime)
				{
					channel->pitch = channel->pitch + channel->pitchChangePerUpdate;
					
					channel->pitchChangeError = channel->pitchChangeError + channel->pitchChangeErrPerUpdate;

					if (channel->pitchChangeError >= channel->pitchChangeTimeSave)
					{
						channel->pitch += channel->pitchChangeSign;
						
						channel->pitchChangeError = channel->pitchChangeError - channel->pitchChangeTimeSave;
					}
					
					--channel->pitchChangeTime;
				}
				if (channel->volumeChangeTime)
				{
					channel->volume = channel->volume + channel->volumeChangePerUpdate;
					
					channel->volumeChangeError = channel->volumeChangeError + channel->volumeChangeErrPerUpdate;
					
					if (channel->volumeChangeError >= channel->volumeChangeTimeSave)
					{
						channel->volume += channel->volumeChangeSign;
						channel->volumeChangeError = channel->volumeChangeError - channel->volumeChangeTimeSave;
					}
					
					--channel->volumeChangeTime;
				}

				if ((soundInst->state & 0x10) != 0)
				{
					soundInst->state &= 0xEF;

					if (!SOUND_Update3dSound(position, channel->handle, channel->pitch, channel->volume, sound->minVolDistance))
					{
						SndEndLoop(channel->handle);

						SndCloseSfxChannel(soundInst->channel);

						soundInst->channel = -1;
					}
				}
				else
				{
					soundInst->state |= 0x10;
				}

				if (!isOkayToPlaySound(sound->flags, spectralPlane, 0, 0))
				{
					SndEndLoop(channel->handle);

					SndCloseSfxChannel(soundInst->channel);

					soundInst->channel = -1;
				}
			}
		}
		else if (isOkayToPlaySound(sound->flags, spectralPlane, 0, 0))
		{
			channel = SndOpenSfxChannel(&soundInst->channel);

			if (channel != NULL)
			{
				channel->volume = sound->maxVolume;
				
				if (sound->maxVolVariation)
				{
					channel->volume += (sound->maxVolVariation - (rand() % (2 * sound->maxVolVariation)));
				}

				channel->pitch = sound->pitch;
				
				if (sound->pitchVariation)
				{
					channel->pitch += sound->pitchVariation - rand() % (2 * sound->pitchVariation);
				}

				sfxIDNum = (sound->numSfxIDs < 2) ? 0 : ((rand() % sound->numSfxIDs));

				channel->handle = SOUND_Play3dSound(position, ((unsigned short*)(sound + 1))[sfxIDNum], channel->pitch, channel->volume, sound->minVolDistance);
				
				if (!channel)
				{
					SndCloseSfxChannel(soundInst->channel);
				}

				soundInst->channel = -1;
			}
		}
	}
#elif defined(PC_VERSION)
	struct SoundInstance* v3; // edi
	SoundEffectChannel* v4; // esi
	__int16 pitchChangePerUpdate; // dx
	__int16 pitchChangeError; // ax
	__int16 pitchChangeTimeSave; // dx
	__int16 volumeChangeErrPerUpdate; // cx
	__int16 volumeChangeTimeSave; // ax
	uchar state; // al
	int flags; // ebx
	int v12; // eax
	int v13; // eax
	int v14; // eax
	int v15; // ebx
	int v16; // eax
	int v17; // eax
	int v18; // eax
	int v19; // ecx
	SoundEffectChannel* v20; // eax
	SoundEffectChannel* v21; // esi
	uchar maxVolVariation; // bl
	ushort pitchVariation; // di
	int v24; // edx
	unsigned int v25; // eax
	int v26; // eax
	int MorphType; // [esp+10h] [ebp-4h]

	v3 = soundInst;
	MorphType = gameTrackerX.gameData.asmData.MorphType;
	if ((soundInst->state & 0xF) == 1)
		return;
	if ((soundInst->state & 0xF) != 2)
	{
		soundInst->channel = -1;
		soundInst->state = 1;
		soundInst->delay = 0;
		return;
	}
	if (soundInst->channel >= 0x10u)
		v4 = 0;
	else
		v4 = &soundEffectChannelTbl[soundInst->channel];
	if (v4)
	{
		if (!aadIsSfxPlayingOrRequested(v4->handle))
		{
			if (soundInst->channel < 0x10u)
				soundEffectChannelTbl[soundInst->channel].inUse = 0;
			soundInst->channel = -1;
			soundInst->state = 1;
			return;
		}
		if (aadIsSfxPlaying(v4->handle))
		{
			if (v4->pitchChangeTime)
			{
				pitchChangePerUpdate = v4->pitchChangePerUpdate;
				v4->pitchChangeError += v4->pitchChangeErrPerUpdate;
				pitchChangeError = v4->pitchChangeError;
				v4->pitch += pitchChangePerUpdate;
				if (pitchChangeError >= v4->pitchChangeTimeSave)
				{
					pitchChangeTimeSave = v4->pitchChangeTimeSave;
					v4->pitch += v4->pitchChangeSign;
					v4->pitchChangeError -= pitchChangeTimeSave;
				}
				--v4->pitchChangeTime;
			}
			if (v4->volumeChangeTime)
			{
				volumeChangeErrPerUpdate = v4->volumeChangeErrPerUpdate;
				v4->volume += v4->volumeChangePerUpdate;
				v4->volumeChangeError += volumeChangeErrPerUpdate;
				if (v4->volumeChangeError >= v4->volumeChangeTimeSave)
				{
					volumeChangeTimeSave = v4->volumeChangeTimeSave;
					v4->volume += v4->volumeChangeSign;
					v4->volumeChangeError -= volumeChangeTimeSave;
				}
				--v4->volumeChangeTime;
			}
			state = soundInst->state;
			if ((state & 0x10) != 0)
			{
				soundInst->state = state & 0xEF;
				if (!SOUND_Update3dSound(position, v4->handle, v4->pitch, v4->volume, sound->minVolDistance))
				{
					aadStopSfx(v4->handle);
					if (soundInst->channel < 0x10u)
						soundEffectChannelTbl[soundInst->channel].inUse = 0;
					soundInst->channel = -1;
				}
			}
			else
			{
				soundInst->state = state | 0x10;
			}
			if ((flags = sound->flags, (flags & 0xF) != 0)
				&& ((v12 = GAMELOOP_GetTimeOfDay() - 600) == 0
					? (v14 = 1)
					: (v13 = v12 - 1200) == 0
					? (v14 = 4)
					: v13 == 100
					? (v14 = 8)
					: (v14 = 2),
					(flags & v14) == 0)
				|| (flags & 0x10) != 0 && !MorphType
				|| (flags & 0x20) != 0 && MorphType
				|| (flags & 0x80u) != 0)
			{
				aadStopSfx(v4->handle);
				if (soundInst->channel < 0x10u)
				{
					soundEffectChannelTbl[soundInst->channel].inUse = 0;
					soundInst->channel = -1;
					return;
				}
				goto LABEL_72;
			}
		}
	}
	else
	{
		v15 = sound->flags;
		if ((v15 & 0xF) == 0
			|| ((v16 = GAMELOOP_GetTimeOfDay() - 600) == 0
				? (v18 = 1)
				: (v17 = v16 - 1200) == 0
				? (v18 = 4)
				: v17 == 100
				? (v18 = 8)
				: (v18 = 2),
				(v15 & v18) != 0))
		{
			if (((v15 & 0x10) == 0 || MorphType) && ((v15 & 0x20) == 0 || !MorphType) && (v15 & 0x80u) == 0)
			{
				v19 = 0;
				v20 = soundEffectChannelTbl;
				while (v20->inUse)
				{
					++v20;
					++v19;
					if ((int)v20 >= (int)&musicInfo)
					{
						v21 = 0;
						goto LABEL_61;
					}
				}
				v26 = v19;
				v21 = &soundEffectChannelTbl[v19];
				v21->inUse = -1;
				soundEffectChannelTbl[v26].pitchChangeTime = 0;
				soundEffectChannelTbl[v26].volumeChangeTime = 0;
				soundInst->channel = v19;
			LABEL_61:
				if (v21)
				{
					v21->volume = sound->maxVolume;
					if (sound->maxVolVariation)
					{
						maxVolVariation = sound->maxVolVariation;
						v21->volume += maxVolVariation - (unsigned __int16)(rand() % (2 * maxVolVariation));
					}
					v21->pitch = sound->pitch;
					if (sound->pitchVariation)
					{
						pitchVariation = sound->pitchVariation;
						v21->pitch += pitchVariation - rand() % (2 * pitchVariation);
						v3 = soundInst;
					}
					v24 = sound->numSfxIDs <= 1u ? 0 : rand() % sound->numSfxIDs;
					v25 = SOUND_Play3dSound(
						position,
						*((unsigned __int16*)&sound[1].type + v24),
						v21->pitch,
						v21->volume,
						sound->minVolDistance);
					v21->handle = v25;
					if (!v25)
					{
						if (v3->channel < 0x10u)
							soundEffectChannelTbl[v3->channel].inUse = 0;
					LABEL_72:
						v3->channel = -1;
					}
				}
			}
		}
	}
#else
UNIMPLEMENTED();
#endif
}

void SOUND_StartInstanceSound(struct SoundInstance* soundInst)
{
#if defined(PSX_VERSION)
	if ((soundInst->state & 0xF) == 1)
	{
		soundInst->state = 2;
	}
#elif defined(PC_VERSION)
	if ((soundInst->state & 0xF) == 1)
		soundInst->state = 2;
#endif
}

void SOUND_StopInstanceSound(struct SoundInstance* soundInst)//Matching - 99.35%
{
#if defined(PSX_VERSION)
	struct SoundEffectChannel* channel;

	channel = (struct SoundEffectChannel*)SndGetSfxChannel(soundInst->channel);
	
	if (channel != NULL)
	{
		SndEndLoop(channel->handle);

		SndCloseSfxChannel(soundInst->channel);

		soundInst->channel = -1;
	}

	soundInst->state = 1;
#elif defined(PC_VERSION)
	SoundEffectChannel* v1; // eax

	if (soundInst->channel >= 0x10u)
		v1 = 0;
	else
		v1 = &soundEffectChannelTbl[soundInst->channel];
	if (v1)
	{
		aadStopSfx(v1->handle);
		if (soundInst->channel < 0x10u)
			soundEffectChannelTbl[soundInst->channel].inUse = 0;
		soundInst->channel = -1;
	}
	soundInst->state = 1;
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// int /*$ra*/ SOUND_IsInstanceSoundLoaded(unsigned char *sfxFileData /*$a0*/, long soundNumber /*$a1*/)
int SOUND_IsInstanceSoundLoaded(unsigned char *sfxFileData, long soundNumber)
{ // line 594, offset 0x8003f438
#if defined(PC_VERSION)
	int v2; // edx
	unsigned __int8* v3; // eax
	unsigned __int16* v4; // esi
	int v5; // edi
	int v7; // edx
	int v8; // edi
	unsigned __int16 v9; // ax
	int IsSfxLoaded; // eax

	if (!sfxFileData)
		return -1;
	if (*sfxFileData != 0xBE)
		return -1;
	if (sfxFileData[1] != 0xEF)
		return -1;
	v2 = 0;
	v3 = sfxFileData + 4;
	if (!sfxFileData[2])
		return -1;
	while (1)
	{
		if (*v3)
		{
			v4 = (unsigned __int16*)(v3 + 14);
			v5 = v3[1];
			v3 += 2 * v5 + 14;
		}
		else
		{
			v4 = (unsigned __int16*)(v3 + 18);
			v5 = v3[1];
			v3 += 2 * v5 + 18;
		}
		if (v2 == soundNumber)
			break;
		if (++v2 >= sfxFileData[2])
			return -1;
	}
	v7 = v5;
	v8 = v5 - 1;
	if (!v7)
		return 1;
	while (1)
	{
		v9 = *v4++;
		IsSfxLoaded = aadIsSfxLoaded(v9);
		if (!IsSfxLoaded)
			break;
		if (IsSfxLoaded == -1)
			return -1;
		if (!v8--)
			return 1;
	}
	return 0;
#else
	UNIMPLEMENTED();
	return 0;
#endif

}


// autogenerated function stub: 
// void /*$ra*/ SOUND_SetInstanceSoundPitch(struct SoundInstance *soundInst /*$a0*/, long pitchChangeAmt /*$s1*/, long time /*$s0*/)
void SOUND_SetInstanceSoundPitch(struct SoundInstance *soundInst, long pitchChangeAmt, long time)
{ // line 665, offset 0x8003f534
#if defined(PC_VERSION)
	WORD* v3; // ecx
	int v4; // esi
	bool v5; // zf
	int v6; // edx

	if ((soundInst->state & 0xF) == 2)
	{
		v3 = soundInst->channel >= 0x10u ? 0 : (WORD*)(36 * soundInst->channel + 12979232);
		if (v3)
		{
			v4 = time;
			v5 = time == 0;
			if (time < 0)
			{
				v4 = -time;
				v5 = time == 0;
			}
			if (v5)
			{
				v3[12] = 0;
				v3[11] += pitchChangeAmt;
			}
			else
			{
				v3[15] = pitchChangeAmt >= 0 ? 1 : -1;
				v3[14] = pitchChangeAmt / v4;
				v6 = pitchChangeAmt % v4;
				if (pitchChangeAmt % v4 < 0)
					v6 = -v6;
				v3[16] = v6;
				v3[17] = 0;
				v3[12] = v4;
				v3[13] = v4;
			}
		}
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ SOUND_SetInstanceSoundVolume(struct SoundInstance *soundInst /*$a0*/, long volumeChangeAmt /*$s0*/, long time /*$s1*/)
void SOUND_SetInstanceSoundVolume(struct SoundInstance *soundInst, long volumeChangeAmt, long time)
{ // line 694, offset 0x8003f5f4
#if defined(PC_VERSION)
	SoundEffectChannel* v3; // esi
	int v4; // edi
	int v5; // ecx
	bool v6; // sf
	int volume; // eax
	int v8; // eax
	__int16 v9; // ax
	int v10; // edx

	if ((soundInst->state & 0xF) == 2)
	{
		v3 = soundInst->channel >= 0x10u ? 0 : &soundEffectChannelTbl[soundInst->channel];
		if (v3)
		{
			v4 = time;
			if (time < 0)
				v4 = -time;
			v5 = volumeChangeAmt;
			v6 = volumeChangeAmt < 0;
			if (volumeChangeAmt > 0)
			{
				volume = v3->volume;
				if (volumeChangeAmt + volume > 127)
					v5 = 127 - volume;
				v6 = v5 < 0;
			}
			if (v6)
			{
				v8 = v3->volume;
				if (v5 + v8 < 0)
					v5 = -v8;
			}
			if (v4)
			{
				v3->volumeChangePerUpdate = v5 / v4;
				v9 = (v5 >= 0) - 1;
				v9 = v9 & ~1;
				v3->volumeChangeSign = v9 + 1;
				v10 = v5 % v4;
				if (v5 % v4 < 0)
					v10 = -v10;
				v3->volumeChangeErrPerUpdate = v10;
				v3->volumeChangeError = 0;
				v3->volumeChangeTime = v4;
				v3->volumeChangeTimeSave = v4;
			}
			else
			{
				v3->volume += v5;
				v3->volumeChangeTime = 0;
			}
		}
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ processOneShotSound(_Position *position /*$s6*/, int hidden /*$t0*/, int burning /*$t1*/, long *triggerFlags /*$s4*/, struct SoundInstance *soundInst /*stack 16*/, struct ObjectOneShotSound *sound /*stack 20*/)
void processOneShotSound(_Position *position, int hidden, int burning, long *triggerFlags, struct SoundInstance *soundInst, struct ObjectOneShotSound *sound)
{ // line 741, offset 0x8003f6f8
	/* begin block 1 */
		// Start line: 742
		// Start offset: 0x8003F6F8
		// Variables:
			struct SoundEffectChannel *channel; // $s0
			int sfxIDNum; // $v1
			int sfxToneID; // $a1
			long triggerMask; // $s3
			int spectralPlane; // $a1
	/* end block 1 */
	// End offset: 0x8003FA18
	// End Line: 848

	/* begin block 2 */
		// Start line: 1482
	/* end block 2 */
	// End Line: 1483
			UNIMPLEMENTED();
}

unsigned long SOUND_Play3dSound(_Position* position, int sfxToneID, int pitch, int maxVolume, int minVolDist)
{
#if defined(PSX_VERSION)
	long dx;
	long dy;
	long dz;
	long objDist;
	long workMinVolDist;
	int angle;
	int quadrant;
	int qpos;
	int pan;
	int volume;

	if (maxVolume != 0)
	{
		if (minVolDist == 0)
		{
			return SndPlayVolPan(sfxToneID, maxVolume, 64, pitch);
		}
		
		workMinVolDist = minVolDist;

		if (theCamera.mode == 5 && (gameTrackerX.gameFlags & 0x10))
		{
			dx = position->x - theCamera.core.position.x;
			dy = position->y - theCamera.core.position.y;
			dz = position->z - theCamera.core.position.z;
		}
		else
		{
			dx = position->x - theCamera.focusInstance->position.x;
			dy = position->y - theCamera.focusInstance->position.y;
			dz = position->z - theCamera.focusInstance->position.z;
		}

		objDist = MATH3D_FastSqrt0(dx * dx + dy * dy + dz * dz);

		if (workMinVolDist >= objDist)
		{
			volume = (workMinVolDist - objDist) / (workMinVolDist / maxVolume);
			
			qpos = (theCamera.core.rotation.z - (ratan2(dy, dx) + 1024)) & 0x3FF;
			angle = (theCamera.core.rotation.z - (ratan2(dy, dx) + 1024)) & 0xFFF;
			quadrant = ((theCamera.core.rotation.z - (ratan2(dy, dx) + 1024)) & 0xFFF) >> 10;

			if (volume >= 128)
			{
				volume = 127;
			}

			if (quadrant == 1)
			{
				pan = qpos >> 4;
			}
			else if (quadrant == 2)
			{
				pan = angle + 64;
			}
			else if (quadrant == 0)
			{
				pan = 63 - qpos;
			}
			else
			{
				pan = 127 - (qpos >> 4);
			}

			if (pan < 64)
			{
				pan = 63 - ((63 - pan) * ((objDist << 8) / workMinVolDist)) >> 8;
			}

			pan = (((pan - 64) * ((objDist << 8) / workMinVolDist)) >> 8)+ 64;
			
			return SndPlayVolPan(sfxToneID, volume, pan, pitch);
		}
	}

	return 0;

#elif defined(PC_VERSION)
	int z; // eax
	int v7; // esi
	int v8; // edi
	int v9; // ecx
	int v10; // ebp
	__int16 v11; // cx
	int v12; // esi
	int v13; // ecx
	int v14; // esi
	int v15; // edi
	int v16; // esi
	int v17; // ecx
	int v18; // esi
	int v19; // esi
	int v20; // eax
	unsigned __int16 v21; // cx

	if (maxVolume)
	{
		if (!minVolDist)
		{
			if (gameTrackerX.sound.gSfxOn)
				return aadPlaySfx(sfxToneID, (unsigned __int16)maxVolume, 64, (__int16)pitch);
			return 0;
		}
		if (theCamera.mode == 5 && (gameTrackerX.gameFlags & 0x10) != 0)
		{
			z = position->z;
			v7 = position->x - theCamera.core.position.x;
			v8 = position->y - theCamera.core.position.y;
			v9 = theCamera.core.position.z;
		}
		else
		{
			z = position->z;
			v7 = position->x - theCamera.focusInstance->position.x;
			v9 = theCamera.focusInstance->position.z;
			v8 = position->y - theCamera.focusInstance->position.y;
		}
		v10 = MATH3D_FastSqrt0((z - v9) * (z - v9) + v8 * v8 + v7 * v7);
		if (v10 <= minVolDist)
		{
			v11 = theCamera.core.rotation.z - (ratan2(v8, v7) + 1024);
			v12 = v11 & 0xFFF;
			v13 = v11 & 0x3FF;
			v14 = v12 >> 10;
			v15 = (minVolDist - v10) / (minVolDist / maxVolume);
			if (v15 > 127)
				v15 = 127;
			if (v14)
			{
				v16 = v14 - 1;
				if (!v16)
				{
					v19 = v13 >> 4;
					goto LABEL_20;
				}
				if (v16 == 1)
				{
					v19 = (v13 >> 4) + 64;
					goto LABEL_20;
				}
				v17 = v13 >> 4;
				v18 = 127;
			}
			else
			{
				v17 = v13 >> 4;
				v18 = 63;
			}
			v19 = v18 - v17;
		LABEL_20:
			v20 = (v10 << 8) / minVolDist;
			if (v19 >= 64)
				v21 = ((v20 * (v19 - 64)) >> 8) + 64;
			else
				v21 = 63 - ((v20 * (63 - v19)) >> 8);
			if (gameTrackerX.sound.gSfxOn)
				return aadPlaySfx(sfxToneID, (unsigned __int16)v15, v21, (__int16)pitch);
		}
	}
#endif
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// unsigned long /*$ra*/ SOUND_Update3dSound(_Position *position /*$t0*/, unsigned long handle /*$s5*/, int pitch /*$s6*/, int maxVolume /*$s4*/, int minVolDist /*stack 16*/)
unsigned long SOUND_Update3dSound(_Position *position, unsigned long handle, int pitch, int maxVolume, int minVolDist)
{ // line 962, offset 0x8003fc7c
	/* begin block 1 */
		// Start line: 963
		// Start offset: 0x8003FC7C
		// Variables:
			long dx; // $s1
			long dy; // $s0
			long dz; // $a0
			long objDist; // $s3
			long workMinVolDist; // $s2
			int angle; // $v0
			int quadrant; // $a0
			int qpos; // $v1
			int pan; // $a2
			int volume; // $a1
	/* end block 1 */
	// End offset: 0x8003FE88
	// End Line: 1054

	/* begin block 2 */
		// Start line: 2084
	/* end block 2 */
	// End Line: 2085
			UNIMPLEMENTED();
	return 0;
}

void SOUND_HandleGlobalValueSignal(int name, long data)
{
}

void SOUND_Init()
{
#if defined(PSX_VERSION)
	struct AadInitAttr initAttr;
	initAttr.numSlots = 4;
	initAttr.nonBlockLoadProc = LOAD_NonBlockingFileLoad;
	initAttr.nonBlockBufferedLoadProc = LOAD_NonBlockingBufferedLoad;
	initAttr.memoryMallocProc = MEMPACK_Malloc;
	initAttr.memoryFreeProc = MEMPACK_Free;
	initAttr.updateMode = 1;

	aadGetMemorySize(&initAttr);
	aadInit(&initAttr, (unsigned char*)&soundBuffer[0]);
	gameTrackerX.sound.gMasterVol = 16383;
	SOUND_SetMusicVolume(127);
	SOUND_SetSfxVolume(127);
	SOUND_SetVoiceVolume(80);
	gameTrackerX.sound.gSfxOn = 1;
	gameTrackerX.sound.gMusicOn = 1;
	gameTrackerX.sound.gVoiceOn = 1;
	gameTrackerX.sound.soundsLoaded = 0;
	SOUND_MusicInit();
	aadInitReverb();
#elif defined(PC_VERSION)
	struct AadInitAttr attributes; // [esp+0h] [ebp-18h] BYREF

	attributes.updateMode = 5;
	SND_SetTimerFunc(aadSlotUpdate);
	attributes.numSlots = 4;
	attributes.nonBlockLoadProc = LOAD_NonBlockingFileLoad;
	attributes.nonBlockBufferedLoadProc = LOAD_NonBlockingBufferedLoad;
	attributes.memoryMallocProc = MEMPACK_Malloc;
	attributes.memoryFreeProc = MEMPACK_Free;
	aadGetMemorySize(&attributes);
	aadInit(&attributes, &soundBuffer);
	gameTrackerX.sound.gMasterVol = 0x3FFF;
	gameTrackerX.sound.gMusicVol = 127;
	aadSetMusicMasterVolume(127);
	gameTrackerX.sound.gSfxVol = 127;
	aadSetSfxMasterVolume(0x7Fu);
	gameTrackerX.sound.gSfxOn = 1;
	gameTrackerX.sound.gMusicOn = 1;
	gameTrackerX.sound.gVoiceOn = 1;
	gameTrackerX.sound.gVoiceVol = 127;
	gameTrackerX.sound.soundsLoaded = 0;
	musicInfo = 0;
	dword_C60E68 = 0;
	dword_C60E70 = 0;
	dword_C60E74 = -1;
	byte_C60E78 = 0;
	dword_C60EA8 = 0;
	dword_C60EA4 = 0;
	dword_C60EA0 = 0;
	aadInitReverb();
#endif
}

void SOUND_Free()
{
	gameTrackerX.sound.soundsLoaded = 0;

	aadShutdown();
}

void SOUND_SetMusicVariable(int variable, int value)
{
	aadSetUserVariable(variable, value);
}

void SOUND_SetMusicVolume(int newVolume)
{ 
	if (newVolume == -1)
	{
		newVolume = gameTrackerX.sound.gMusicVol;
	}

	gameTrackerX.sound.gMusicVol = newVolume;

	aadSetMusicMasterVolume(newVolume);
}

void SOUND_SetSfxVolume(int newVolume)
{ 
	if (newVolume == -1)
	{
		newVolume = gameTrackerX.sound.gSfxVol;
	}

	gameTrackerX.sound.gSfxVol = newVolume;

	aadSetSfxMasterVolume(newVolume);
}

void SOUND_SetVoiceVolume(int newVolume)
{
	if (newVolume == -1)
	{
		newVolume = gameTrackerX.sound.gVoiceVol;
	}

	gameTrackerX.sound.gVoiceVol = newVolume;
}

void SOUND_PauseAllSound()
{
	if (gameTrackerX.sound.soundsLoaded != 0)
	{
		aadShutdownReverb();

		aadPauseSound();
	}
}

void SOUND_ResumeAllSound()
{
	if (gameTrackerX.sound.soundsLoaded != 0)
	{
		aadInitReverb();

		aadResumeSound();
	}
}

void SOUND_StopAllSound()
{ 
	if (gameTrackerX.sound.soundsLoaded != 0)
	{
		aadStopAllSfx();
		aadStopAllSlots();
		aadShutdownReverb();
		aadCancelPauseSound();
	}
}

void SOUND_ResetAllSound()
{ 
	if (gameTrackerX.sound.soundsLoaded != 0)
	{
		SOUND_StopAllSound();

		aadInitReverb();
	}
}

void SOUND_MusicOff()
{
	int slotNumber;

	for (slotNumber = 1; slotNumber < 4; slotNumber++)
	{
		aadDisableSlot(slotNumber);

		if (aadGetSlotStatus(slotNumber) == 1)
		{
			aadStopSlot(slotNumber);
			aadStartSlot(slotNumber);
		}
		slotNumber++;///?
	}
}

void SOUND_MusicOn()
{
	int slotNumber;

	slotNumber = 1;

	while (slotNumber < 4)
	{
		aadEnableSlot(slotNumber++);
	}
}

void SOUND_SfxOff()
{ 
	aadStopAllSfx();
}

void SOUND_SfxOn()
{
}

int SndIsPlaying(unsigned long handle)
{
	return aadIsSfxPlaying(handle);
}

int SndIsPlayingOrRequested(unsigned long handle)
{
	return aadIsSfxPlayingOrRequested(handle);
}

int SndTypeIsPlayingOrRequested(unsigned int sfxToneID)
{
	return aadIsSfxTypePlayingOrRequested(sfxToneID);
}

unsigned long SndPlay(unsigned int sample)
{ 
	if (gameTrackerX.sound.gSfxOn == 0)
	{
		return 0;
	}

	return aadPlaySfx(sample, 90, 64, 0);
}

void SndEndLoop(unsigned long handle)
{
	aadStopSfx(handle);
}

unsigned long SndPlayVolPan(unsigned int sample, unsigned short vol, unsigned short pan, short pitch)
{ 
	if (gameTrackerX.sound.gSfxOn != 0)
	{
		return aadPlaySfx(sample, vol & 0xFFFF, pan & 0xFFFF, pitch);
	}

	return 0;
}

unsigned long SndUpdateVolPanPitch(unsigned long handle, unsigned short vol, unsigned short pan, short pitch)
{ 
	if (gameTrackerX.sound.gSfxOn != 0)
	{
		return aadSetSfxVolPanPitch(handle, vol, pan, pitch);
	}

	return 0;
}

void musicLoadReturnFunc(int dynamicBankIndex, int errorStatus)
{ 
	musicInfo.errorStatus = errorStatus;
	musicInfo.state = musicInfo.nextState;
}

void musicFadeoutReturnFunc()
{
	musicInfo.state = musicInfo.nextState;
}

void musicEndCallbackFunc(long userData, int slot, int loopFlag)//Matching - 94.38%
{
	if (slot == 0)
	{
		aadInstallEndSequenceCallback(0, 0);

		if (aadAssignDynamicSequence(musicInfo.bankLoaded, 0, 0) == 0)
		{
			aadStartSlot(0);
			
			musicInfo.state = musicInfo.nextState;
		}
		else
		{

			musicInfo.state = 0;
		}
	}
}

void SOUND_PutMusicCommand(int cmdType, int cmdData)
{
	struct MusicLoadCmd* cmd;

	cmd = &musicInfo.commandQueue[musicInfo.commandIn];

	cmd->type = cmdType;
	cmd->data = cmdData;

	if (musicInfo.numCmdsInQueue < 3)
	{
		musicInfo.numCmdsInQueue++;
		musicInfo.commandIn = (musicInfo.commandIn + 1) & 0x3;
	}
}

void SOUND_MusicInit()
{
	musicInfo.state = 0;
	musicInfo.errorStatus = 0;
	musicInfo.checkMusicDelay = 0;
	musicInfo.currentMusicPlane = -1;
	musicInfo.currentMusicName[0] = 0;
	musicInfo.numCmdsInQueue = 0;
	musicInfo.commandOut = 0;
	musicInfo.commandIn = 0;
}

int SOUND_IsMusicLoading()
{
	if (musicInfo.state == 1 || musicInfo.state == 3 || musicInfo.state == 7)
	{
		return 1;
	}

	return 0;
}

void SOUND_ProcessMusicLoad()
{
	char musicName[8];
	char sndFileName[32];
	char smpFileName[32];
	struct MusicLoadCmd *cmd;
	struct Level *level;
	
	switch (musicInfo.state)
	{
	case 0:

		if (musicInfo.numCmdsInQueue != 0)
		{
			cmd = &musicInfo.commandQueue[musicInfo.commandOut];
			if (cmd->type == 0)
			{
				musicInfo.state = 11;
				musicInfo.nextState = 13;
				musicInfo.currentMusicPlane = cmd->data;
				aadStartMusicMasterVolFade(0, -3, musicFadeoutReturnFunc);
			}

			musicInfo.commandOut = (musicInfo.commandOut + 1) & 0x3;
			musicInfo.numCmdsInQueue--;
		}
		else
		{
			if (musicInfo.checkMusicDelay == 0)
			{
				if (aadMem->sramDefragInfo.status == 0)
				{
					musicInfo.checkMusicDelay = 30;

					level = STREAM_GetLevelWithID(gameTrackerX.playerInstance->currentStreamUnitID);

					if (level != NULL)
					{
						if (level->dynamicMusicName != NULL)
						{
							musicName[0] = level->dynamicMusicName[0];
							musicName[1] = level->dynamicMusicName[1];

							if (musicInfo.currentMusicPlane == -1)
							{
								musicInfo.currentMusicPlane = gameTrackerX.gameData.asmData.MorphType;
							}

							if (musicInfo.currentMusicPlane != 0)
							{
								musicName[2] = 's';
								musicName[3] = 'p';
							}
							else
							{
								musicName[2] = 'm';
								musicName[3] = 'a';
							}

							musicName[4] = 0;

#if defined(AKUJI)
							musicName[0] = 'r';
							musicName[1] = 'a';
							musicName[2] = 'i';
							musicName[3] = 'n';
							musicName[4] = '1';
							musicName[5] = 0;
#endif

#if defined(UWP)
							if (_strcmpi(musicName, musicInfo.currentMusicName) != 0)
#else
							if (strcmpi(musicName, musicInfo.currentMusicName) != 0)
#endif
							{
								if (musicInfo.currentMusicName[0] != 0)
								{
									sprintf(sndFileName, "\\kain2\\music\\%s\\%s.snd", musicName, musicName);

									if (LOAD_DoesFileExist(sndFileName) != 0)
									{
										strcpy(musicInfo.currentMusicName, musicName);
										strcpy(sndFileName, "\\kain2\\music\\uwtr\\uwtr.snd");
										strcpy(smpFileName, "\\kain2\\music\\uwtr\\uwtr.smp");
									
										musicInfo.state = 3;
										musicInfo.nextState = 4;

										aadLoadDynamicSoundBank(sndFileName, smpFileName, 1, 1, musicLoadReturnFunc);
									}
								}
								else
								{
									sprintf(sndFileName, "\\kain2\\music\\%s\\%s.snd", musicName, musicName);
									sprintf(smpFileName, "\\kain2\\music\\%s\\%s.smp", musicName, musicName);

									if (LOAD_DoesFileExist(sndFileName) != 0)
									{
										strcpy(musicInfo.currentMusicName, musicName);
										
										musicInfo.state = 1;
										musicInfo.nextState = 2;
										
										aadLoadDynamicSoundBank(sndFileName, smpFileName, 0, 1, musicLoadReturnFunc);
									}
								}
							}
						}
						else
						{
							if (musicInfo.currentMusicName[0] != 0)
							{
								musicInfo.currentMusicName[0] = 0;
								musicInfo.state = 11;
								musicInfo.nextState = 12;
								aadStartMusicMasterVolFade(0, -1, musicFadeoutReturnFunc);
							}
						}
					}
				}
			}
			else
			{
				musicInfo.checkMusicDelay--;
			}
		}
		break;
	case 2:
#if defined(AKUJI)
		if (aadAssignDynamicSequence(0, 2, 0) == 0)
#else
		if (aadAssignDynamicSequence(0, 0, 0) == 0)
#endif
		{
			aadStartSlot(0);
			musicInfo.state = 0;
		}
		break;
	case 4:
		if (musicInfo.errorStatus == 0)
		{
			musicInfo.state = 5;
			musicInfo.nextState = 6;
			musicInfo.bankLoaded = 1;

			aadInstallEndSequenceCallback(musicEndCallbackFunc, 0);
		}
		else
		{
			musicInfo.state = 0;
		}
		break;
	case 6:
		if (aadMem->sramDefragInfo.status == 0)
		{
			sprintf(sndFileName, "\\kain2\\music\\%s\\%s.snd", musicInfo.currentMusicName, musicInfo.currentMusicName);
			sprintf(smpFileName, "\\kain2\\music\\%s\\%s.smp", musicInfo.currentMusicName, musicInfo.currentMusicName);

			aadLoadDynamicSoundBank(sndFileName, smpFileName, 0, 1, musicLoadReturnFunc);
			musicInfo.state = 7;
			musicInfo.nextState = 8;
		}
		break;
	case 8:
		if (musicInfo.errorStatus == 0)
		{
			musicInfo.state = 9;
			musicInfo.nextState = 10;
			musicInfo.bankLoaded = 0;

			aadInstallEndSequenceCallback(musicEndCallbackFunc, 0);
			aadSetUserVariable(0x7F, 1);
		}
		else
		{
			musicInfo.state = 0;
		}
		break;
	case 10:
		aadFreeDynamicSoundBank(1);
		musicInfo.state = 0;
		break;
	case 12:
		aadStopAllSlots();
		aadFreeDynamicSoundBank(0);
		aadStartMusicMasterVolFade(gameTrackerX.sound.gMusicVol, 1, NULL);
		musicInfo.state = 0;
		break;
	case 13:
		aadStopAllSlots();
		aadFreeDynamicSoundBank(0);
		aadStartMusicMasterVolFade(gameTrackerX.sound.gMusicVol, 1, NULL);
		musicInfo.currentMusicName[0] = 0;
		musicInfo.checkMusicDelay = 0;
		musicInfo.state = 0;
		break;
	}
}

void SOUND_UpdateSound()//Matching - 88.37%
{
	aadProcessLoadQueue();

	if ((gameTrackerX.debugFlags & 0x40000) || gSramFullAlarm == 0 && gSramFullMsgCnt != 0)
	{
		if (gSramFullMsgCnt == 0)
		{
			gSramFullMsgCnt = 60;
		}
		else
		{
			gSramFullMsgCnt--;
		}

		FONT_Print("$\n\n\n\n\n\n\n\n\n\nsound memory full!\nu = % d % d f = % d % d lf = % d", gSramTotalUsed, gSramUsedBlocks, gSramTotalFree, gSramFreeBlocks, gSramLargestFree);
	}

	if (gameTrackerX.sound.gMusicOn != 0)
	{
		SOUND_ProcessMusicLoad();
	}
}

void SOUND_PlaneShift(int newPlane)
{ 
	if (gameTrackerX.sound.gMusicOn != 0)
	{
		SOUND_PutMusicCommand(0, newPlane);
	}
	else
	{
		musicInfo.currentMusicPlane = -1;
	}
}

void SOUND_ShutdownMusic()
{
	aadStopAllSlots();
	EnterCriticalSection();

	if (musicInfo.state == 1 || musicInfo.state == 3 || musicInfo.state == 7)
	{
		musicInfo.nextState = 0;
		ExitCriticalSection();

		while (musicInfo.state != 0)
		{
			STREAM_PollLoadQueue();
		}
	}
	else
	{
		ExitCriticalSection();
	}

	musicInfo.currentMusicName[0] = 0;
	aadFreeDynamicSoundBank(0);
	aadFreeDynamicSoundBank(1);
	musicInfo.state = 0;
	aadStartMusicMasterVolFade(gameTrackerX.sound.gMusicVol, 1, NULL);
}

void SOUND_SetMusicModifier(long modifier)
{
	switch (modifier)
	{
	case 0:
	{
		SOUND_SetMusicVariable(0x0, 0);

		break;
	}
	case 1:
	{
		SOUND_SetMusicVariable(0x0, 1);

		break;
	}
	case 2:
	{
		SOUND_SetMusicVariable(0x0, 0x3);

		break;
	}
	case 3:
	{
		SOUND_SetMusicVariable(0x0, 0x4);

		break;
	}
	case 4:
	{
		SOUND_SetMusicVariable(0x0, 2);

		break;
	}
	case 5:
	{
		SOUND_SetMusicVariable(0x1, 1);

		break;
	}
	case 6:
	{
		SOUND_SetMusicVariable(0x2, 1);

		break;
	}
	case 9:
	{
		SOUND_SetMusicVariable(0x7D, 1);

		break;
	}
	case 10:
	{
		SOUND_SetMusicVariable(0x7E, 1);

		break;
	}
	case 11:
	{
		SOUND_SetMusicVariable(0x7C, 1);

		break;
	}
	case 13:
	{
		SOUND_SetMusicVariable(0x78, 1);

		break;
	}
	case 14:
	{
		SOUND_SetMusicVariable(0x3, 1);

		break;
	}
	case 15:
	{
		SOUND_SetMusicVariable(0x77, 1);
	
		break;
	}
	}
}

void SOUND_ResetMusicModifier(long modifier)
{
	switch (modifier)
	{
	case 0:
	case 1:
	case 2:
	case 3:
	case 4:
	{
		SOUND_SetMusicVariable(0x0, 0);

		break;
	}
	case 5:
	{
		SOUND_SetMusicVariable(0x1, 0);

		break;
	}
	case 6:
	{
		SOUND_SetMusicVariable(0x2, 0);

		break;
	}
	case 9:
	{
		SOUND_SetMusicVariable(0x7D, 0);

		break;
	}
	case 10:
	{
		SOUND_SetMusicVariable(0x7E, 0);

		break;
	}
	case 11:
	{
		SOUND_SetMusicVariable(0x7C, 0);

		break;
	}
	case 13:
	{
		SOUND_SetMusicVariable(0x78, 0);

		break;
	}
	case 14:
	{
		SOUND_SetMusicVariable(0x3, 0);

		break;
	}
	case 15:
	{
		SOUND_SetMusicVariable(0x77, 0);

		break;
	}
	}
}