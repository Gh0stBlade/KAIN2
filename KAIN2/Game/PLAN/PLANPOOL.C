#include "Game/CORE.H"
#include "PLANPOOL.H"
#include "Game/MATH3D.H"


int PLANPOOL_NumNodesInPlan(struct PlanningNode* goalNode, struct PlanningNode* planningPool) // Matching - 100%
{
	struct PlanningNode* currentNode;
	int i;

	for (i = 0, currentNode = &planningPool[goalNode->parent]; goalNode != currentNode; i++)
	{
		goalNode = &planningPool[goalNode->parent];

		currentNode = &planningPool[goalNode->parent];
	}

	return i + 1;
}

int PLANPOOL_CountBitsSetInLong(long mylong)//Matching - 100%
{
	int numBitsSet;

	for (numBitsSet = 0; mylong; numBitsSet++)
	{
		mylong &= (mylong - 1);
	}

	return numBitsSet;
}

int PLANPOOL_NumConnectionsExaminedForNode(struct PlanningNode* node) // Matching - 100%
{
	return PLANPOOL_CountBitsSetInLong(node->connectionStatus);
}

int PLANPOOL_NumConnectionsForNode(struct PlanningNode* node)
{
	return PLANPOOL_CountBitsSetInLong(node->connections);
}

struct PlanningNode* PLANPOOL_GetFirstNodeOfSource(struct PlanningNode* planningPool, char nodeSource)//Matching - 99.75%
{
	int i;

	for (i = 0; i < poolManagementData->numNodesInPool; i++, planningPool++)
	{
		if ((planningPool->nodeType & 0x7) == nodeSource)
		{
			return planningPool;
		}
	}

	return 0;
}

int PLANPOOL_NumberOfNodesOfType(struct PlanningNode* planningPool, char nodeType)//Matching - 99.74%
{
	int i;
	int numNodesOfType;

	for (i = 0, numNodesOfType = 0; i < poolManagementData->numNodesInPool; i++, planningPool++)
	{
		if (planningPool->nodeType == nodeType)
		{
			numNodesOfType++;
		}
	}

	return numNodesOfType;
}

int PLANPOOL_NumberOfNodesOfSource(struct PlanningNode* planningPool, char nodeSource)//Matching - 99.75%
{
	int i;
	int numNodesOfSource;

	for (i = 0, numNodesOfSource = 0; i < poolManagementData->numNodesInPool; i++, planningPool++)
	{
		if ((planningPool->nodeType & 0x7) == nodeSource)
		{
			numNodesOfSource++;
		}
	}

	return numNodesOfSource;
}

// autogenerated function stub: 
// struct PlanningNode * /*$ra*/ PLANPOOL_GetNodeWithID(struct PlanningNode *planningPool /*$a0*/, int type /*$a1*/, int id /*$a2*/, long suID /*$a3*/)
struct PlanningNode * PLANPOOL_GetNodeWithID(struct PlanningNode *planningPool, int type, int id, long suID)
{ // line 213, offset 0x800993a8
	/* begin block 1 */
		// Start line: 215
		// Start offset: 0x800993A8
		// Variables:
			int i; // $v1
	/* end block 1 */
	// End offset: 0x8009940C
	// End Line: 224

	/* begin block 2 */
		// Start line: 414
	/* end block 2 */
	// End Line: 415

	/* begin block 3 */
		// Start line: 415
	/* end block 3 */
	// End Line: 416

	/* begin block 4 */
		// Start line: 417
	/* end block 4 */
	// End Line: 418
			UNIMPLEMENTED();
	return null;
}


struct PlanningNode* PLANPOOL_GetNodeByPosition(struct _Position* currentPos, struct PlanningNode* planningPool) // Matching - 100%
{
	int i;
	unsigned long zDiff;
	unsigned long minZDiff;
	struct PlanningNode* returnNode;

	minZDiff = -1;
	returnNode = NULL;
	for (i = 0; i < poolManagementData->numNodesInPool; i++)
	{
		if (MATH3D_LengthXY(currentPos->x - planningPool[i].pos.x, currentPos->y - planningPool[i].pos.y) < 11)
		{
			zDiff = abs(currentPos->z - planningPool[i].pos.z);
			if (zDiff < minZDiff)
			{
				returnNode = &planningPool[i];
			}
		}
	}
	return returnNode;
}

struct PlanningNode * PLANPOOL_GetClosestNode(_Position *pos, struct PlanningNode *planningPool, char distanceType) // Matching - 92.83%
{
	int i;
	long dist;
	long minDist;
	struct PlanningNode *closestNode;

	minDist = 0x7FFFFFFF;
	closestNode = NULL;
	for (i = 0; i < poolManagementData->numNodesInPool; i++)
	{
		if (distanceType == 0)
		{
			dist = MATH3D_LengthXY(pos->x - planningPool[i].pos.x, pos->y - planningPool[i].pos.y);
		}
		else
		{
			dist = MATH3D_LengthXYZ(pos->x - planningPool[i].pos.x, pos->y - planningPool[i].pos.y, pos->z - planningPool[i].pos.z);
		}
		if (dist < minDist)
		{
			minDist = dist;
			closestNode = &planningPool[i];
		}
	}
	return closestNode;
}

// autogenerated function stub: 
// int /*$ra*/ PLANPOOL_AppropriatePair(struct PlanningNode *node1 /*$t1*/, struct PlanningNode *node2 /*$a1*/)
int PLANPOOL_AppropriatePair(struct PlanningNode *node1, struct PlanningNode *node2)
{ // line 277, offset 0x800995e8
	/* begin block 1 */
		// Start line: 278
		// Start offset: 0x800995E8
		// Variables:
			struct PlanningNode *temp; // $v0
			int res; // $s0
			int src; // $a0
			int plc; // $v1
			short type1; // $a0
			short type2; // $v1
			short placement1; // $t5
			short placement2; // $t4
			short source1; // $t2
			short source2; // $t3
	/* end block 1 */
	// End offset: 0x80099748
	// End Line: 345

	/* begin block 2 */
		// Start line: 595
	/* end block 2 */
	// End Line: 596
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PLANPOOL_AreTwoNodesConnected(struct PlanningNode *node1 /*$a3*/, struct PlanningNode *node2 /*$a1*/, struct PlanningNode *planningPool /*$a2*/)
int PLANPOOL_AreTwoNodesConnected(struct PlanningNode *node1, struct PlanningNode *node2, struct PlanningNode *planningPool)
{ // line 350, offset 0x8009975c
	/* begin block 1 */
		// Start line: 351
		// Start offset: 0x8009975C
		// Variables:
			long node2Mask; // $a0
	/* end block 1 */
	// End offset: 0x800997C4
	// End Line: 361

	/* begin block 2 */
		// Start line: 741
	/* end block 2 */
	// End Line: 742
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ PLANPOOL_MarkTwoNodesAsConnected(struct PlanningNode *node1 /*$s1*/, struct PlanningNode *node2 /*$a1*/, struct PlanningNode *planningPool /*$a2*/)
void PLANPOOL_MarkTwoNodesAsConnected(struct PlanningNode *node1, struct PlanningNode *node2, struct PlanningNode *planningPool)
{ // line 365, offset 0x800997cc
	/* begin block 1 */
		// Start line: 366
		// Start offset: 0x800997CC
		// Variables:
			int node1Index; // $s2
			int node2Index; // $s0
	/* end block 1 */
	// End offset: 0x80099874
	// End Line: 377

	/* begin block 2 */
		// Start line: 773
	/* end block 2 */
	// End Line: 774
			UNIMPLEMENTED();
}


void PLANPOOL_MarkTwoNodesAsNotConnected(struct PlanningNode* node1, struct PlanningNode* node2, struct PlanningNode* planningPool) // Matching - 100.00%
{
	node1->connectionStatus |= 1 << (node2 - planningPool);
	node1->connections &= ~(1 << (node2 - planningPool));
}

struct PlanningNode* PLANPOOL_GetClosestUnexploredValidNeighbor(struct PlanningNode* startNode, struct PlanningNode* planningPool) // Matching - 99.85%
{
	int i;
	unsigned long connectionStatus;
	unsigned long dist;
	unsigned long minDist;
	struct PlanningNode* returnNode;

	minDist = 0xFFFFFFFF;
	returnNode = NULL;
	if (startNode == NULL)
	{
		return NULL;
	}
	connectionStatus = startNode->connectionStatus;
	for (i = 0; i < poolManagementData->numNodesInPool; i++)
	{
		if ((connectionStatus & 1) == 0)
		{
			if (PLANPOOL_AppropriatePair(startNode, &planningPool[i]))
			{
				dist = MATH3D_LengthXYZ(startNode->pos.x - planningPool[i].pos.x, startNode->pos.y - planningPool[i].pos.y, startNode->pos.z - planningPool[i].pos.z);
				if (dist < minDist)
				{
					minDist = dist;
					returnNode = &planningPool[i];
				}
			}
			else
			{
				PLANPOOL_MarkTwoNodesAsNotConnected(startNode, &planningPool[i], planningPool);
			}
		}
		connectionStatus = connectionStatus >> 1;
	}
	return returnNode;
}

// autogenerated function stub: 
// void /*$ra*/ PLANPOOL_ChangeNodePosition(_Position *newPos /*$t0*/, struct PlanningNode *nodeToChange /*$a1*/, struct PlanningNode *planningPool /*$a2*/)
void PLANPOOL_ChangeNodePosition(_Position *newPos, struct PlanningNode *nodeToChange, struct PlanningNode *planningPool)
{ // line 451, offset 0x80099a34
	/* begin block 1 */
		// Start line: 452
		// Start offset: 0x80099A34
		// Variables:
			int i; // $a0
			unsigned char nodeToChangeMask; // $v1
	/* end block 1 */
	// End offset: 0x80099AE4
	// End Line: 469

	/* begin block 2 */
		// Start line: 1002
	/* end block 2 */
	// End Line: 1003
			UNIMPLEMENTED();
}


struct PlanningNode* PLANPOOL_AddNodeToPool(struct _Position* pos, struct PlanningNode* planningPool, short nodeType, short nodeID, long streamUnitID) // Matching - 100%
{
	struct PlanningNode* nextAvailableNode;
	int i;

	nextAvailableNode = NULL;

	if (poolManagementData->numNodesInPool < 32U)
	{
		nextAvailableNode = planningPool + (poolManagementData->numNodesInPool);

		SET_VEC((struct _SVector*)&nextAvailableNode->pos, pos);

		nextAvailableNode->connectionStatus = (1 << poolManagementData->numNodesInPool);
		nextAvailableNode->connections = 0;
		nextAvailableNode->flags = 0;
		nextAvailableNode->nodeType = nodeType;
		nextAvailableNode->id = nodeID;
		nextAvailableNode->streamUnitID = streamUnitID;

		poolManagementData->numNodesInPool++;

		for (i = 0; i < poolManagementData->numNodesInPool; i++)
		{
			poolManagementData->distanceMatrix[poolManagementData->numNodesInPool][i - 32] = 0;
			poolManagementData->distanceMatrix[i][poolManagementData->numNodesInPool - 1] = 0;
		}
	}

	return nextAvailableNode;
}


// autogenerated function stub: 
// void /*$ra*/ PLANPOOL_DeleteNodeFromPool(struct PlanningNode *nodeToDelete /*$a0*/, struct PlanningNode *planningPool /*$a1*/)
void PLANPOOL_DeleteNodeFromPool(struct PlanningNode *nodeToDelete, struct PlanningNode *planningPool)
{ // line 510, offset 0x80099be0
	/* begin block 1 */
		// Start line: 512
		// Start offset: 0x80099BE0
		// Variables:
			int indexOfNodeToDelete; // $t3
			int lastNodeIndex; // $t2
			long oldConnectionMask; // $v1
			long newConnectionMask; // $a3
			int i; // $a2
			struct PlanningNode *lastNode; // $v0
	/* end block 1 */
	// End offset: 0x80099DA4
	// End Line: 556

	/* begin block 2 */
		// Start line: 1146
	/* end block 2 */
	// End Line: 1147

	/* begin block 3 */
		// Start line: 1147
	/* end block 3 */
	// End Line: 1148

	/* begin block 4 */
		// Start line: 1152
	/* end block 4 */
	// End Line: 1153
			UNIMPLEMENTED();
}




