#include "CORE.H"
#include "SCRIPT.H"
#include "PSX/COLLIDES.H"
#include "G2/QUATG2.H"

void SCRIPT_CombineEulerAngles(struct _Rotation* combinedRotation, struct _Rotation* inputRotation1, struct _Rotation* inputRotation2)  // Matching - 100%
{
	MATRIX rotMatrix1;
	MATRIX rotMatrix2;
	struct _G2EulerAngles_Type ea;
	short _x1;
	short _y1;
	short _z1;
	struct _SVector* _v;

	RotMatrix((SVECTOR*)inputRotation1, &rotMatrix1);
	RotMatrix((SVECTOR*)inputRotation2, &rotMatrix2);
	MulMatrix2(&rotMatrix2, &rotMatrix1);
	G2EulerAngles_FromMatrix(&ea, (struct _G2Matrix_Type*)&rotMatrix1, 21);
	_v = (_SVector*)&ea;
	_x1 = _v->x;
	_y1 = _v->y;
	_z1 = _v->z;
	combinedRotation->x = _x1;
	combinedRotation->y = _y1;
	combinedRotation->z = _z1;
}

void SCRIPT_InstanceSplineInit(struct _Instance* instance)
{
	struct Spline* spline;
	struct RSpline* rspline;
	struct Spline* sspline;
	struct MultiSpline* multi;
	struct SplineDef* sd;
	struct SplineDef* rsd;
	struct SplineDef* ssd;
	unsigned long isParent;
	unsigned long isClass;
	struct _G2Quat_Type* q;
	struct _G2EulerAngles_Type ea;
	MATRIX introTransform;
	struct _Rotation combinedRotation;
	short _x1;
	short _y1;
	short _z1;
	short _x0;
	short _y0;
	short _z0;
	struct _Position* _v;
	struct _Position* _v0;
	struct _SVector* start_point;

	multi = SCRIPT_GetMultiSpline(instance, &isParent, &isClass);

	if (multi != NULL)
	{
		sd = SCRIPT_GetPosSplineDef(instance, multi, isParent, isClass);
		rsd = SCRIPT_GetRotSplineDef(instance, multi, isParent, isClass);
		ssd = SCRIPT_GetScaleSplineDef(instance, multi, isParent, isClass);

		spline = multi->positional;
		rspline = multi->rotational;
		sspline = multi->scaling;

		if (rspline != NULL)
		{
			q = SplineGetFirstRot(rspline, rsd);

			if (isParent == 0)
			{
				if (isClass == 0)
				{
					G2Quat_ToMatrix_S(q, (struct _G2Matrix_Type*)&multi->curRotMatrix);
				
					q = (struct _G2Quat_Type*)&instance->intro->rotation;

					if (instance->intro != NULL)
					{
						RotMatrix((SVECTOR*)&instance->intro->rotation, &introTransform);

						MulMatrix0(&multi->curRotMatrix, &introTransform, &multi->curRotMatrix);
					}
					instance->flags |= 0x1;
				}
			}
		
			G2Quat_ToEuler(q, &ea, 0);

			instance->rotation.x = ea.x;
			instance->rotation.y = ea.y;
			instance->rotation.z = ea.z;

			SCRIPT_CombineEulerAngles(&combinedRotation, (struct _Rotation*)instance->data, &instance->intro->rotation);

			((struct _Rotation*)instance->data)->x = combinedRotation.x;
			((struct _Rotation*)instance->data)->y = combinedRotation.y;
			((struct _Rotation*)instance->data)->z = combinedRotation.z;
		}
		
		if (spline != NULL)
		{
			start_point = SplineGetFirstPoint(spline, sd);
			
			if (start_point != NULL)
			{
				_v0 = (struct _Position*)&instance->initialPos;

				if (isClass != 0)
				{
					_x0 = _v0->x;
					_y0 = _v0->y;
					_z0 = _v0->z;

					_x1 = start_point->x;
					_y1 = start_point->y;
					_z1 = start_point->z;

					_v = &instance->position;

					_v->x = _x0 + _x1;
					_v->y = _y0 + _y1;
					_v->z = _z0 + _z1;
				}
				else
				{
					instance->position.x = start_point->x;
					instance->position.y = start_point->y;
					instance->position.z = start_point->z;
				}
			}
		}

		if (sspline != NULL)
		{
			start_point = SplineGetFirstPoint(sspline, ssd);

			if (start_point != NULL)
			{
				instance->scale.x = start_point->x;
				instance->scale.y = start_point->y;
				instance->scale.z = start_point->z;
			}
		}
	}
}


// autogenerated function stub: 
// short /*$ra*/ SCRIPTCountFramesInSpline(struct _Instance *instance /*$s4*/)
short SCRIPTCountFramesInSpline(struct _Instance *instance)
{ // line 266, offset 0x8003c980
	/* begin block 1 */
		// Start line: 267
		// Start offset: 0x8003C980
		// Variables:
			short kf; // $s3
			short frames; // $s2
			struct SplineKey *key; // $a0
			struct Spline *spline; // $s0
			struct RSpline *rspline; // $s1

		/* begin block 1.1 */
			// Start line: 282
			// Start offset: 0x8003CA0C
			// Variables:
				struct SplineRotKey *rkey; // $a0
		/* end block 1.1 */
		// End offset: 0x8003CA48
		// End Line: 288

		/* begin block 1.2 */
			// Start line: 291
			// Start offset: 0x8003CA50
			// Variables:
				struct MultiSpline *multi; // $v0
		/* end block 1.2 */
		// End offset: 0x8003CAA8
		// End Line: 300
	/* end block 1 */
	// End offset: 0x8003CAA8
	// End Line: 302

	/* begin block 2 */
		// Start line: 468
	/* end block 2 */
	// End Line: 469
				UNIMPLEMENTED();
	return 0;
}

struct Spline* ScriptGetPosSpline(struct _Instance* instance)
{
	struct MultiSpline* multi;

	multi = SCRIPT_GetMultiSpline(instance, NULL, NULL);

	if (multi == NULL)
	{
		return NULL;
	}

	return multi->positional;
}

struct RSpline* ScriptGetRotSpline(struct _Instance* instance)
{
	struct MultiSpline* multi;

	multi = SCRIPT_GetMultiSpline(instance, NULL, NULL);

	if (multi == NULL)
	{
		return NULL;
	}

	return multi->rotational;
}

int SCRIPT_GetSplineFrameNumber(struct _Instance* instance, struct SplineDef* splineDef)//Matching - 95%
{
	return SplineGetFrameNumber(ScriptGetPosSpline(instance) == NULL ? ScriptGetPosSpline(instance) : (struct Spline*)ScriptGetRotSpline(instance), splineDef);
}

struct MultiSpline* SCRIPT_GetMultiSpline(struct _Instance* instance, unsigned long* isParent, unsigned long* isClass)
{
	struct MultiSpline* multi;

	multi = NULL;

	if (isParent != NULL)
	{
		*isParent = 0;
	}
	if (isClass != NULL)
	{
		*isClass = 0;
	}

	if (instance != NULL)
	{
		if (instance->intro != NULL && instance->intro->multiSpline != NULL)
		{
			multi = instance->intro->multiSpline;

			if ((instance->flags & 0x100002) == 2 && isParent != NULL)
			{
				*isParent = 1;
			}

		}

		if (multi == NULL)
		{
			if (instance->object->modelList[0] != NULL)
			{
				multi = instance->object->modelList[0]->multiSpline;

				if (isClass != NULL)
				{
					*isClass = 1;
				}
			}

		}
	}
	
	return multi;
}


struct SplineDef* SCRIPT_GetPosSplineDef(struct _Instance* instance, struct MultiSpline* multi, unsigned long isParent, unsigned long isClass) // Matching - 100%
{
	struct SplineDef* splineDef;

	if (isParent != 0 || isClass != 0)
	{
		return (struct SplineDef*)&instance->work0;
	}

	if (multi == NULL)
	{
		return NULL;
	}

	return &multi->curPositional;
}

struct SplineDef* SCRIPT_GetRotSplineDef(struct _Instance* instance, struct MultiSpline* multi, unsigned long isParent, unsigned long isClass)
{
	struct SplineDef* splineDef;

	if (isParent != 0 || isClass != 0)
	{
		return (struct SplineDef*)&instance->work2;
	}
	else
	{
		if (multi != NULL)
		{
			return &multi->curRotational;
		}
	}

	return NULL;
}

struct SplineDef* SCRIPT_GetScaleSplineDef(struct _Instance* instance, struct MultiSpline* multi, unsigned long isParent, unsigned long isClass)
{
	struct SplineDef* splineDef;

	if (isParent != 0 || isClass != 0)
	{
		return (struct SplineDef*)&instance->work4;
	}
	else
	{
		if (multi != NULL)
		{
			return &multi->curScaling;
		}
	}

	return NULL;
}


// autogenerated function stub: 
// void /*$ra*/ SCRIPT_RelativisticSpline(struct _Instance *instance /*$s0*/, struct _SVector *point /*$a3*/)
void SCRIPT_RelativisticSpline(struct _Instance *instance, struct _SVector *point)
{ // line 412, offset 0x8003ccd0
	/* begin block 1 */
		// Start line: 413
		// Start offset: 0x8003CCD0
		// Variables:
			struct _SVector pt; // stack offset -64

		/* begin block 1.1 */
			// Start line: 423
			// Start offset: 0x8003CD10
			// Variables:
				MATRIX segMatrix; // stack offset -56
				_Position newPt; // stack offset -24
				_Position localPt; // stack offset -16

			/* begin block 1.1.1 */
				// Start line: 426
				// Start offset: 0x8003CD10
				// Variables:
					short _x1; // $a1
					short _y1; // $v1
					short _z1; // $a0
					struct _SVector *_v0; // $v0
			/* end block 1.1.1 */
			// End offset: 0x8003CD10
			// End Line: 426

			/* begin block 1.1.2 */
				// Start line: 426
				// Start offset: 0x8003CD10
				// Variables:
					short _y0; // $v1
					short _z0; // $v0
					//short _x1; // $a1
					//short _y1; // $a3
					//short _z1; // $a2
					_Position *_v; // $a0
					//_Position *_v0; // $v0
					_Position *_v1; // $a2
			/* end block 1.1.2 */
			// End offset: 0x8003CD10
			// End Line: 426
		/* end block 1.1 */
		// End offset: 0x8003CD10
		// End Line: 426

		/* begin block 1.2 */
			// Start line: 440
			// Start offset: 0x8003CE78
			// Variables:
				short _x0; // $v0
				//short _y0; // $a0
				//short _z0; // $v1
				//short _x1; // $a1
				//short _y1; // $a2
				//short _z1; // $a3
				//_Position *_v; // $v0
				//_Position *_v0; // $v1
		/* end block 1.2 */
		// End offset: 0x8003CEB0
		// End Line: 440
	/* end block 1 */
	// End offset: 0x8003CEB0
	// End Line: 442

	/* begin block 2 */
		// Start line: 772
	/* end block 2 */
	// End Line: 773
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ SCRIPT_InstanceSplineSet(struct _Instance *instance /*$s2*/, short frameNum /*$fp*/, struct SplineDef *splineDef /*$s4*/, struct SplineDef *rsplineDef /*$s5*/, struct SplineDef *ssplineDef /*stack 16*/)
void SCRIPT_InstanceSplineSet(struct _Instance *instance, short frameNum, struct SplineDef *splineDef, struct SplineDef *rsplineDef, struct SplineDef *ssplineDef)
{ // line 444, offset 0x8003cec0
	/* begin block 1 */
		// Start line: 445
		// Start offset: 0x8003CEC0
		// Variables:
			struct Spline *spline; // $s0
			struct RSpline *rspline; // $s3
			struct Spline *sspline; // $s7
			struct MultiSpline *multi; // $s1
			unsigned long isClass; // stack offset -44
			unsigned long isParent; // stack offset -48
			struct _SVector point; // stack offset -96

		/* begin block 1.1 */
			// Start line: 506
			// Start offset: 0x8003D064
			// Variables:
				struct _G2Quat_Type q; // stack offset -88

			/* begin block 1.1.1 */
				// Start line: 509
				// Start offset: 0x8003D07C
				// Variables:
					MATRIX introTransform; // stack offset -80
			/* end block 1.1.1 */
			// End offset: 0x8003D098
			// End Line: 515
		/* end block 1.1 */
		// End offset: 0x8003D098
		// End Line: 515

		/* begin block 1.2 */
			// Start line: 523
			// Start offset: 0x8003D0BC
			// Variables:
				struct _Rotation rot; // stack offset -88

			/* begin block 1.2.1 */
				// Start line: 527
				// Start offset: 0x8003D0D0
				// Variables:
					struct _Rotation combinedRotation; // stack offset -80

				/* begin block 1.2.1.1 */
					// Start line: 527
					// Start offset: 0x8003D0D0
					// Variables:
						short _x1; // $v0
						short _y1; // $v1
						short _z1; // $a0
				/* end block 1.2.1.1 */
				// End offset: 0x8003D118
				// End Line: 537
			/* end block 1.2.1 */
			// End offset: 0x8003D118
			// End Line: 538
		/* end block 1.2 */
		// End offset: 0x8003D118
		// End Line: 540

		/* begin block 1.3 */
			// Start line: 544
			// Start offset: 0x8003D128
			// Variables:
				struct _SVector scale; // stack offset -88
		/* end block 1.3 */
		// End offset: 0x8003D168
		// End Line: 552
	/* end block 1 */
	// End offset: 0x8003D168
	// End Line: 554

	/* begin block 2 */
		// Start line: 840
	/* end block 2 */
	// End Line: 841
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// long /*$ra*/ SCRIPT_SplineProcess(struct _Instance *instance /*$s4*/, struct MultiSpline *multi /*$fp*/, struct SplineDef *splineDef /*stack 8*/, struct SplineDef *rsplineDef /*$s7*/, struct SplineDef *ssplineDef /*stack 16*/, int direction /*stack 20*/, int isClass /*stack 24*/)
long SCRIPT_SplineProcess(struct _Instance *instance, struct MultiSpline *multi, struct SplineDef *splineDef, struct SplineDef *rsplineDef, struct SplineDef *ssplineDef, int direction, int isClass)
{ // line 556, offset 0x8003d198
	/* begin block 1 */
		// Start line: 557
		// Start offset: 0x8003D198
		// Variables:
			long retVal; // $s3
			struct Spline *spline; // $s5
			struct RSpline *rspline; // $s1
			struct Spline *sspline; // $a0
			struct _SVector *point; // $s2
			struct _Rotation rot; // stack offset -96
			long timeOff; // $s6

		/* begin block 1.1 */
			// Start line: 574
			// Start offset: 0x8003D1F4
			// Variables:
				struct _SVector pt; // stack offset -88
		/* end block 1.1 */
		// End offset: 0x8003D270
		// End Line: 594

		/* begin block 1.2 */
			// Start line: 617
			// Start offset: 0x8003D2DC
			// Variables:
				struct _G2Quat_Type q; // stack offset -80

			/* begin block 1.2.1 */
				// Start line: 620
				// Start offset: 0x8003D2F4
				// Variables:
					MATRIX introTransform; // stack offset -72
			/* end block 1.2.1 */
			// End offset: 0x8003D310
			// End Line: 626
		/* end block 1.2 */
		// End offset: 0x8003D334
		// End Line: 632

		/* begin block 1.3 */
			// Start line: 638
			// Start offset: 0x8003D348
			// Variables:
				struct _Rotation combinedRotation; // stack offset -72

			/* begin block 1.3.1 */
				// Start line: 638
				// Start offset: 0x8003D348
				// Variables:
					short _x1; // $v0
					short _y1; // $v1
					short _z1; // $a0
			/* end block 1.3.1 */
			// End offset: 0x8003D348
			// End Line: 638
		/* end block 1.3 */
		// End offset: 0x8003D348
		// End Line: 638

		/* begin block 1.4 */
			// Start line: 662
			// Start offset: 0x8003D3A0
			// Variables:
				//struct _SVector pt; // stack offset -80
		/* end block 1.4 */
		// End offset: 0x8003D44C
		// End Line: 687
	/* end block 1 */
	// End offset: 0x8003D44C
	// End Line: 688

	/* begin block 2 */
		// Start line: 1107
	/* end block 2 */
	// End Line: 1108
					UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ SCRIPT_InstanceSplineProcess(struct _Instance *instance /*$s4*/, struct SplineDef *splineDef /*$s3*/, struct SplineDef *rsplineDef /*$s2*/, struct SplineDef *ssplineDef /*$s0*/, int direction /*stack 16*/)
long SCRIPT_InstanceSplineProcess(struct _Instance *instance, struct SplineDef *splineDef, struct SplineDef *rsplineDef, struct SplineDef *ssplineDef, int direction)
{ // line 716, offset 0x8003d480
	/* begin block 1 */
		// Start line: 717
		// Start offset: 0x8003D480
		// Variables:
			struct MultiSpline *multi; // $s1
			unsigned long isClass; // stack offset -28
			unsigned long isParent; // stack offset -32
	/* end block 1 */
	// End offset: 0x8003D568
	// End Line: 747

	/* begin block 2 */
		// Start line: 1466
	/* end block 2 */
	// End Line: 1467
			UNIMPLEMENTED();
	return 0;
}

void SCRIPT_FadeOutProcess(struct _Instance* instance)
{
	instance->fadeValue += (short)(gameTrackerX.timeMult * 32);

	if (instance->fadeValue >= 4096)
	{
		INSTANCE_PlainDeath(instance);
	}
}


// autogenerated function stub: 
// void /*$ra*/ ScriptKillInstance(struct _Instance *instance /*$s2*/, int effect /*$s0*/)
void ScriptKillInstance(struct _Instance *instance, int effect)
{ // line 1046, offset 0x8003d5d0
	/* begin block 1 */
		// Start line: 1047
		// Start offset: 0x8003D5D0
		// Variables:
			struct Object *object; // $s1

		/* begin block 1.1 */
			// Start line: 1069
			// Start offset: 0x8003D65C
			// Variables:
				//struct Object *object; // $v0
		/* end block 1.1 */
		// End offset: 0x8003D67C
		// End Line: 1074

		/* begin block 1.2 */
			// Start line: 1080
			// Start offset: 0x8003D6A4
			// Variables:
				SVECTOR v; // stack offset -24
		/* end block 1.2 */
		// End offset: 0x8003D6E0
		// End Line: 1087

		/* begin block 1.3 */
			// Start line: 1093
			// Start offset: 0x8003D6E0
			// Variables:
				struct FXSplinter *splinterData; // $a0
				int facadeFlg; // $a1
				short shardFlags; // $a2

			/* begin block 1.3.1 */
				// Start line: 1100
				// Start offset: 0x8003D704
				// Variables:
					struct GenericTune *tune; // $v1
			/* end block 1.3.1 */
			// End offset: 0x8003D730
			// End Line: 1108
		/* end block 1.3 */
		// End offset: 0x8003D780
		// End Line: 1114
	/* end block 1 */
	// End offset: 0x8003D798
	// End Line: 1127

	/* begin block 2 */
		// Start line: 1848
	/* end block 2 */
	// End Line: 1849
					UNIMPLEMENTED();
}




