#include "CORE.H"
#include "COLLIDE.H"

#include "MEMPACK.H"
#include "Game/STREAM.H"
#include "Game/BSP.H"
#include "Game/CAMERA.H"
#include "Game/MATH3D.H"
#include "Game/PSX/COLLIDES.H"
#include "Game/EVENT.H"

#ifdef PC_VERSION
#pragma warning(disable: 4101)
#endif

long collide_ignoreAttr;
long collide_acceptAttr;
long dyna_clddyna[8]; // offset 0x800d056c
long stat_clddyna[8]; // offset 0x800d058c
long dyna_cldstat[8]; // offset 0x800d05ac

void G2Quat_ToMatrix(struct _G2EulerAngles_Type* a1, struct _G2Matrix_Type* a2)
{
#if defined(PC_VERSION)
	int x; // ecx
	int y; // ebp
	int z; // ebx
	int order; // esi
	int v6; // edx
	int v7; // eax
	int v8; // ebx
	int v9; // edi
	int v10; // esi
	int v11; // [esp+10h] [ebp-Ch]
	int v12; // [esp+14h] [ebp-8h]
	int v13; // [esp+18h] [ebp-4h]
	int a1a; // [esp+20h] [ebp+4h]

	x = a1->x;
	y = a1->y;
	z = a1->z;
	order = a1->order;
	v6 = x * order;
	v11 = (z * order) >> 11;
	v12 = (x * x) >> 11;
	v7 = x * z;
	v13 = (y * z) >> 11;
	v8 = (y * y) >> 11;
	a1a = (a1->z * a1->z) >> 11;
	v9 = (x * y) >> 11;
	a2->rotScale[0][0] = 4096 - v8 - a1a;
	v10 = (y * order) >> 11;
	v7 >>= 11;
	a2->rotScale[0][1] = v9 - v11;
	a2->rotScale[0][2] = v7 + v10;
	a2->rotScale[1][0] = v11 + v9;
	a2->rotScale[1][1] = 4096 - v12 - a1a;
	v6 >>= 11;
	a2->rotScale[2][0] = v7 - v10;
	a2->rotScale[2][1] = v6 + v13;
	a2->rotScale[1][2] = v13 - v6;
	a2->rotScale[2][2] = 4096 - v12 - v8;
#else
	UNIMPLEMENTED();
#endif
}

// autogenerated function stub: 
// int /*$ra*/ COLLIDE_PointInTriangle(struct _SVector *v0 /*$a0*/, struct _SVector *v1 /*$a1*/, struct _SVector *v2 /*$a2*/, struct _SVector *point /*$a3*/, struct _SVector *normal /*stack 16*/)
int COLLIDE_PointInTriangle(struct _SVector* v0, struct _SVector* v1, struct _SVector* v2, struct _SVector* point, struct _SVector* normal)
{ // line 243, offset 0x8001e460
#if defined(PC_VERSION)
	struct _Triangle2D* triangle; // eax
	int x; // edi
	__int16 y; // cx
	int v8; // edx
	int v9; // ecx
	__int16* p_x; // ecx
	__int16 v11; // si
	__int16 z; // dx
	__int16 v13; // bx
	int v14; // edi
	__int16 v15; // bp
	int v16; // edx
	__int16 v17; // bx
	int v18; // eax
	int v19; // ecx
	int v20; // eax
	int v21; // zf
	int v23; // [esp+10h] [ebp-8h]
	__int16 v0a; // [esp+1Ch] [ebp+4h]
	int v1a; // [esp+20h] [ebp+8h]
	struct _SVector* v2a; // [esp+24h] [ebp+Ch]
	int normala; // [esp+2Ch] [ebp+14h]

	triangle = (struct _Triangle2D*)getScratchAddr(0);
	x = normal->x;
	if (normal->x < 0)
		x = -x;
	y = normal->y;
	v8 = y;
	if (y < 0)
		v8 = -y;
	v9 = normal->z;
	if (x <= v8)
	{
		v9 = (__int16)v9;
		if ((v9 & 0x8000u) != 0)
			v9 = -(__int16)v9;
		if (v8 > v9)
		{
			*(DWORD*)&triangle->x0 = (unsigned __int16)v0->x | (v0->z << 16);
			p_x = &triangle->x2;
			*(DWORD*)&triangle->x1 = (unsigned __int16)v1->x | (v1->z << 16);
			*(DWORD*)&triangle->x2 = (unsigned __int16)v2->x | (v2->z << 16);
			v11 = point->x;
			z = point->z;
			goto LABEL_15;
		}
	LABEL_14:
		*(DWORD*)&triangle->x0 = (unsigned __int16)v0->x | (v0->y << 16);
		p_x = &triangle->x2;
		*(DWORD*)&triangle->x1 = (unsigned __int16)v1->x | (v1->y << 16);
		*(DWORD*)&triangle->x2 = (unsigned __int16)v2->x | (v2->y << 16);
		v11 = point->x;
		z = point->y;
		goto LABEL_15;
	}
	v9 = (__int16)v9;
	if ((v9 & 0x8000u) != 0)
		v9 = -(__int16)v9;
	if (x <= v9)
		goto LABEL_14;
	*(DWORD*)&triangle->x0 = (v0->z << 16) | (unsigned __int16)v0->y;
	p_x = &triangle->x2;
	*(DWORD*)&triangle->x1 = (v1->z << 16) | (unsigned __int16)v1->y;
	*(DWORD*)&triangle->x2 = (v2->z << 16) | (unsigned __int16)v2->y;
	v11 = point->y;
	z = point->z;
LABEL_15:
	v0a = z;
	v13 = z;
	v2a = (struct _SVector*)triangle;
	v1a = 0;
	normala = 0;
	v23 = 3;
	v14 = p_x[1] >= z;
	do
	{
		v15 = triangle->y0;
		v16 = v15 >= v13;
		if (v14 == v16)
		{
			if (v14 && v13 == p_x[1])
			{
				if (v13 == v15)
				{
					if (v11 > *p_x != v11 > triangle->x0 || v11 == *p_x || v11 == triangle->x0)
						return 1;
					v13 = v0a;
				}
				else if (v11 == *p_x)
				{
					return 1;
				}
			}
			goto LABEL_36;
		}
		v17 = triangle->x0;
		if (*p_x >= v11 == triangle->x0 >= (unsigned __int16)v11)
		{
			if (*p_x >= v11)
				v1a = v1a == 0;
		}
		else
		{
			v18 = p_x[1] - v15;
			v19 = v18 * (v17 - v11) - (*p_x - v17) * (v15 - v0a);
			if (v18 < 0)
			{
				v18 = -v18;
				v19 = -v19;
			}
			v20 = v18 / 2;
			if (v19 <= v20)
			{
				if (v19 >= -v20)
					return 1;
			}
			else
			{
				v1a = v1a == 0;
			}
			triangle = (struct _Triangle2D*)v2a;
		}
		if (normala)
			break;
		v13 = v0a;
		normala = 1;
	LABEL_36:
		v14 = v16;
		p_x = &triangle->x0;
		triangle = (struct _Triangle2D*)((char*)triangle + 4);
		v21 = v23 == 1;
		v2a = (struct _SVector*)triangle;
		--v23;
	} while (!v21);
	return v1a;
#else
UNIMPLEMENTED();
	return 0;
#endif
}

int COLLIDE_PointInTriangle2DPub(short* v0, short* v1, short* v2, short* point)
{
#if defined(PSX_VERSION)
	struct _SVector normal;

	normal.x = 0;
	normal.y = 0;
	normal.z = 4096;

	return COLLIDE_PointInTriangle((struct _SVector*)v0, (struct _SVector*)v1, (struct _SVector*)v2, (struct _SVector*)point, (struct _SVector*)&normal);

#elif defined(PC_VERSION)
	struct _SVector normal; // [esp+0h] [ebp-8h] BYREF

	normal.z = 4096;
	normal.x = 0;
	normal.y = 0;
	normal.pad = 0;
	return COLLIDE_PointInTriangle(
		(struct _SVector*)v0,
		(struct _SVector*)v1,
		(struct _SVector*)v2,
		(struct _SVector*)point,
		&normal);
#endif
}

long COLLIDE_GetNormal(short nNum, short* nrmlArray, struct _SVector* nrml)//Matching - 99.87%
{
#if defined(PSX_VERSION)
	short* sPtr;
	long bitMask;

	if (nNum >= 0)
	{
		sPtr = &nrmlArray[nNum * 3];

		bitMask = *sPtr++;

		nrml->x = bitMask & 0x1FFF;
		nrml->y = *sPtr++;
		nrml->z = *sPtr;

		bitMask >>= 13;
	}
	else
	{
		sPtr = &nrmlArray[-nNum * 3];
		bitMask = *sPtr++;

		nrml->x = -(bitMask & 0x1FFF);
		nrml->y = -(*sPtr++);
		nrml->z = -(*sPtr);

		bitMask >>= 13;
	}

	return bitMask;

#elif defined(PC_VERSION)
	__int16 v3; // dx
	int result; // eax
	__int16* v5; // ecx
	__int16 v6; // dx

	if (nNum < 0)
	{
		v5 = &nrmlArray[-3 * nNum];
		v6 = *v5++;
		nrml->x = -(v6 & 0x1FFF);
		nrml->y = -*v5;
		nrml->z = -v5[1];
		return v6 >> 13;
	}
	else
	{
		v3 = nrmlArray[3 * nNum];
		result = v3 >> 13;
		nrml->x = v3 & 0x1FFF;
		nrml->y = nrmlArray[3 * nNum + 1];
		nrml->z = nrmlArray[3 * nNum + 2];
	}
	return result;
#endif
}

void COLLIDE_MakeNormal(struct _Terrain* terrain, struct _TFace* tface, struct _SVector* normal)
{
#if defined(PSX_VERSION)
	UNIMPLEMENTED();
#elif defined(PC_VERSION)
	struct _Vector* ScratchAddr; // esi
	DWORD* v4; // edi
	int* v5; // ebx
	struct _TVertex* vertexList; // edx
	struct _TVertex* v7; // ecx
	struct _TVertex* v8; // edx
	int z; // eax
	int v10; // edx
	int v11; // eax
	int v12; // eax
	int v13; // ecx
	int v14; // sf
	int v15; // edi
	int v16; // esi
	int v17; // edx
	int v18; // edx
	struct _Terrain* terraina; // [esp+14h] [ebp+4h]

	ScratchAddr = (struct _Vector*)getScratchAddr(0);
	v4 = (DWORD*)getScratchAddr(4);
	v5 = (int*)getScratchAddr(8);
	vertexList = terrain->vertexList;
	v7 = &vertexList[tface->face.v0];
	terraina = (struct _Terrain*)&vertexList[tface->face.v1];
	v8 = &vertexList[tface->face.v2];
	ScratchAddr->x = terraina->UnitChangeFlags - v7->vertex.x;
	ScratchAddr->y = terraina->spad - v7->vertex.y;
	ScratchAddr->z = terraina->lpad2 - v7->vertex.z;
	*v4 = v8->vertex.x - v7->vertex.x;
	v4[1] = v8->vertex.y - v7->vertex.y;
	z = v8->vertex.z;
	v10 = v4[1];
	v11 = z - v7->vertex.z;
	v4[2] = v11;
	*v5 = (__int16)((ScratchAddr->y * v11 - ScratchAddr->z * v10) >> 12);
	v5[1] = -(__int16)((v4[2] * ScratchAddr->x - ScratchAddr->z * *v4) >> 12);
	v12 = *v5;
	v13 = (__int16)((v4[1] * ScratchAddr->x - ScratchAddr->y * *v4) >> 12);
	v14 = *v5 < 0;
	v5[2] = v13;
	v15 = v12;
	if (v14)
		v15 = -v12;
	v16 = v5[1];
	v17 = v16;
	if (v16 < 0)
		v17 = -v16;
	if (v15 <= v17)
	{
		if (v16 >= 0)
			goto LABEL_10;
	}
	else
	{
		v16 = v12;
		if (v12 >= 0)
			goto LABEL_10;
	}
	v16 = -v16;
LABEL_10:
	v18 = v13;
	if (v13 < 0)
		v18 = -v13;
	if (v18 > v16)
	{
		if (v13 < 0)
			v13 = -v13;
		v16 = v13;
	}
	if (v16)
	{
		normal->x = (v12 << 12) / v16;
		normal->y = (v5[1] << 12) / v16;
		normal->z = (v5[2] << 12) / v16;
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_UpdateAllTransforms(struct _Instance *instance /*$a0*/, SVECTOR*offset /*$a1*/)
void COLLIDE_UpdateAllTransforms(struct _Instance *instance, SVECTOR*offset)
{ // line 415, offset 0x8001e9c0
#if defined(PC_VERSION)
#ifndef PC_VERSION
	MATRIX* matrix; // ebx
	int vx; // edx
	int vy; // esi
	int vz; // edi
	struct Object* object; // eax
	struct _Model* v7; // ecx
	MATRIX* v8; // eax
	int numSegments; // ecx
	struct _Model* v10; // ecx
	__int32* v11; // eax
	__int32 v12; // ebp
	__int32 v13; // ebx

	matrix = instance->matrix;
	if (matrix)
	{
		vx = offset->vx;
		vy = offset->vy;
		vz = offset->vz;
		object = instance->object;
		if (!object->animList || (object->oflags2 & 0x40000000) != 0)
		{
			v10 = object->modelList[instance->currentModel];
			v8 = instance->matrix;
			numSegments = v10->numSegments;
		}
		else
		{
			v7 = object->modelList[instance->currentModel];
			v8 = matrix - 1;
			numSegments = v7->numSegments + 1;
		}
		if (numSegments)
		{
			v11 = &v8->t[1];
			do
			{
				v12 = vy + *v11;
				*(v11 - 1) += vx;
				v13 = vz + v11[1];
				*v11 = v12;
				v11[1] = v13;
				v11 += 8;
				--numSegments;
			} while (numSegments);
		}
	}
#endif
#else
	UNIMPLEMENTED();
#endif
}

void COLLIDE_MoveAllTransforms(struct _Instance* instance, struct _Position* offset)
{
#if defined(PSX_VERSION)
	UNIMPLEMENTED();
#elif defined(PC_VERSION)
#ifndef PC_VERSION
	MATRIX* oldMatrix; // ebx
	int x; // edx
	int y; // esi
	int z; // edi
	struct Object* object; // eax
	struct _Model* v7; // ecx
	MATRIX* v8; // eax
	int numSegments; // ecx
	struct _Model* v10; // ecx
	__int32* v11; // eax
	__int32 v12; // ebp
	__int32 v13; // ebx

	oldMatrix = instance->oldMatrix;
	if (oldMatrix)
	{
		x = offset->x;
		y = offset->y;
		z = offset->z;
		object = instance->object;
		if (!object->animList || (object->oflags2 & 0x40000000) != 0)
		{
			v10 = object->modelList[instance->currentModel];
			v8 = instance->oldMatrix;
			numSegments = v10->numSegments;
		}
		else
		{
			v7 = object->modelList[instance->currentModel];
			v8 = oldMatrix - 1;
			numSegments = v7->numSegments + 1;
		}
		if (numSegments)
		{
			v11 = &v8->t[1];
			do
			{
				v12 = y + *v11;
				*(v11 - 1) += x;
				v13 = z + v11[1];
				*v11 = v12;
				v11[1] = v13;
				v11 += 8;
				--numSegments;
			} while (numSegments);
		}
	}
#endif
#else
	UNIMPLEMENTED();
#endif
}

long COLLIDE_WithinYZBounds(struct _SVector* point, struct _HBox* hbox)//Matching - 86.52%
{
	if (point->y >= hbox->minY && hbox->maxY >= point->y)
	{
		if (point->z >= hbox->minZ)
		{
			return hbox->maxZ >= point->z;
		}
	}
	return 0;
}

long COLLIDE_WithinXZBounds(struct _SVector* point, struct _HBox* hbox)
{
	if (point->x >= hbox->minX && hbox->maxX >= point->x)
	{
		if (point->z >= hbox->minZ)
		{
			return hbox->maxZ >= point->z;
		}
	}
	return 0;
}

long COLLIDE_WithinXYBounds(struct _SVector* point, struct _HBox* hbox)
{
	if (point->x >= hbox->minX && hbox->maxX >= point->x)
	{
		if (point->y >= hbox->minY)
		{
			return hbox->maxY >= point->y;
		}
	}
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_LineWithBoxFace(short startDist /*$a0*/, long lineDist /*$a1*/, short planeDist /*$a2*/, struct _SVector *start /*$a3*/, struct _Vector *line /*stack 16*/, struct _HBox *hbox /*stack 20*/, TDRFuncPtr_COLLIDE_LineWithBoxFace6collideBoundFunc collideBoundFunc /*stack 24*/, struct _SVector *normal /*stack 28*/)
void COLLIDE_LineWithBoxFace(short startDist, long lineDist, short planeDist, struct _SVector *start, struct _Vector *line, struct _HBox *hbox, TDRFuncPtr_COLLIDE_LineWithBoxFace6collideBoundFunc collideBoundFunc, struct _SVector *normal)
{ // line 611, offset 0x8001ec74
#if 0
	/* begin block 1 */
		// Start line: 612
		// Start offset: 0x8001EC74
		// Variables:
			struct _SVector point; // stack offset -24
			long t; // stack offset -16

		/* begin block 1.1 */
			// Start line: 612
			// Start offset: 0x8001ED38
			// Variables:
				struct _SVector *point; // $t1
				struct _SVector *normal; // $s0
				struct _SVector *point0; // $a2
				struct _SVector *normal0; // $a3
				struct _SVector *point1; // $a1
				struct _SVector *normal1; // $t0

			/* begin block 1.1.1 */
				// Start line: 612
				// Start offset: 0x8001ED38

				/* begin block 1.1.1.1 */
					// Start line: 612
					// Start offset: 0x8001ED5C
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.1 */
				// End offset: 0x8001ED5C
				// End Line: 612

				/* begin block 1.1.1.2 */
					// Start line: 612
					// Start offset: 0x8001ED5C
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.2 */
				// End offset: 0x8001ED5C
				// End Line: 612

				/* begin block 1.1.1.3 */
					// Start line: 612
					// Start offset: 0x8001ED5C
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.3 */
				// End offset: 0x8001ED5C
				// End Line: 612

				/* begin block 1.1.1.4 */
					// Start line: 612
					// Start offset: 0x8001ED5C
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.4 */
				// End offset: 0x8001ED5C
				// End Line: 612

				/* begin block 1.1.1.5 */
					// Start line: 612
					// Start offset: 0x8001EDDC
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.5 */
				// End offset: 0x8001EDDC
				// End Line: 612

				/* begin block 1.1.1.6 */
					// Start line: 612
					// Start offset: 0x8001EDDC
					// Variables:
						short _z1; // $a0
						short _y1; // $v1
						short _x1; // $v0
				/* end block 1.1.1.6 */
				// End offset: 0x8001EDDC
				// End Line: 612
			/* end block 1.1.1 */
			// End offset: 0x8001EE10
			// End Line: 612
		/* end block 1.1 */
		// End offset: 0x8001EE10
		// End Line: 612
	/* end block 1 */
	// End offset: 0x8001EE10
	// End Line: 643

	/* begin block 2 */
		// Start line: 1111
	/* end block 2 */
	// End Line: 1112
#else
UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_IntersectLineAndBox(struct _SVector *point0 /*$a0*/, struct _SVector *normal0 /*$a1*/, struct _SVector *point1 /*$a2*/, struct _SVector *normal1 /*$a3*/, struct _SVector *end /*stack 16*/, struct _SVector *start /*stack 20*/, struct _HBox *hbox /*stack 24*/)
long COLLIDE_IntersectLineAndBox(struct _SVector *point0, struct _SVector *normal0, struct _SVector *point1, struct _SVector *normal1, struct _SVector *end, struct _SVector *start, struct _HBox *hbox)
{ // line 650, offset 0x8001ee20
#if 0
	/* begin block 1 */
		// Start line: 651
		// Start offset: 0x8001EE20
		// Variables:
			struct _SVector normal; // stack offset -64
			struct _Vector line; // stack offset -56

		/* begin block 1.1 */
			// Start line: 651
			// Start offset: 0x8001EE20
			// Variables:
				long _x0; // $a1
				long _y0; // $a2
				long _z0; // $a0
				long _x1; // $v0
				long _y1; // $v0
				long _z1; // $v1
				struct _Vector *_v; // $s3
		/* end block 1.1 */
		// End offset: 0x8001EE20
		// End Line: 651
	/* end block 1 */
	// End offset: 0x8001F070
	// End Line: 711

	/* begin block 2 */
		// Start line: 1201
	/* end block 2 */
	// End Line: 1202
#else
	UNIMPLEMENTED();
#endif
	return 0;
}

struct _TFace* COLLIDE_PointAndTerrain(struct _Terrain* terrain, struct _PCollideInfo* pcollideInfo, struct _LCollideInfo* lcol)
{
	return COLLIDE_PointAndTerrainFunc(terrain, pcollideInfo, 0, NULL, 0, 0, lcol);
}


// autogenerated function stub: 
// struct _TFace * /*$ra*/ COLLIDE_PointAndTerrainFunc(struct _Terrain *terrain /*$t2*/, struct _PCollideInfo *pCollideInfo /*stack 4*/, int Flags /*$a2*/, short *Backface_Flag /*$a3*/, long ignoreAttr /*stack 16*/, long acceptAttr /*stack 20*/, struct _LCollideInfo *lcolinfo /*stack 24*/)
struct _TFace * COLLIDE_PointAndTerrainFunc(struct _Terrain *terrain, struct _PCollideInfo *pCollideInfo, int Flags, short *Backface_Flag, long ignoreAttr, long acceptAttr, struct _LCollideInfo *lcolinfo)
{ // line 780, offset 0x8001f0cc
#if 0
	/* begin block 1 */
		// Start line: 781
		// Start offset: 0x8001F0CC
		// Variables:
			struct PandTScratch *CSpad; // $s0
			void **stack; // $s1
			struct _BSPNode *bspNode; // $a1
			int curTree; // stack offset -48
			struct _SVector *NewPos; // stack offset -80
			struct _SVector *OldPos; // $a0
			struct _Instance *instance; // $s7

		/* begin block 1.1 */
			// Start line: 781
			// Start offset: 0x8001F0CC
			// Variables:
				short _x1; // $a3
				short _y1; // $t0
				short _z1; // $t1
				struct _SVector *_v0; // $v1
		/* end block 1.1 */
		// End offset: 0x8001F0CC
		// End Line: 781

		/* begin block 1.2 */
			// Start line: 781
			// Start offset: 0x8001F0CC
			// Variables:
				short _x1; // $v0
				short _y1; // $v1
				short _z1; // $a0
				struct _SVector *_v0; // $a2
		/* end block 1.2 */
		// End offset: 0x8001F0CC
		// End Line: 781

		/* begin block 1.3 */
			// Start line: 781
			// Start offset: 0x8001F0CC
			// Variables:
				struct _SVector *_v; // $a1
		/* end block 1.3 */
		// End offset: 0x8001F0CC
		// End Line: 781

		/* begin block 1.4 */
			// Start line: 837
			// Start offset: 0x8001F22C
			// Variables:
				struct BSPTree *bsp; // $s4

			/* begin block 1.4.1 */
				// Start line: 865
				// Start offset: 0x8001F328
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $t0
					struct _SVector *_v; // $s6
					_Position *_v1; // $a3
			/* end block 1.4.1 */
			// End offset: 0x8001F328
			// End Line: 865

			/* begin block 1.4.2 */
				// Start line: 865
				// Start offset: 0x8001F328
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $a3
					struct _SVector *_v; // $s5
			/* end block 1.4.2 */
			// End offset: 0x8001F328
			// End Line: 865

			/* begin block 1.4.3 */
				// Start line: 898
				// Start offset: 0x8001F558
				// Variables:
					struct _TFace *tface; // $s3

				/* begin block 1.4.3.1 */
					// Start line: 905
					// Start offset: 0x8001F5A4
					// Variables:
						struct _SVector *vertex0; // $a0

					/* begin block 1.4.3.1.1 */
						// Start line: 781
						// Start offset: 0x8001F62C
						// Variables:
							short *nrmlArray; // $a0
							struct _SVector *nrml; // $a1

						/* begin block 1.4.3.1.1.1 */
							// Start line: 781
							// Start offset: 0x8001F62C
							// Variables:
								short *sPtr; // $v1
						/* end block 1.4.3.1.1.1 */
						// End offset: 0x8001F6BC
						// End Line: 781
					/* end block 1.4.3.1.1 */
					// End offset: 0x8001F6BC
					// End Line: 781

					/* begin block 1.4.3.1.2 */
						// Start line: 781
						// Start offset: 0x8001F768
						// Variables:
							struct _SVector *point; // $t0
							struct _SVector *start; // $a3
							struct _SVector *line; // $a2

						/* begin block 1.4.3.1.2.1 */
							// Start line: 781
							// Start offset: 0x8001F768
							// Variables:
								long len; // $v1
								long t; // $a1
						/* end block 1.4.3.1.2.1 */
						// End offset: 0x8001F7A0
						// End Line: 781
					/* end block 1.4.3.1.2 */
					// End offset: 0x8001F7A0
					// End Line: 781

					/* begin block 1.4.3.1.3 */
						// Start line: 950
						// Start offset: 0x8001F8CC
						// Variables:
							short _x0; // $v0
							short _y0; // $v1
							short _z0; // $a1
							short _x1; // $a0
							short _y1; // $a3
							short _z1; // $a2
							_Position *_v1; // $a2
					/* end block 1.4.3.1.3 */
					// End offset: 0x8001F8CC
					// End Line: 950

					/* begin block 1.4.3.1.4 */
						// Start line: 1015
						// Start offset: 0x8001F970
						// Variables:
							short _x0; // $v0
							short _y0; // $v1
							short _z0; // $a1
							short _x1; // $a0
							short _y1; // $a2
							short _z1; // $a3
							struct _SVector *_v; // $fp
					/* end block 1.4.3.1.4 */
					// End offset: 0x8001F970
					// End Line: 1015
				/* end block 1.4.3.1 */
				// End offset: 0x8001F9F4
				// End Line: 1036
			/* end block 1.4.3 */
			// End offset: 0x8001FA34
			// End Line: 1049

			/* begin block 1.4.4 */
				// Start line: 1053
				// Start offset: 0x8001FA34
				// Variables:
					int plane_front_error; // $v1
					int plane_back_error; // $a0
			/* end block 1.4.4 */
			// End offset: 0x8001FB84
			// End Line: 1120

			/* begin block 1.4.5 */
				// Start line: 1124
				// Start offset: 0x8001FB94
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $t0
					_Position *_v1; // $a3
			/* end block 1.4.5 */
			// End offset: 0x8001FB94
			// End Line: 1124

			/* begin block 1.4.6 */
				// Start line: 1124
				// Start offset: 0x8001FB94
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a2
					short _z1; // $a3
			/* end block 1.4.6 */
			// End offset: 0x8001FBF8
			// End Line: 1125
		/* end block 1.4 */
		// End offset: 0x8001FBF8
		// End Line: 1126

		/* begin block 1.5 */
			// Start line: 1127
			// Start offset: 0x8001FC10
			// Variables:
				short _x1; // $v1
				short _y1; // $a0
				short _z1; // $v0
				struct _SVector *_v1; // $v0
		/* end block 1.5 */
		// End offset: 0x8001FC10
		// End Line: 1127
	/* end block 1 */
	// End offset: 0x8001FC10
	// End Line: 1127

	/* begin block 2 */
		// Start line: 1540
	/* end block 2 */
	// End Line: 1541
#endif
	UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// int /*$ra*/ COLLIDE_PointAndHFace(struct _SVector *newPos /*$s4*/, struct _SVector *oldPos /*$s6*/, struct _HFace *hface /*$s5*/, struct _Model *model /*$s7*/, struct _SVector *hfNormal /*stack 16*/)
int COLLIDE_PointAndHFace(struct _SVector *newPos, struct _SVector *oldPos, struct _HFace *hface, struct _Model *model, struct _SVector *hfNormal)
{ // line 1330, offset 0x8001fc64
#if 0
	/* begin block 1 */
		// Start line: 1331
		// Start offset: 0x8001FC64
		// Variables:
			MATRIX *posMatrix; // $s1
			struct _SVector *normal; // $s3
			struct _Vector *dpv; // $s2
			struct _SVector *planePoint; // stack offset -48
			struct _SVector *vertex0; // $s0
			struct _SVector *vertex1; // $s1

		/* begin block 1.1 */
			// Start line: 1341
			// Start offset: 0x8001FCD0
			// Variables:
				short _x0; // $v0
				short _y0; // $v1
				short _z0; // $a1
				short _x1; // $a2
				short _y1; // $a3
				short _z1; // $t0
		/* end block 1.1 */
		// End offset: 0x8001FCD0
		// End Line: 1341

		/* begin block 1.2 */
			// Start line: 1341
			// Start offset: 0x8001FCD0
			// Variables:
				short _x0; // $v0
				short _y0; // $v1
				short _z0; // $a1
				short _x1; // $a2
				short _y1; // $a3
				short _z1; // $t0
				struct _SVector *_v; // $t1
		/* end block 1.2 */
		// End offset: 0x8001FCD0
		// End Line: 1341

		/* begin block 1.3 */
			// Start line: 1341
			// Start offset: 0x8001FCD0
			// Variables:
				short _x1; // $v0
				short _y1; // $v1
				short _z1; // $a1
				struct _SVector *_v0; // $t3
		/* end block 1.3 */
		// End offset: 0x8001FCD0
		// End Line: 1341
	/* end block 1 */
	// End offset: 0x8001FE7C
	// End Line: 1378

	/* begin block 2 */
		// Start line: 3219
	/* end block 2 */
	// End Line: 3220
#endif
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_PointAndInstance(struct _PCollideInfo *pcollideInfo /*$s4*/, struct _Instance *instance /*stack 4*/)
void COLLIDE_PointAndInstance(struct _PCollideInfo *pcollideInfo, struct _Instance *instance)
{ // line 1389, offset 0x8001feac
#if 0
	/* begin block 1 */
		// Start line: 1390
		// Start offset: 0x8001FEAC
		// Variables:
			MATRIX *swTransform; // stack offset -92
			MATRIX *wsTransform; // stack offset -88
			MATRIX *swNormMat; // $fp
			struct _Vector *oldPosVec; // stack offset -84
			struct _Vector *lNormal; // stack offset -80
			struct _Vector *wNormal; // stack offset -76
			struct _Vector *dv; // $s2
			struct _Vector *newPosVec; // $s5
			struct _SVector *oldPos; // stack offset -72
			struct _SVector *newPos; // $s3
			struct _SVector *point; // stack offset -68
			long *flag; // stack offset -64
			struct _Model *model; // stack offset -60
			struct _HModel *hmodel; // $v0
			struct _HPrim *hprim; // stack offset -56
			int i; // stack offset -52
			long collideType; // stack offset -48

		/* begin block 1.1 */
			// Start line: 1416
			// Start offset: 0x8001FFCC
			// Variables:
				struct _HBox *hbox; // $s0
				struct _HFace *hface; // $s1
				struct _HSphere *hsphere; // $s0

			/* begin block 1.1.1 */
				// Start line: 1419
				// Start offset: 0x8001FFCC
				// TypeDefs:
					struct COLLIDE_258fake tmm
			/* end block 1.1.1 */
			// End offset: 0x8001FFCC
			// End Line: 1419

			/* begin block 1.1.2 */
				// Start line: 1452
				// Start offset: 0x80020184
				// Variables:
					long len; // $t0

				/* begin block 1.1.2.1 */
					// Start line: 1453
					// Start offset: 0x80020184
					// Variables:
						long a; // stack offset -104
						long b; // stack offset -100
						long c; // stack offset -96
				/* end block 1.1.2.1 */
				// End offset: 0x80020184
				// End Line: 1453
			/* end block 1.1.2 */
			// End offset: 0x80020248
			// End Line: 1459

			/* begin block 1.1.3 */
				// Start line: 1488
				// Start offset: 0x800203F0
				// Variables:
					struct _SVector hfNormal; // stack offset -136
			/* end block 1.1.3 */
			// End offset: 0x80020418
			// End Line: 1494

			/* begin block 1.1.4 */
				// Start line: 1509
				// Start offset: 0x80020450
				// Variables:
					struct _SVector hbNormal; // stack offset -136
					struct _SVector point0; // stack offset -128
					struct _SVector point1; // stack offset -120
					struct _SVector normal1; // stack offset -112

				/* begin block 1.1.4.1 */
					// Start line: 1551
					// Start offset: 0x80020590
					// Variables:
						short _x1; // $v0
						short _y1; // $v1
						short _z1; // $a3
				/* end block 1.1.4.1 */
				// End offset: 0x80020590
				// End Line: 1551
			/* end block 1.1.4 */
			// End offset: 0x800205D8
			// End Line: 1561
		/* end block 1.1 */
		// End offset: 0x80020690
		// End Line: 1580
	/* end block 1 */
	// End offset: 0x800206B0
	// End Line: 1582

	/* begin block 2 */
		// Start line: 3368
	/* end block 2 */
	// End Line: 3369
#endif
						UNIMPLEMENTED();
}

void COLLIDE_PointAndInstanceTrivialReject(struct _PCollideInfo* pcollideInfo, struct _Instance* instance)//Matching - 91.86%
{
	struct _Vector* dv;
	struct _SVector linePoint;
	long _x0;
	long _y0;
	long _z0;
	long _x1;
	long _y1;
	long _z1;
	struct _SVector* _v0;

	dv = (struct _Vector*)getScratchAddr(0);

	if (MEMPACK_MemoryValidFunc((char*)instance->object)
		&& !(instance->flags & 0x40)
		&& instance->hModelList
		&& (!(pcollideInfo->collideType & 0x40) || !(instance->object->oflags2 & 0x40)))
	{
		_v0 = &linePoint;

		COLLIDE_NearestPointOnLine_S(_v0, pcollideInfo->oldPoint, pcollideInfo->newPoint, &instance->position);

		_x1 = _v0->x;
		_y1 = _v0->y;
		_z1 = _v0->z;

		_x0 = instance->position.x;
		_y0 = instance->position.y;
		_z0 = instance->position.z;

		dv->x = (_x1 - _x0);
		dv->y = (_y1 - _y0);
		dv->z = (_z1 - _z0);

		dv->x >>= 1;
		dv->y >>= 1;
		dv->z >>= 1;

		if ((dv->x * dv->x) + (dv->y * dv->y) + (dv->z * dv->z) < (instance->object->modelList[instance->currentModel]->maxRadSq >> 2))
		{
			if (instance->matrix)
			{
				COLLIDE_PointAndInstance(pcollideInfo, instance);
			}
		}
	}
}

void COLLIDE_PointAndWorld(struct _PCollideInfo* pcollideInfo, struct Level* level)//Matching - 96.50%
{
	int i;
	struct _LCollideInfo lcol;
	struct _Instance* instance;
	struct Level* thislevel;
	struct _TFace* tface;
	int in_warpRoom;
	struct _Terrain* terrain;
	struct _InstanceList* instanceList;
	struct _StreamUnit* streamUnit;

	in_warpRoom = 0;

	pcollideInfo->type = 0;

	if ((pcollideInfo->collideType & 0x1))
	{
		tface = NULL;

		if (level != NULL && MEMPACK_MemoryValidFunc((char*)level))
		{
			terrain = level->terrain;

			tface = COLLIDE_PointAndTerrain(terrain, pcollideInfo, &lcol);

			if (tface != NULL)
			{
				pcollideInfo->type = 3;
				pcollideInfo->prim = tface;
				pcollideInfo->inst = (struct _Instance*)level;
				pcollideInfo->segment = lcol.curTree;

				if (gameTrackerX.gameData.asmData.MorphTime != 1000)
				{
					COLLIDE_MakeNormal(terrain, tface, (struct _SVector*)&pcollideInfo->wNormal);
				}
				else
				{
					COLLIDE_GetNormal((short)tface->normal, &terrain->normalList->x, (struct _SVector*)&pcollideInfo->wNormal);
				}
			}
			else if ((STREAM_GetStreamUnitWithID(level->streamUnitID)->flags & 0x1) != 0)
			{
				in_warpRoom = 1;
			}
		}
		if (tface == NULL)
		{
			streamUnit = &StreamTracker.StreamList[0];

			for (i = 0; i < 16; i++, streamUnit++)
			{
				thislevel = streamUnit->level;

				if (streamUnit->used == 2 && thislevel != level && (!in_warpRoom || !(streamUnit->flags & 0x1)))
				{
					if (MEMPACK_MemoryValidFunc((char*)thislevel))
					{
						terrain = thislevel->terrain;

						tface = COLLIDE_PointAndTerrain(terrain, pcollideInfo, &lcol);

						if (tface != NULL)
						{
							pcollideInfo->type = 3;
							pcollideInfo->prim = tface;
							pcollideInfo->inst = (struct _Instance*)thislevel;
							pcollideInfo->segment = lcol.curTree;

							if (gameTrackerX.gameData.asmData.MorphTime != 1000)
							{
								COLLIDE_MakeNormal(terrain, tface, (struct _SVector*)&pcollideInfo->wNormal);
							}
							else
							{
								COLLIDE_GetNormal((short)tface->normal, &terrain->normalList->x, (struct _SVector*)&pcollideInfo->wNormal);
							}
							break;
						}
					}
				}
			}

			if (tface == NULL)
			{
				pcollideInfo->type = 0;
				pcollideInfo->prim = 0;
				pcollideInfo->inst = 0;
				pcollideInfo->wNormal.vx = 0;
				pcollideInfo->wNormal.vy = 0;
				pcollideInfo->wNormal.vz = 0;
			}
		}
	}

	instanceList = gameTrackerX.instanceList;

	if ((pcollideInfo->collideType & 0x8) != 0)
	{
		for (i = 16; i < 32; i++)
		{
			instance = (struct _Instance*)instanceList->group[i].next;

			while (instance)
			{
				if (!(instance->flags2 & 0x24000000))
				{
					COLLIDE_PointAndInstanceTrivialReject(pcollideInfo, instance);
				}

				instance = (struct _Instance*)instance->node.next;
			}
		}
	}
	else if ((pcollideInfo->collideType & 0x10) != 0)
	{
		if ((pcollideInfo->collideType & 0x2) != 0)
		{
			for (i = 0; i < 8; i++)
			{
				instance = (struct _Instance*)instanceList->group[stat_clddyna[i]].next;

				while (instance)
				{
					if (!(instance->flags2 & 0x24000000))
					{
						COLLIDE_PointAndInstanceTrivialReject(pcollideInfo, instance);
					}

					instance = (struct _Instance*)instance->node.next;
				}
			}
		}
		if ((pcollideInfo->collideType & 0x4) != 0)
		{
			for (i = 0; i < 8; i++)
			{
				instance = (struct _Instance*)instanceList->group[dyna_clddyna[i]].next;

				while (instance)
				{
					if (!(instance->flags2 & 0x24000000))
					{
						COLLIDE_PointAndInstanceTrivialReject(pcollideInfo, instance);
					}

					instance = (struct _Instance*)instance->node.next;
				}
			}
		}
	}
	else
	{
		if ((pcollideInfo->collideType & 0x4))
		{
			for (i = 0; i < 8; i++)
			{
				instance = (struct _Instance*)instanceList->group[dyna_cldstat[i]].next;

				while (instance)
				{
					if (!(instance->flags2 & 0x24000000))
					{
						COLLIDE_PointAndInstanceTrivialReject(pcollideInfo, instance);
					}

					instance = (struct _Instance*)instance->node.next;
				}
			}
		}
	}
}

// autogenerated function stub: 
// long /*$ra*/ COLLIDE_ClosestPointInBoxToPoint(_Position *boxPoint /*$a0*/, struct _HBox *hbox /*$a1*/, struct _SVector *point /*$a2*/)
long COLLIDE_ClosestPointInBoxToPoint(_Position *boxPoint, struct _HBox *hbox, struct _SVector *point)
{ // line 1893, offset 0x80020c4c
	/* begin block 1 */
		// Start line: 1895
		// Start offset: 0x80020C4C
		// Variables:
			long inside; // $a3
	/* end block 1 */
	// End offset: 0x80020D18
	// End Line: 1941

	/* begin block 2 */
		// Start line: 4803
	/* end block 2 */
	// End Line: 4804

	/* begin block 3 */
		// Start line: 4804
	/* end block 3 */
	// End Line: 4805

	/* begin block 4 */
		// Start line: 4806
	/* end block 4 */
	// End Line: 4807
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_SphereAndPoint(struct _Sphere *sphere /*$s1*/, struct _SVector *point /*$s2*/, struct _SVector *normal /*$s3*/)
long COLLIDE_SphereAndPoint(struct _Sphere *sphere, struct _SVector *point, struct _SVector *normal)
{ // line 1944, offset 0x80020d20
	/* begin block 1 */
		// Start line: 1945
		// Start offset: 0x80020D20
		// Variables:
			long len; // $a2
			struct _Vector *line; // $s0

		/* begin block 1.1 */
			// Start line: 1945
			// Start offset: 0x80020D20
			// Variables:
				long _x0; // $a2
				long _y0; // $a1
				long _z0; // $a0
				long _x1; // $v0
				long _y1; // $v0
				long _z1; // $v0
		/* end block 1.1 */
		// End offset: 0x80020D20
		// End Line: 1945

		/* begin block 1.2 */
			// Start line: 1953
			// Start offset: 0x80020DB4
			// Variables:
				long a; // stack offset -40
				long b; // stack offset -36
				long c; // stack offset -32
		/* end block 1.2 */
		// End offset: 0x80020DB4
		// End Line: 1953
	/* end block 1 */
	// End offset: 0x80020F48
	// End Line: 1970

	/* begin block 2 */
		// Start line: 4905
	/* end block 2 */
	// End Line: 4906
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_SphereAndHBox(struct _HBox *hbox /*$s4*/, struct _Sphere *sphere /*$s1*/, _Position *oldPos /*$s5*/, struct _SVector *normal /*$s3*/)
long COLLIDE_SphereAndHBox(struct _HBox *hbox, struct _Sphere *sphere, _Position *oldPos, struct _SVector *normal)
{ // line 1975, offset 0x80020f64
#if 0
	/* begin block 1 */
		// Start line: 1976
		// Start offset: 0x80020F64
		// Variables:
			struct _SVector point; // stack offset -96
			struct _SVector point0; // stack offset -88
			struct _SVector point1; // stack offset -80
			struct _SVector normal0; // stack offset -72
			struct _SVector normal1; // stack offset -64
			struct _SVector sphereNormal; // stack offset -56
			struct _SVector dv; // stack offset -48
			struct _SVector absdv; // stack offset -40

		/* begin block 1.1 */
			// Start line: 1989
			// Start offset: 0x80020FAC
			// Variables:
				long numIntersects; // $a2

			/* begin block 1.1.1 */
				// Start line: 1993
				// Start offset: 0x80020FDC
				// Variables:
					short _x1; // $v0
					short _y1; // $v1
					short _z1; // $a0
			/* end block 1.1.1 */
			// End offset: 0x80020FDC
			// End Line: 1993

			/* begin block 1.1.2 */
				// Start line: 1993
				// Start offset: 0x80020FDC
				// Variables:
					short _x1; // $a0
					short _y1; // $v1
					short _z1; // $a1
					struct _SVector *_v0; // $v0
			/* end block 1.1.2 */
			// End offset: 0x80020FDC
			// End Line: 1993

			/* begin block 1.1.3 */
				// Start line: 2000
				// Start offset: 0x8002107C
				// Variables:
					short _y0; // $v0
					short _z0; // $v1
					short _x1; // $v0
					short _y1; // $a2
					short _z1; // $a3
					struct _SVector *_v; // $a1
					struct _SVector *_v0; // $v1
			/* end block 1.1.3 */
			// End offset: 0x8002107C
			// End Line: 2000
		/* end block 1.1 */
		// End offset: 0x80021290
		// End Line: 2076

		/* begin block 1.2 */
			// Start line: 2080
			// Start offset: 0x80021290

			/* begin block 1.2.1 */
				// Start line: 2087
				// Start offset: 0x800212D4
				// Variables:
					short _x1; // $v0
					short _y1; // $v1
					short _z1; // $a0
					struct _SVector *_v0; // $v0
					struct _SVector *_v1; // $v0
			/* end block 1.2.1 */
			// End offset: 0x800212D4
			// End Line: 2087

			/* begin block 1.2.2 */
				// Start line: 2087
				// Start offset: 0x800212D4
				// Variables:
					short _x1; // $v1
					short _y1; // $a0
					short _z1; // $a1
			/* end block 1.2.2 */
			// End offset: 0x800212D4
			// End Line: 2087

			/* begin block 1.2.3 */
				// Start line: 2096
				// Start offset: 0x80021318
				// Variables:
					short _x1; // $v0
					short _y1; // $v1
					short _z1; // $a0
			/* end block 1.2.3 */
			// End offset: 0x80021318
			// End Line: 2096

			/* begin block 1.2.4 */
				// Start line: 2096
				// Start offset: 0x80021318
				// Variables:
					short _x1; // $a0
					short _y1; // $v1
					short _z1; // $a1
					struct _SVector *_v0; // $v0
			/* end block 1.2.4 */
			// End offset: 0x80021318
			// End Line: 2096
		/* end block 1.2 */
		// End offset: 0x800213B8
		// End Line: 2106
	/* end block 1 */
	// End offset: 0x800213B8
	// End Line: 2108

	/* begin block 2 */
		// Start line: 4981
	/* end block 2 */
	// End Line: 4982
#endif
					UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_Instance1SpheresToInstance2(struct _Instance *instance1 /*stack 0*/, struct _Instance *instance2 /*$fp*/, long sphereToSphere /*$a2*/)
void COLLIDE_Instance1SpheresToInstance2(struct _Instance *instance1, struct _Instance *instance2, long sphereToSphere)
{ // line 2419, offset 0x800213dc
#if 0
	/* begin block 1 */
		// Start line: 2420
		// Start offset: 0x800213DC
		// Variables:
			MATRIX *wsTransform2; // stack offset -132
			MATRIX *oldWSTransform2; // stack offset -128
			_Position *spherePos; // stack offset -124
			struct _Vector *line; // $s7
			struct _Vector *offset; // stack offset -120
			struct _Vector *tempVec; // stack offset -116
			struct _Vector *sSpherePos1; // stack offset -112
			struct _Vector *oldSSpherePos1; // stack offset -108
			struct _SVector *svec; // stack offset -104
			struct _Sphere *sSphere1; // $s3
			struct _Sphere *oldSSphere1; // stack offset -100
			struct _Sphere *wSphere1; // stack offset -96
			struct _Sphere *wSphere2; // stack offset -92
			struct _Sphere *oldWSphere1; // stack offset -88
			struct _Sphere *oldWSphere2; // stack offset -84
			struct _CollideInfo *collideInfo; // $s2
			struct _HFaceInfo *hfaceInfo; // stack offset -80
			MATRIX *swTransform1; // stack offset -76
			MATRIX *swTransform2; // stack offset -72
			MATRIX *oldSWTransform1; // $s0
			MATRIX *oldSWTransform2; // $s4
			struct _HSphere *hsphere1; // $s6
			struct _HSphere *hsphere2; // $s0
			struct _HFace *hface; // $s0
			void (*collideFunc)(); // $a3
			long flag; // stack offset -152
			long edge; // stack offset -136
			struct _HModel *hmodel1; // $a0
			struct _HModel *hmodel2; // stack offset -68
			struct _HPrim *hprim1; // stack offset -64
			struct _HPrim *hprim2; // stack offset -60
			int i; // stack offset -56

		/* begin block 1.1 */
			// Start line: 2478
			// Start offset: 0x80021578
			// Variables:
				int i; // stack offset -52

			/* begin block 1.1.1 */
				// Start line: 2524
				// Start offset: 0x800217F0
				// Variables:
					long len; // $a3

				/* begin block 1.1.1.1 */
					// Start line: 2525
					// Start offset: 0x800217F0
					// Variables:
						long a; // stack offset -148
						long b; // stack offset -144
						long c; // stack offset -140
				/* end block 1.1.1.1 */
				// End offset: 0x800217F0
				// End Line: 2525

				/* begin block 1.1.1.2 */
					// Start line: 2531
					// Start offset: 0x80021888
					// Variables:
						short _x1; // $v1
						short _y1; // $a0
						short _z1; // $v0
						_Position *_v1; // $v0
				/* end block 1.1.1.2 */
				// End offset: 0x80021888
				// End Line: 2531

				/* begin block 1.1.1.3 */
					// Start line: 2536
					// Start offset: 0x800218B0
					// Variables:
						short _x1; // $v0
						short _y1; // $v1
						short _z1; // $a0
				/* end block 1.1.1.3 */
				// End offset: 0x800218B0
				// End Line: 2536
			/* end block 1.1.1 */
			// End offset: 0x800219E4
			// End Line: 2561

			/* begin block 1.1.2 */
				// Start line: 2577
				// Start offset: 0x80021A58
				// Variables:
					struct _Model *model2; // $s1

				/* begin block 1.1.2.1 */
					// Start line: 2676
					// Start offset: 0x80021E58
					// Variables:
						struct _HBox *hbox; // $s4
				/* end block 1.1.2.1 */
				// End offset: 0x800220B4
				// End Line: 2742
			/* end block 1.1.2 */
			// End offset: 0x800220B4
			// End Line: 2743
		/* end block 1.1 */
		// End offset: 0x800220D4
		// End Line: 2746
	/* end block 1 */
	// End offset: 0x800220FC
	// End Line: 2748

	/* begin block 2 */
		// Start line: 4838
	/* end block 2 */
	// End Line: 4839
#endif
						UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_Instances(struct _Instance *instance1 /*$s1*/, struct _Instance *instance2 /*$s0*/)
void COLLIDE_Instances(struct _Instance *instance1, struct _Instance *instance2)
{ // line 2761, offset 0x8002212c
	/* begin block 1 */
		// Start line: 2762
		// Start offset: 0x8002212C
		// Variables:
			long lx; // $a1
			long ly; // $a3
			long lz; // $a2
			long mrmr; // $v0

		/* begin block 1.1 */
			// Start line: 2806
			// Start offset: 0x80022158
			// Variables:
				long x; // $a1
				long y; // $a3
				long z; // $a2
		/* end block 1.1 */
		// End offset: 0x80022158
		// End Line: 2806
	/* end block 1 */
	// End offset: 0x80022260
	// End Line: 2828

	/* begin block 2 */
		// Start line: 7060
	/* end block 2 */
	// End Line: 7061
				UNIMPLEMENTED();
}

void COLLIDE_InstanceList(struct _InstanceList* instanceList)
{
	struct _Instance* instance; // $s1
	struct _Instance* instance2; // $s0
	struct _Instance* playerInstance; // $s2
	long i; // $s4
	long j; // $s2

}


// autogenerated function stub: 
// long /*$ra*/ COLLIDE_SphereAndHFace(struct _Sphere *sphere /*$s2*/, _Position *oldPos /*$a1*/, struct _HFaceInfo *hfaceInfo /*$s4*/, struct _SVector *intersect /*$s5*/, long *edge /*stack 16*/)
long COLLIDE_SphereAndHFace(struct _Sphere *sphere, _Position *oldPos, struct _HFaceInfo *hfaceInfo, struct _SVector *intersect, long *edge)
{ // line 3061, offset 0x8002251c
#if 0
	/* begin block 1 */
		// Start line: 3062
		// Start offset: 0x8002251C
		// Variables:
			struct SandHFScratch *CSpad; // $s0
			struct _SVector *vertex0; // $a0
			long result; // $s6
			long behind; // $v0
			unsigned long d0sq; // $s1

		/* begin block 1.1 */
			// Start line: 3126
			// Start offset: 0x80022734
			// Variables:
				struct _Vector dv; // stack offset -64

			/* begin block 1.1.1 */
				// Start line: 3128
				// Start offset: 0x80022734
				// Variables:
					short _x1; // $v0
					short _y1; // $v1
					short _z1; // $a0
					struct _SVector *_v0; // $v0
			/* end block 1.1.1 */
			// End offset: 0x80022734
			// End Line: 3128
		/* end block 1.1 */
		// End offset: 0x80022814
		// End Line: 3141

		/* begin block 1.2 */
			// Start line: 3143
			// Start offset: 0x80022814
			// Variables:
				long y; // $v1
				long z; // $v0
		/* end block 1.2 */
		// End offset: 0x80022814
		// End Line: 3143

		/* begin block 1.3 */
			// Start line: 3147
			// Start offset: 0x80022884
			// Variables:
				unsigned long d1sq; // $a0

			/* begin block 1.3.1 */
				// Start line: 3149
				// Start offset: 0x80022884
				// Variables:
					long y; // $v1
					long z; // $v0
			/* end block 1.3.1 */
			// End offset: 0x80022884
			// End Line: 3149

			/* begin block 1.3.2 */
				// Start line: 3161
				// Start offset: 0x80022928
				// Variables:
					long y; // $v1
					long z; // $v0
			/* end block 1.3.2 */
			// End offset: 0x80022928
			// End Line: 3161
		/* end block 1.3 */
		// End offset: 0x800229B8
		// End Line: 3170

		/* begin block 1.4 */
			// Start line: 3174
			// Start offset: 0x800229CC
			// Variables:
				long len; // $a2
				struct _Vector dv; // stack offset -64

			/* begin block 1.4.1 */
				// Start line: 3176
				// Start offset: 0x800229CC
				// Variables:
					long _x0; // $a3
					long _y0; // $t0
					long _z0; // $t1
					long _x1; // $v1
					long _y1; // $v0
					long _z1; // $v1
					struct _Vector *_v; // $v0
					struct _SVector *_v1; // $t2
			/* end block 1.4.1 */
			// End offset: 0x800229CC
			// End Line: 3176

			/* begin block 1.4.2 */
				// Start line: 3176
				// Start offset: 0x800229CC
				// Variables:
					long a; // stack offset -48
					long b; // stack offset -44
					long c; // stack offset -40
			/* end block 1.4.2 */
			// End offset: 0x800229CC
			// End Line: 3176
		/* end block 1.4 */
		// End offset: 0x80022BCC
		// End Line: 3198
	/* end block 1 */
	// End offset: 0x80022BD0
	// End Line: 3201

	/* begin block 2 */
		// Start line: 6122
	/* end block 2 */
	// End Line: 6123
#endif
					UNIMPLEMENTED();
	return 0;
}

long COLLIDE_SAndT(struct SCollideInfo* scollideInfo, struct Level* level)//Matching - 60.33%
{
	struct _Terrain* terrain; // $s5
	void** stack; // $s1
	int v4; // $t6
	int radiusSquared; // $t7
	SVECTOR* oldPos; // $v0
	short vx; // $v1
	short vy; // $a0
	int v9; // $v1
	short v10; // $v0
	int y; // $v0
	int z; // $v1
	int result; // $v0
	int v14; // $a0
	int numBSPTrees; // $v0
	struct BSPTree* bsp; // $s4
	short flags; // $v1
	int v18; // $v0
	int v19; // dc
	int v20; // $v0
	short v21; // $v1
	short v22; // $a0
	short v23; // $v1
	short v24; // $a0
	short v25; // $v1
	short v26; // $a0
	struct _BSPNode* bspNode; // $a1
	int v29; // $t1
	struct _TFace* v32; // $s3
	short* v33; // $s2
	int v34; // $a0
	int v35; // $v1
	short* v36; // $v1
	short v37; // $v0
	int v38; // $v0
	short* v39; // $v1
	short v40; // $v0
	struct _TVertex* v41; // $a3
	char v45; // $v0
	char segment; // $a2
	int v47; // $v0
	int front_spectral_error; // $v0
	int back_spectral_error; // $a3
	void* v53; // $v0
	void* front; // $v0
	void* v55; // $v0
	void* back; // $v0
	short v57; // $v1
	short v58; // $a0
	short v59; // $v1
	short v60; // $a0
	short v61; // $a2
	short v62; // $a3
	short v63; // $a1
	short v64; // $v1
	struct _Sphere* sphere; // $v0
	long a; // [sp+18h] [-10h] BYREF
	long b; // [sp+1Ch] [-Ch] BYREF
	long c; // [sp+20h] [-8h] BYREF
	int v69; // [sp+24h] [-4h]
	struct SandTScratch* CSpad;

	CSpad = (struct SandTScratch*)getScratchAddr(114);
	terrain = level->terrain;
	stack = (void**)getScratchAddr(167);
	if (gameTrackerX.gameData.asmData.MorphTime != 1000)
		CSpad->in_spectral = 2;
	else
		CSpad->in_spectral = gameTrackerX.gameData.asmData.MorphTime == 1;
	CSpad->normalList = (struct _HNormal*)terrain->normalList;
	CSpad->vertexList = terrain->vertexList;
	CSpad->collideFunc = scollideInfo->collideFunc;
	CSpad->instance = scollideInfo->instance;
	CSpad->prim = scollideInfo->prim;
	radiusSquared = scollideInfo->sphere->radiusSquared;
	*(unsigned int*)&CSpad->sphere.position.x = *(unsigned int*)&scollideInfo->sphere->position.x;
	*(unsigned int*)&CSpad->sphere.position.z = *(unsigned int*)&scollideInfo->sphere->position.z;
	CSpad->sphere.radiusSquared = radiusSquared;
	CSpad->result = 0;
	CSpad->collide_ignoreAttr = 0u;
	CSpad->collide_acceptAttr = 0u;
	oldPos = scollideInfo->oldPos;
	vx = oldPos->vx;
	vy = oldPos->vy;
	CSpad->oldPos.x = vx;
	CSpad->oldPos.y = vy;
	CSpad->oldPos.z = (short)oldPos->vz;
	CSpad->spherePos.x = CSpad->sphere.position.x;
	CSpad->spherePos.y = CSpad->sphere.position.y;
	CSpad->spherePos.z = CSpad->sphere.position.z;
	CSpad->midPoint.x = CSpad->sphere.position.x - vx;
	CSpad->midPoint.y = CSpad->sphere.position.y - vy;
	v9 = (short)(CSpad->sphere.position.x - vx);
	v10 = scollideInfo->sphere->position.z - (short)oldPos->vx;
	if (v9 < 0)
		v9 = -v9;
	CSpad->midPoint.z = v10;
	a = v9;
	y = CSpad->midPoint.y;
	z = CSpad->midPoint.z;
	if (CSpad->midPoint.y < 0)
		y = -CSpad->midPoint.y;
	if (CSpad->midPoint.z < 0)
		z = -CSpad->midPoint.z;
	b = y;
	c = z;
	MATH3D_Sort3VectorCoords(&a, & b, & c);
	CSpad->midRadius = 30 * c + 12 * b + 9 * a;
	result = 0;
	if (CSpad->midRadius)
	{
		CSpad->midPoint.x = (CSpad->spherePos.x + CSpad->oldPos.x) >> 1;
		CSpad->midPoint.y = (CSpad->spherePos.y + CSpad->oldPos.y) >> 1;
		CSpad->midPoint.z = (CSpad->spherePos.z + CSpad->oldPos.z) >> 1;
		v14 = CSpad->midRadius / 2 + (unsigned short)CSpad->sphere.radius;
		CSpad->midRadius = v14;
		if (CSpad->in_spectral == 2)
			CSpad->midRadius = v14 + 2048;
		numBSPTrees = terrain->numBSPTrees;
		v69 = 0;
		if (numBSPTrees > 0)
		{
			do
			{
				bsp = &terrain->BSPTreeArray[v69];
				if (bsp->ID >= 0)
				{
					flags = bsp->flags;
					v18 = flags & 0x2000;
					if ((flags & 0x4000) == 0 || (v18 = flags & 0x2000, gameTrackerX.raziel_collide_override))
					{
						v19 = v18 == 0;
						v20 = flags & 0x102;
						if (v19 || (v20 = flags & 0x102, gameTrackerX.monster_collide_override))
						{
							if (!v20 || (flags & 0xE0) != 0 && (INSTANCE_Query(CSpad->instance, 1) & 2) != 0)
							{
								CSpad->collideInfo.bspID = bsp->ID;
								v21 = CSpad->oldPos.y - bsp->globalOffset.y;
								v22 = CSpad->oldPos.z - bsp->globalOffset.z;
								CSpad->oldPos.x -= bsp->globalOffset.x;
								CSpad->oldPos.y = v21;
								CSpad->oldPos.z = v22;
								v23 = CSpad->midPoint.y - bsp->globalOffset.y;
								v24 = CSpad->midPoint.z - bsp->globalOffset.z;
								CSpad->midPoint.x -= bsp->globalOffset.x;
								CSpad->midPoint.y = v23;
								CSpad->midPoint.z = v24;
								v25 = CSpad->sphere.position.y - bsp->globalOffset.y;
								v26 = CSpad->sphere.position.z - bsp->globalOffset.z;
								CSpad->sphere.position.x -= bsp->globalOffset.x;
								CSpad->sphere.position.y = v25;
								CSpad->sphere.position.z = v26;
								CSpad->posMatrix.m[0][0] = CSpad->sphere.position.x;
								CSpad->posMatrix.m[0][1] = v25;
								CSpad->posMatrix.m[0][2] = v26;
								CSpad->posMatrix.m[1][0] = CSpad->oldPos.x;
								CSpad->posMatrix.m[1][1] = CSpad->oldPos.y;
								CSpad->posMatrix.m[1][2] = CSpad->oldPos.z;
								*stack = stack;
								SetRotMatrix(&CSpad->posMatrix);
								v19 = bsp->bspRoot == (struct _BSPNode*)++stack;
								*stack = bsp->bspRoot;
								if (!v19)
								{
									while (1)
									{
										bspNode = (struct _BSPNode*)*stack;
										if (!(*((short*)*stack-- + 7) & 2))
											break;
										v29 = 0;
										if (CSpad->midPoint.x - CSpad->midRadius < *(int*)&bspNode->front
											&& *(int*)&bspNode->d < CSpad->midPoint.x + CSpad->midRadius
											&& CSpad->midPoint.y - CSpad->midRadius < *(int*)&bspNode->back
											&& *(int*)&bspNode->d < CSpad->midPoint.y + CSpad->midRadius
											&& CSpad->midPoint.z - CSpad->midRadius < *(int*)&bspNode->back)
										{
											v29 = *(int*)&bspNode->front < CSpad->midPoint.z + CSpad->midRadius;
										}
										if (v29)
										{
											*(unsigned int*)&CSpad->posMatrix.m[0][0] = *(unsigned int*)&CSpad->sphere.position.x;
											CSpad->posMatrix.m[0][2] = CSpad->sphere.position.z;

											gte_ldv0(&CSpad->sphere.position);
											CSpad->i = bspNode->c;
											v32 = (struct _TFace*)&bspNode->a;
											v33 = (short*)&v32->face.v2;
											if ((unsigned short)CSpad->i << 16)
											{
												do
												{
													v34 = *((unsigned char*)v33 + 2);
													if (((v34 & CSpad->collide_ignoreAttr) == 0 || (v34 & CSpad->collide_acceptAttr) != 0)
														&& ((unsigned short)v33[3] == 0xFFFF
															|| (*(short*)((char*)&terrain->StartTextureList->attr + (unsigned short)v33[3]) & 0x2000) == 0)
														&& (v34 & 8) == 0)
													{
														if (CSpad->in_spectral != 2
															|| (unsigned short)v33[2] == *(short*)(2
																* ((-1431655765
																	* ((char*)v32 - (char*)terrain->faceList)) >> 2)
																+ *(unsigned int*)terrain->morphNormalIdx))
														{
															v35 = v33[2];
															if (v35 < 0)
															{
																v39 = &CSpad->normalList->x - 3 * v35;
																v40 = *v39++;
																CSpad->normal.x = -(v40 & 0x1FFF);
																CSpad->normal.y = -*v39;
																v38 = -(unsigned short)v39[1];
															}
															else
															{
																v36 = &CSpad->normalList->x + 3 * v35;
																v37 = *v36++;
																CSpad->normal.x = v37 & 0x1FFF;
																CSpad->normal.y = *v36;
																v38 = v36[1];
															}
															CSpad->normal.z = v38;
														}
														else
														{
															COLLIDE_MakeNormal(terrain, v32, (struct _SVector*)&CSpad->normal);
														}
														v41 = &CSpad->vertexList[v32->face.v0];

														gte_ldv2_ext(&CSpad->vertexList[v32->face.v0]);
														gte_ldv0(&CSpad->normal);
														gte_rtv0();
														gte_stlvnl(&CSpad->normal);

														if (CSpad->dpv.y >= CSpad->dpv.x
															&& CSpad->dpv.x - CSpad->dpv.z < (unsigned short)CSpad->sphere.radius
															&& CSpad->dpv.y - CSpad->dpv.z >= -(unsigned short)CSpad->sphere.radius)
														{
															CSpad->hfaceInfo.hface = (struct _HFace*)v32;
															CSpad->hfaceInfo.vertex0 = (struct _HVertex*)v41;
															CSpad->hfaceInfo.vertex1 = (struct _HVertex*)&CSpad->vertexList[*(v33 - 1)];
															CSpad->hfaceInfo.vertex2 = (struct _HVertex*)&CSpad->vertexList[*v33];
															*(unsigned int*)&CSpad->hfaceInfo.normal.x = *(unsigned int*)&CSpad->normal.x;
															*(unsigned int*)&CSpad->hfaceInfo.normal.z = *(unsigned int*)&CSpad->normal.z;
															if (COLLIDE_SphereAndHFace(
																&CSpad->sphere,
																(struct _Position*)&CSpad->oldPos,
																&CSpad->hfaceInfo,
																(struct _SVector*)&CSpad->collideInfo.point1,
																&CSpad->edge))
															{
																CSpad->collideInfo.flags = 0;
																if (CSpad->edge)
																	v45 = 4;
																else
																	v45 = 8;
																CSpad->collideInfo.flags = v45;
																CSpad->collideInfo.type0 = 1;
																CSpad->collideInfo.type1 = 3;
																CSpad->collideInfo.inst1 = bsp;
																CSpad->collideInfo.level = level;
																CSpad->collideInfo.inst0 = (void*)CSpad->instance->node.prev;
																segment = scollideInfo->segment;
																CSpad->collideInfo.prim0 = CSpad->prim;
																CSpad->collideInfo.offset.y = CSpad->sphere.position.y - CSpad->posMatrix.m[0][1];
																CSpad->collideInfo.offset.x = CSpad->sphere.position.x - CSpad->posMatrix.m[0][0];
																//CSpad->collideInfo.prim1 = 32;
																CSpad->collideInfo.segment = segment;
																CSpad->collideInfo.offset.z = CSpad->sphere.position.z - CSpad->posMatrix.m[0][2];
																if (CSpad->instance)
																{
																	CSpad->instance->collideInfo = &CSpad->collideInfo;
																	//if ( CSpad->collideFunc )
																	  //((void (__fastcall *)(_Instance *, struct GameTracker *))CSpad->collideFunc)(
																	  //  CSpad->instance,
																	  //  &gameTrackerX);
																}
																CSpad->result = 1;
																*(unsigned int*)&CSpad->posMatrix.m[0][0] = *(unsigned int*)&CSpad->sphere.position.x;
																CSpad->posMatrix.m[0][2] = CSpad->sphere.position.z;
															}
															SetRotMatrix(&CSpad->posMatrix);
														}
													}
													v33 += 6;
													v47 = (unsigned short)CSpad->i-- - 1;
													++v32;
												} while (v47 << 16);
											}
											*(unsigned int*)&CSpad->posMatrix.m[0][0] = *(unsigned int*)&CSpad->sphere.position.x;
											CSpad->posMatrix.m[0][2] = CSpad->sphere.position.z;

											gte_ldv0(&CSpad->sphere.position);
										}
									LABEL_78:
										if (*stack == stack)
											goto LABEL_79;
									}

									gte_ldv0(&bspNode->a);

									gte_rtv0();
									gte_stlvnl(&bspNode->a);
									CSpad->dpv.x -= bspNode->d;
									CSpad->dpv.y -= bspNode->d;
									if (CSpad->in_spectral)
									{
										front_spectral_error = bspNode->front_spectral_error;
										back_spectral_error = bspNode->back_spectral_error;
									}
									else
									{
										front_spectral_error = bspNode->front_material_error;
										back_spectral_error = bspNode->back_material_error;
									}
									if (CSpad->dpv.y >= (unsigned short)CSpad->sphere.radius + front_spectral_error)
									{
										if ((unsigned short)CSpad->sphere.radius + front_spectral_error < CSpad->dpv.x)
											goto LABEL_75;
										goto LABEL_73;
									}
									if (back_spectral_error - (unsigned short)CSpad->sphere.radius < CSpad->dpv.y)
									{
										if (CSpad->dpv.x < CSpad->dpv.y)
										{
										LABEL_73:
											back = (void*)bspNode->back;
											if (back)
												*++stack = back;
										LABEL_75:
											front = (void*)bspNode->front;
										}
										else
										{
											v55 = (void*)bspNode->front;
											if (v55)
												*++stack = v55;
											front = (void*)bspNode->back;
										}
									}
									else
									{
										if (CSpad->dpv.x >= back_spectral_error - (unsigned short)CSpad->sphere.radius)
										{
											v53 = (void*)bspNode->front;
											if (v53)
												*++stack = v53;
										}
										front = (void*)bspNode->back;
									}
									if (front)
										*++stack = front;
									goto LABEL_78;
								}
							LABEL_79:
								v57 = CSpad->oldPos.y + bsp->globalOffset.y;
								v58 = CSpad->oldPos.z + bsp->globalOffset.z;
								CSpad->oldPos.x += bsp->globalOffset.x;
								CSpad->oldPos.y = v57;
								CSpad->oldPos.z = v58;
								v59 = CSpad->midPoint.y + bsp->globalOffset.y;
								v60 = CSpad->midPoint.z + bsp->globalOffset.z;
								CSpad->midPoint.x += bsp->globalOffset.x;
								CSpad->midPoint.y = v59;
								CSpad->midPoint.z = v60;
								v61 = bsp->globalOffset.y;
								v62 = bsp->globalOffset.z;
								CSpad->sphere.position.x += bsp->globalOffset.x;
								CSpad->sphere.position.y += v61;
								CSpad->sphere.position.z += v62;
							}
						}
					}
				}
				v19 = ++v69 < terrain->numBSPTrees;
			} while (v19);
		}
		v63 = CSpad->sphere.position.y;
		v64 = CSpad->sphere.position.z;
		sphere = scollideInfo->sphere;
		sphere->position.x = CSpad->sphere.position.x;
		sphere->position.y = v63;
		sphere->position.z = v64;
		return CSpad->result;
	}
	return result;
}

long COLLIDE_SphereAndTerrain(struct SCollideInfo* scollideInfo, struct Level* level)
{
	int result;
	int d;
	int in_warpRoom;
	struct _StreamUnit* stream;

	result = COLLIDE_SAndT(scollideInfo, level);

	in_warpRoom = 0;
	
	stream = STREAM_GetStreamUnitWithID(level->streamUnitID);

	if (stream != NULL)
	{
		in_warpRoom = stream->flags & 0x1;
	}

	for (d = 0; d < 16; d++)
	{
		if ((StreamTracker.StreamList[d].used == 2) && (StreamTracker.StreamList[d].level != level) && ((in_warpRoom == 0) || !(StreamTracker.StreamList[d].flags & 0x1)) && (MEMPACK_MemoryValidFunc((char*)StreamTracker.StreamList[d].level) != 0))
		{
			result = COLLIDE_SAndT(scollideInfo, StreamTracker.StreamList[d].level);
		}
	}

	return result;
}

void COLLIDE_InstanceTerrain(struct _Instance* instance, struct Level* level)
{
	struct _Vector* newPosVec;
	struct _Vector* oldPosVec;
	struct _SVector* oldPos;
	struct SCollideInfo scollideInfoX;
	struct SCollideInfo* scollideInfo;
	struct _Sphere* wSphere;
	MATRIX* swTransform;
	MATRIX* oldSWTransform;
	void (*collideFunc)(struct _Instance* instance, struct GameTracker* gameTracker); // stack offset -52
	struct _HSphere* hsphere;
	long flags;
	int i;
	struct _HModel* hmodel;
	struct _HPrim* hprim;

	newPosVec = (struct _Vector*)getScratchAddr(82);
	oldPos = (struct _SVector*)getScratchAddr(90);
	wSphere = (struct _Sphere*)getScratchAddr(110);
	oldPosVec = (struct _Vector*)getScratchAddr(86);

	scollideInfo = &scollideInfoX;

	if (instance->matrix != NULL && instance->oldMatrix != NULL)
	{
		if((instance->object->oflags2 & 0x80000))
		{
			gameTrackerX.monster_collide_override = 1;
		}

		collideFunc = instance->collideFunc;

		if (collideFunc != NULL)
		{
			hmodel = &instance->hModelList[instance->currentModel];

			i = hmodel->numHPrims;
			hprim = hmodel->hPrimList;

			while (i-- != 0)
			{
				if ((hprim->hpFlags & 0x1) && (hprim->withFlags & 0x2) && hprim->type == 1)
				{
					swTransform = &instance->matrix[hprim->segment];
				
					oldSWTransform = &instance->oldMatrix[hprim->segment];

					SetRotMatrix(swTransform);

					SetTransMatrix(swTransform);

					RotTrans((SVECTOR*)&hprim->data.hsphere->position, (VECTOR*)newPosVec, &flags);
				
					SetRotMatrix(oldSWTransform);

					SetTransMatrix(oldSWTransform);

					RotTrans((SVECTOR*)&hprim->data.hsphere->position, (VECTOR*)oldPosVec, &flags);
				
					wSphere->position.x = newPosVec->x;
					wSphere->position.y = newPosVec->y;
					wSphere->position.z = newPosVec->z;

					wSphere->radius = hprim->data.hsphere->radius;

					oldPos->x = oldPosVec->x;
					oldPos->y = oldPosVec->y;
					oldPos->z = oldPosVec->z;

					wSphere->radiusSquared = hprim->data.hsphere->radiusSquared;

					scollideInfo->sphere = wSphere;
					
					scollideInfo->oldPos = (SVECTOR*)oldPos;

					scollideInfo->collideFunc = collideFunc;

					scollideInfo->instance = instance;

					scollideInfo->segment = hprim->segment;

					scollideInfo->prim = (void*)hprim;

					scollideInfo->id = hprim->data.hsphere->id;

					COLLIDE_SphereAndTerrain(scollideInfo, level);
				}
				
				hprim++;
			}
		}

		gameTrackerX.monster_collide_override = 0;
	}
}

long COLLIDE_LineWithSignals(struct _SVector* startPoint, struct _SVector* endPoint, struct _MultiSignal** signalList, long maxSignals, struct Level* level)
{
	struct IandTScratch* CSpad;
	struct _Terrain* terrain; // $s4
	void** stack; // $s2
	int v8; // $t3
	int numSignalsCollidedWith; // $fp
	int result; // $v0
	struct _Vector* p_dpv; // $t1
	int v12; // $s5
	struct _BSPNode* bspNode; // $a1
	int front_high; // $v1
	int d_low; // $v1
	int back_low; // $v1
	int d_high; // $v1
	int back_high; // $v1
	int front_low; // $v1
	struct _TFace* tface; // $s3
	unsigned short* p_textoff; // $s1
	int v27; // $v1
	short* v28; // $v1
	short v29; // $v0
	int v30; // $v0
	short* v31; // $v1
	short v32; // $v0
	int v33; // $a0
	int v37; // $v1
	int y; // $v0
	int v39; // $a1
	int v40; // $v0
	int v41; // $v0
	int front_spectral_error; // $v1
	int back_spectral_error; // $a0
	void* back; // $v0
	void* front; // $v0
	short _x1; // $a0 MAPDST
	short _y1; // $a0 MAPDST
	short _z1; // $a1 MAPDST
	int v52; // [sp+18h] [-10h]
	struct _Vector* v53; // [sp+20h] [-8h]
	struct _Vector* v54; // [sp+20h] [-8h]

	CSpad = (struct IandTScratch*)getScratchAddr(16);

	terrain = level->terrain;

	stack = (void**)getScratchAddr(41);

	CSpad->normalList = (short*)terrain->normalList;
	CSpad->vertexList = terrain->vertexList;

	CSpad->oldPos.x = startPoint->x;
	CSpad->oldPos.z = startPoint->z;

	CSpad->newPos.x = endPoint->x;
	CSpad->newPos.z = endPoint->z;

	numSignalsCollidedWith = 0;

	if (gameTrackerX.gameData.asmData.MorphTime == 1000)
	{
		CSpad->in_spectral = gameTrackerX.gameData.asmData.MorphType == 1;
	}
	else
	{
		CSpad->in_spectral = 2;
	}

	CSpad->line.x = CSpad->oldPos.x - CSpad->newPos.x;
	CSpad->line.y = CSpad->oldPos.y - CSpad->newPos.y;
	CSpad->line.z = CSpad->oldPos.z - CSpad->newPos.z;

	result = 0;

	if (CSpad->line.x || CSpad->line.y || CSpad->line.z)
	{
		v52 = 0;
		if (terrain->numBSPTrees > 0)
		{
			p_dpv = &CSpad->dpv;
			v12 = 0;
			do
			{
				if (terrain->BSPTreeArray[v12].ID == -1)
				{
					*stack = stack;

					_x1 = terrain->BSPTreeArray[v12].globalOffset.x;
					_y1 = terrain->BSPTreeArray[v12].globalOffset.y;
					_z1 = terrain->BSPTreeArray[v12].globalOffset.z;

					CSpad->newPos.x -= _x1;
					CSpad->newPos.y -= _y1;
					CSpad->newPos.z -= _z1;

					_x1 = terrain->BSPTreeArray[v12].globalOffset.x;
					_y1 = terrain->BSPTreeArray[v12].globalOffset.y;
					_z1 = terrain->BSPTreeArray[v12].globalOffset.z;

					CSpad->oldPos.x -= _x1;
					CSpad->oldPos.y -= _y1;
					CSpad->oldPos.z -= _z1;

					// *++stack = *(void **)(terrain->BSPTreeArray[v12]);

					CSpad->posMatrix.m[0][0] = CSpad->newPos.x;
					CSpad->posMatrix.m[1][1] = CSpad->newPos.y;
					CSpad->posMatrix.m[0][2] = CSpad->newPos.z;
					CSpad->posMatrix.m[1][0] = CSpad->oldPos.x;
					CSpad->posMatrix.m[1][1] = CSpad->oldPos.y;
					CSpad->posMatrix.m[1][2] = CSpad->oldPos.z;

					v53 = p_dpv;
					SetRotMatrix(&CSpad->posMatrix);
					p_dpv = v53;
					while (*stack != stack)
					{
						bspNode = (struct _BSPNode*)*stack;
						if (*((short*)*stack-- + 7) & 2)
						{
							front_high = ((unsigned short*)bspNode->front)[0];
							if (front_high >= CSpad->newPos.x || front_high >= CSpad->oldPos.x)
							{
								d_low = ((unsigned short*)bspNode->d)[1];
								if (CSpad->newPos.x >= d_low || CSpad->oldPos.x >= d_low)
								{
									back_low = ((unsigned short*)bspNode->back)[1];
									if (back_low >= CSpad->newPos.y || back_low >= CSpad->oldPos.y)
									{
										d_high = ((unsigned short*)bspNode->d)[0];
										if (CSpad->newPos.y >= d_high || CSpad->oldPos.y >= d_high)
										{
											back_high = ((unsigned short*)bspNode->back)[0];
											if (back_high >= CSpad->newPos.z || back_high >= CSpad->oldPos.z)
											{
												front_low = ((unsigned short*)bspNode->front)[1];
												if (CSpad->newPos.z >= front_low || CSpad->oldPos.z >= front_low)
												{
													CSpad->i = bspNode->c;
													tface = *(struct _TFace**)&bspNode->a;
													p_textoff = &tface->textoff;
													if (CSpad->i)
													{
														do
														{
															if ((*(p_textoff - 2) & 0xC0) != 0 && (unsigned short)*p_textoff != 0xFFFF)
															{
																v27 = *(p_textoff - 1);
																if (v27 < 0)
																{
																	v31 = (short*)(*(unsigned int*)CSpad->normalList - 6 * v27);
																	v32 = *v31++;
																	CSpad->normal.x = -(v32 & 0x1FFF);
																	CSpad->normal.y = -*v31;
																	v30 = -(unsigned short)v31[1];
																}
																else
																{
																	v28 = (short*)(*(unsigned int*)CSpad->normalList + 6 * v27);
																	v29 = *v28++;
																	CSpad->normal.x = v29 & 0x1FFF;
																	CSpad->normal.y = *v28;
																	//LOWORD(v30) = v28[1];
																}
																CSpad->normal.z = v30;
																//                              v33 = dword_1F8000A0 + 12 * *(unsigned short *)tface->face.gap0;

																gte_ldv0(&bspNode->a);
																gte_rtv0();
																//gte_stlvnl();

																CSpad->dpv.x -= CSpad->dpv.z;
																v37 = CSpad->dpv.y - CSpad->dpv.z;
																CSpad->dpv.y -= CSpad->dpv.z;
																if (CSpad->dpv.x < 0 && v37 >= 0)
																{
																	y = p_dpv->y;
																	if (CSpad->dpv.x == y)
																		v39 = 0;
																	else
																		v39 = (y << 12) / (CSpad->dpv.x - y);
																	CSpad->planePoint.x = CSpad->oldPos.x + ((CSpad->line.x * v39) >> 12);
																	CSpad->planePoint.y = CSpad->oldPos.y + ((CSpad->line.y * v39) >> 12);
																	CSpad->planePoint.z = CSpad->oldPos.z + ((CSpad->line.z * v39) >> 12);
																	v54 = p_dpv;
																	v40 = COLLIDE_PointInTriangle(
																		(struct _SVector*)v33,
																		(struct _SVector*)(CSpad->normalList + 12 * (unsigned short)*(p_textoff - 4)),
																		(struct _SVector*)(CSpad->normalList + 12 * (unsigned short)*(p_textoff - 3)),
																		&CSpad->planePoint,
																		&CSpad->normal);
																	p_dpv = v54;
																	if (v40)
																	{
																		v41 = numSignalsCollidedWith;
																		if (numSignalsCollidedWith < maxSignals)
																		{
																			++numSignalsCollidedWith;
																			signalList[v41] = (struct _MultiSignal*)(*(unsigned int*)&terrain[1].UnitChangeFlags
																				+ (unsigned short)*p_textoff);
																		}
																	}
																}
															}
															p_textoff += 6;
															++tface;
														} while (CSpad->i-- != 1);
													}
												}
											}
										}
									}
								}
							}
						}
						else
						{

							gte_ldv0(&bspNode->a);
							gte_rtv0();
							//gte_stlvnl();
							CSpad->dpv.x -= bspNode->d;
							CSpad->dpv.y -= bspNode->d;

							if (CSpad->in_spectral)
							{
								front_spectral_error = bspNode->front_spectral_error;
								back_spectral_error = bspNode->back_spectral_error;
							}
							else
							{
								front_spectral_error = bspNode->front_material_error;
								back_spectral_error = bspNode->back_material_error;
							}
							if (CSpad->dpv.x < front_spectral_error || CSpad->dpv.y < front_spectral_error)
							{
								if (back_spectral_error < CSpad->dpv.x || back_spectral_error < CSpad->dpv.y)
								{
									front = (void*)bspNode->front;
									if (front)
										*++stack = front;
								}
								back = (void*)bspNode->back;
							}
							else
							{
								back = (void*)bspNode->front;
							}
							if (back)
								*++stack = back;
						}
					}
					_x1 = terrain->BSPTreeArray[v12].globalOffset.x;
					_y1 = terrain->BSPTreeArray[v12].globalOffset.y;
					_z1 = terrain->BSPTreeArray[v12].globalOffset.z;

					CSpad->newPos.x += _x1;
					CSpad->newPos.y += _y1;
					CSpad->newPos.z += _z1;

					_x1 = terrain->BSPTreeArray[v12].globalOffset.x;
					_y1 = terrain->BSPTreeArray[v12].globalOffset.y;
					_z1 = terrain->BSPTreeArray[v12].globalOffset.z;

					CSpad->oldPos.x += _x1;
					CSpad->oldPos.y += _y1;
					CSpad->oldPos.z += _z1;
				}
				v12 += 36;
				++v52;
			} while (v52 < terrain->numBSPTrees);
		}
		return numSignalsCollidedWith;
	}
	return result;
}

void COLLIDE_InstanceTerrainSignal(struct _Instance* instance, struct Level* level)//Matching - 98.95%
{
	struct _Model* model;
	int numSignals;
	int d;
	struct _MultiSignal* msignal;
	struct _SVector startPoint;
	struct _SVector endPoint;
	struct _MultiSignal* signalListArray[8];

	model = instance->object->modelList[instance->currentModel];

	if (instance->matrix != NULL && instance->oldMatrix != NULL)
	{
		if ((instance->object->oflags2 & 0x80000) && INSTANCE_Query(instance, 0x1) != 130)
		{
			startPoint = *(struct _SVector*)&instance->oldPos;
			startPoint.z += 100;
			endPoint = *(struct _SVector*)&instance->position;
			endPoint.z += 100;
		}
		else
		{
			if (model != NULL && model->numSegments >= 2)
			{
				startPoint.x = instance->oldMatrix[1].t[0];
				startPoint.y = instance->oldMatrix[1].t[1];
				startPoint.z = instance->oldMatrix[1].t[2];

				endPoint.x = instance->matrix[1].t[0];
				endPoint.y = instance->matrix[1].t[1];
				endPoint.z = instance->matrix[1].t[2];
			}
			else
			{
				startPoint = *(struct _SVector*)&instance->oldPos;
				endPoint = *(struct _SVector*)&instance->position;
			}
		}
		
		numSignals = COLLIDE_LineWithSignals(&startPoint, &endPoint, signalListArray, 8, level);

		for (d = 0; d < numSignals; d++)
		{
			msignal = signalListArray[d];
			if (instance == gameTrackerX.playerInstance)
			{
				msignal->flags |= 0x1;
			}

			SIGNAL_HandleSignal(instance, msignal->signalList, 0);
			EVENT_AddSignalToReset(msignal);
		}
	}
}

struct _StreamUnit* COLLIDE_CameraWithStreamSignals(struct Camera* camera)
{
	struct _SVector startPoint;
	struct _SVector endPoint;
	struct _Model* model;
	long numSignals;
	long i;
	long numStreamSignals;
	struct _MultiSignal (*signalListArray[8]);
	struct _StreamUnit (*streamSignalUnits[8]);
	struct _StreamUnit *playerStreamUnit;
	struct Level* level;
	long playerStreamUnitID;
	struct _Instance* instance;
	struct _Instance* af_instance;
	struct _MultiSignal* msignal;
	long isWarpGateSignal;
	struct _StreamUnit* cameraStreamUnit;
	long cameraStreamID;	
	int number;

	instance = camera->focusInstance;
	af_instance = gameTrackerX.playerInstance;

	playerStreamUnitID = instance->currentStreamUnitID;

	if (instance == af_instance)
	{
		if (gameTrackerX.SwitchToNewStreamUnit != 0)
		{
			playerStreamUnitID = gameTrackerX.moveRazielToStreamID;
		}
	}

	playerStreamUnit = STREAM_GetStreamUnitWithID(playerStreamUnitID);

	endPoint.x = camera->core.position.x;
	endPoint.y = camera->core.position.y;
	endPoint.z = camera->core.position.z;

	if (instance->matrix != NULL)
	{
		model = instance->object->modelList[instance->currentModel];

		if (model != NULL)
		{
			if (model->numSegments >= 2)
			{
				startPoint.x = instance->matrix[1].t[0];
				startPoint.y = instance->matrix[1].t[1];
				startPoint.z = instance->matrix[1].t[2];
			}
			else
			{
				startPoint.x = instance->position.x;
				startPoint.y = instance->position.y;
				startPoint.z = instance->position.z;
			}
		}
		else
		{
			startPoint.x = instance->position.x;
			startPoint.y = instance->position.y;
			startPoint.z = instance->position.z;
		}
	}
	else
	{
		startPoint.x = instance->position.x;
		startPoint.y = instance->position.y;
		startPoint.z = instance->position.z;
	}

	level = playerStreamUnit->level;
	numStreamSignals = 0;
	
	if (level != NULL)
	{
		numSignals = COLLIDE_LineWithSignals(&startPoint, &endPoint, signalListArray, 8, level);

		for(i = 0; i < numSignals; i++)
		{
			if (SIGNAL_IsStreamSignal(signalListArray[i]->signalList, &isWarpGateSignal) != 0)
			{
				if (isWarpGateSignal)
				{
					if (WARPGATE_IsWarpgateActive())
					{
						if (gameTrackerX.SwitchToNewWarpIndex == -1)
						{
							number = CurrentWarpNumber;
						}
						else
						{
							number = gameTrackerX.SwitchToNewWarpIndex;
						}

						cameraStreamID = WarpRoomArray[number].streamUnit->StreamUnitID;
					}
					else
					{
						cameraStreamID = 0;
					}
				}
				else
				{
					signalListArray[i]->signalList->data.StreamLevel.streamID;
				}

				if (cameraStreamID != 0)
				{
					cameraStreamUnit = STREAM_GetStreamUnitWithID(cameraStreamID);
				}
				else
				{
					cameraStreamUnit = NULL;
				}

				if (cameraStreamUnit != NULL)
				{
					streamSignalUnits[numStreamSignals++] = cameraStreamUnit;
				}
			}
		}
	}

	if (numStreamSignals == 0)
	{
		return 0;
	}
	else if (numStreamSignals != 1)
	{
		if (numStreamSignals > 0)
		{
			for (i = 0; i < numStreamSignals; i++)
			{
				if (streamSignalUnits[i]->StreamUnitID != playerStreamUnitID)
				{
					return streamSignalUnits[i];
				}
			}
		}
	}
	else
	{
		return streamSignalUnits[0];
	}

	return NULL;
}

void COLLIDE_InstanceListWithSignals(struct _InstanceList* instanceList)//Matching - 99.66%
{
	struct _Instance* instance;
	struct Level* level;

	instance = (struct _Instance*)instanceList->first;

	while (instance != NULL)
	{
		if (!(instance->flags2 & 0x24000000))
		{
			level = STREAM_GetLevelWithID(instance->currentStreamUnitID);
			
			if (level != NULL)
			{
				COLLIDE_InstanceTerrainSignal(instance, level);
			}
		}

		instance = instance->next;
	}
}

void COLLIDE_InstanceListTerrain(struct _InstanceList* instanceList)//Matching - 99.77%
{
	long i;
	struct _Instance* instance;
	struct Level* level;

	for (i = 1; i < 32; i += 2)
	{
		instance = (struct _Instance*)instanceList->group[i].next;

		while (instance != NULL)
		{
			if (instance->hModelList != NULL && !(instance->flags2 & 0x24040000))
			{
				level = STREAM_GetLevelWithID(instance->currentStreamUnitID);

				if (level != NULL)
				{
					COLLIDE_InstanceTerrain(instance, level);
				}
			}

			instance = (struct _Instance*)instance->node.next;
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ COLLIDE_SegmentCollisionOn(struct _Instance *instance /*$a0*/, int segment /*$a1*/)
void COLLIDE_SegmentCollisionOn(struct _Instance *instance, int segment)
{ // line 4947, offset 0x80024850
	/* begin block 1 */
		// Start line: 4949
		// Start offset: 0x80024850

		/* begin block 1.1 */
			// Start line: 4951
			// Start offset: 0x80024860
			// Variables:
				int i; // $a2
				struct _HModel *hmodel; // $v0
				struct _HPrim *hprim; // $v1
		/* end block 1.1 */
		// End offset: 0x800248C0
		// End Line: 4962
	/* end block 1 */
	// End offset: 0x800248C0
	// End Line: 4963

	/* begin block 2 */
		// Start line: 9894
	/* end block 2 */
	// End Line: 9895

	/* begin block 3 */
		// Start line: 12376
	/* end block 3 */
	// End Line: 12377
				UNIMPLEMENTED();
}

void COLLIDE_SegmentCollisionOff(struct _Instance* instance, int segment)
{
	int i;
	int enabled;
	struct _HModel* hmodel;
	struct _HPrim* hprim;

	if (instance->hModelList != NULL)
	{
		hmodel = &instance->hModelList[instance->currentModel];

		hprim = hmodel->hPrimList;

		enabled = 0;

		if (hmodel->numHPrims != 0)
		{
			for (i = hmodel->numHPrims; i != 0; i--)
			{
				if (hprim[i].segment == segment)
				{
					hprim[i].hpFlags &= 0xFE;
				}

				if (enabled == 0 && (hprim[i].hpFlags & 0x1))
				{
					enabled = 1;
				}
			}
		}

		if (enabled == 0)
		{
			instance->flags2 |= 0x40000;
		}
	}
}



// autogenerated function stub: 
// long /*$ra*/ COLLIDE_FindCollisionFaceNormal(struct _CollideInfo *collideInfo /*$a0*/, struct _Normal *normal /*$s2*/)
long COLLIDE_FindCollisionFaceNormal(struct _CollideInfo *collideInfo, struct _Normal *normal)
{ // line 5015, offset 0x80024964
#if 0
	/* begin block 1 */
		// Start line: 5016
		// Start offset: 0x80024964
		// Variables:
			long valid_normal; // $a2

		/* begin block 1.1 */
			// Start line: 5025
			// Start offset: 0x80024998
			// Variables:
				struct _TFace *tface; // $a1
		/* end block 1.1 */
		// End offset: 0x800249E0
		// End Line: 5029

		/* begin block 1.2 */
			// Start line: 5036
			// Start offset: 0x80024A18

			/* begin block 1.2.1 */
				// Start line: 5040
				// Start offset: 0x80024A18
				// Variables:
					SVECTOR*lNormal; // stack offset -24
					struct _Instance *inst1; // $s1
			/* end block 1.2.1 */
			// End offset: 0x80024A18
			// End Line: 5041
		/* end block 1.2 */
		// End offset: 0x80024A18
		// End Line: 5041

		/* begin block 1.3 */
			// Start line: 5054
			// Start offset: 0x80024A6C
			// Variables:
				struct _Instance *inst1; // $v0
		/* end block 1.3 */
		// End offset: 0x80024A84
		// End Line: 5058
	/* end block 1 */
	// End offset: 0x80024A84
	// End Line: 5060

	/* begin block 2 */
		// Start line: 10030
	/* end block 2 */
	// End Line: 10031
#endif
				UNIMPLEMENTED();
	return 0;
}

short* COLLIDE_GetBSPTreeFlag(struct _CollideInfo* collideInfo)
{
	struct Level* level;
	struct _Terrain* terrain;
	struct BSPTree* bspTree;

	level = (struct Level*)collideInfo->level;

	terrain = level->terrain;

	bspTree = &terrain->BSPTreeArray[collideInfo->bspID];

	return &bspTree->flags;
}

void COLLIDE_SetBSPTreeFlag(struct _CollideInfo* collideInfo, short flag)
{
	short* bspTreeFlags;

	bspTreeFlags = COLLIDE_GetBSPTreeFlag(collideInfo);

	bspTreeFlags[0] |= flag;
}


// autogenerated function stub: 
// int /*$ra*/ COLLIDE_PointAndTfaceFunc(struct _Terrain *terrain /*$fp*/, struct BSPTree *bsp /*$s6*/, struct _SVector *orgNewPos /*$s7*/, struct _SVector *orgOldPos /*$t4*/, struct _TFace *tface /*stack 16*/, long ignoreAttr /*stack 20*/, long flags /*stack 24*/)
int COLLIDE_PointAndTfaceFunc(struct _Terrain *terrain, struct BSPTree *bsp, struct _SVector *orgNewPos, struct _SVector *orgOldPos, struct _TFace *tface, long ignoreAttr, long flags)
{ // line 5121, offset 0x80024afc
#if 0
	/* begin block 1 */
		// Start line: 5122
		// Start offset: 0x80024AFC
		// Variables:
			struct PandTFScratch *CSpad; // $s0
			int result; // stack offset -48

		/* begin block 1.1 */
			// Start line: 5141
			// Start offset: 0x80024B8C
			// Variables:
				struct _SVector *vertex0; // $s3
				struct _SVector *vertex1; // $s4

			/* begin block 1.1.1 */
				// Start line: 5144
				// Start offset: 0x80024B8C
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a1
					short _x1; // $a2
					short _y1; // $t0
					short _z1; // $t2
					struct _SVector *_v; // $t1
					_Position *_v1; // $a3
			/* end block 1.1.1 */
			// End offset: 0x80024B8C
			// End Line: 5144

			/* begin block 1.1.2 */
				// Start line: 5144
				// Start offset: 0x80024B8C
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a1
					short _x1; // $a2
					short _y1; // $t0
					short _z1; // $a3
					struct _SVector *_v; // $t3
			/* end block 1.1.2 */
			// End offset: 0x80024B8C
			// End Line: 5144

			/* begin block 1.1.3 */
				// Start line: 5144
				// Start offset: 0x80024B8C
				// Variables:
					short *nrmlArray; // $a1
					struct _SVector *nrml; // $a0

				/* begin block 1.1.3.1 */
					// Start line: 5144
					// Start offset: 0x80024B8C
					// Variables:
						short *sPtr; // $v1
				/* end block 1.1.3.1 */
				// End offset: 0x80024CCC
				// End Line: 5154
			/* end block 1.1.3 */
			// End offset: 0x80024CCC
			// End Line: 5154

			/* begin block 1.1.4 */
				// Start line: 5185
				// Start offset: 0x80024DE0
				// Variables:
					short _x0; // $v0
					short _y0; // $v1
					short _z0; // $a0
					short _x1; // $a1
					short _y1; // $a3
					short _z1; // $a2
					_Position *_v1; // $a2
			/* end block 1.1.4 */
			// End offset: 0x80024DE0
			// End Line: 5185
		/* end block 1.1 */
		// End offset: 0x80024E18
		// End Line: 5189
	/* end block 1 */
	// End offset: 0x80024E1C
	// End Line: 5192

	/* begin block 2 */
		// Start line: 10242
	/* end block 2 */
	// End Line: 10243
#endif
					UNIMPLEMENTED();
	return 0;
}




