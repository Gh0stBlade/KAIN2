#include "Game/CORE.H"
#include "MONLIB.H"
#include "Game/PHYSICS.H"
#include "Game/G2/ANIMG2.H"
#include "Game/MATH3D.H"
#include "Game/PLAN/ENMYPLAN.H"
#include "Game/EVENT.H"
#include <Game/STATE.H>
#include "Game/G2/ANMG2ILF.H"

void MON_TurnOffWeaponSpheres(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	if (instance->LinkChild != NULL)
	{
		struct _Instance* weapon;

		for (weapon = instance->LinkChild; weapon != NULL; weapon = weapon->LinkSibling)
		{
			TurnOffCollisionPhysOb(weapon, 3);
		}
	}

	if (mv->mvFlags & 0x4000)
	{
		int i;
		struct _HPrim* hprim;
		struct _HModel* hmodel;

		hmodel = instance->hModelList + instance->currentModel;
		hprim = hmodel->hPrimList;
		for (i = hmodel->numHPrims; i != 0; i--, hprim++)
		{
			if ((hprim->type == 1) && (hprim->data.hsphere->id == 9))
			{
				hprim->hpFlags &= ~1;
			}
		}
		mv->mvFlags &= ~0x4000;
	}
}


void MON_TurnOnWeaponSpheres(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	int i;
	struct _HPrim* hprim;
	struct _HModel* hmodel;

	mv = (struct _MonsterVars*)instance->extraData;
	if (!(mv->mvFlags & 0x4000) && (instance->hModelList != NULL))
	{
		hmodel = instance->hModelList + instance->currentModel;
		hprim = hmodel->hPrimList;
		for (i = hmodel->numHPrims; i != 0; i--, hprim++)
		{
			if ((hprim->type == 1) && (hprim->data.hsphere->id == 9))
			{
				hprim->hpFlags |= 1;
				break;
			}
		}
		mv->mvFlags |= 0x4000;
	}
}


void MON_TurnOnWeaponSphere(struct _Instance* instance, int segment)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	if (instance->LinkChild != NULL)
	{
		struct _Instance* weapon;

		weapon = INSTANCE_GetChildLinkedToSegment(instance, segment);

		if (weapon != NULL)
		{
			TurnOnCollisionPhysOb(weapon, 3);
			mv->mvFlags |= 0x4000;
		}
	}
	else if (!(mv->mvFlags & 0x4000) && (instance->hModelList != NULL))
	{
		int i;
		struct _HPrim* hprim;
		struct _HModel* hmodel;

		hmodel = instance->hModelList + instance->currentModel;
		hprim = hmodel->hPrimList;
		for (i = hmodel->numHPrims; i != 0; i--, hprim++)
		{
			if ((hprim->segment == segment) && (hprim->type == 1) && (hprim->data.hsphere->id == 9))
			{
				hprim->hpFlags |= 1;
			}
		}
		mv->mvFlags |= 0x4000;
	}
}


void MON_TurnOffBodySpheres(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	int i;
	struct _HPrim* hprim;
	struct _HModel* hmodel;

	mv = (struct _MonsterVars*)instance->extraData;
	if (mv->mvFlags & 0x8000)
	{
		hmodel = instance->hModelList + instance->currentModel;
		hprim = hmodel->hPrimList;
		for (i = hmodel->numHPrims; i != 0; i--, hprim++)
		{
			if ((hprim->type == 1) && (hprim->data.hsphere->id == 8))
			{
				hprim->hpFlags &= 0xFE;
			}
		}
		mv->mvFlags &= 0xFFFF7FFF;
	}
}


void MON_TurnOnBodySpheres(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	int i;
	struct _HPrim* hprim;
	struct _HModel* hmodel;

	mv = (struct _MonsterVars*)instance->extraData;
	if (!(mv->mvFlags & 0x8000) && (instance->hModelList != NULL))
	{
		hmodel = instance->hModelList + instance->currentModel;
		hprim = hmodel->hPrimList;
		for (i = hmodel->numHPrims; i != 0; i--, hprim++)
		{
			if ((hprim->type == 1) && (hprim->data.hsphere->id == 8))
			{
				hprim->hpFlags |= 1;
			}
		}
		mv->mvFlags |= 0x8000;
	}
}

void MON_TurnOffAllSpheres(struct _Instance* instance)  // Matching - 100%
{
	MON_TurnOffWeaponSpheres(instance);

	MON_TurnOffBodySpheres(instance);
}

void MON_TurnOnAllSpheres(struct _Instance* instance)  // Matching - 100%
{
	MON_TurnOnWeaponSpheres(instance);

	MON_TurnOnBodySpheres(instance);
}


void MON_SwitchState(struct _Instance* instance, enum MonsterState state)  // Matching - 100%
{
	struct _MonsterVars* mv;
	int temp;  // not from SYMDUMP

	mv = (struct _MonsterVars*)instance->extraData;
	if (mv->mvFlags & 0x4000)
	{
		MON_TurnOffWeaponSpheres(instance);
	}
	if (!(mv->mvFlags & 1))
	{
		mv->previousMainState = (char)instance->currentMainState;
	}
	if ((state == MONSTER_STATE_GENERALDEATH) || (state == MONSTER_STATE_DEAD) || (state == MONSTER_STATE_IMPALEDEATH) || (state == MONSTER_STATE_GRABBED))
	{
		PurgeMessageQueue(&mv->messageQueue);
	}
	else
	{
		if (state == MONSTER_STATE_MISSILEHIT)
		{
			PurgeMessageQueue(&mv->messageQueue);
		}
	}
	instance->currentMainState = state;
	mv->mvFlags |= 1;
	mv->mvFlags &= ~0x1000;
	mv->mvFlags &= ~0x20000;
	mv->mvFlags &= ~0x40000000;
	mv->mvFlags &= ~0x4000000;
	temp = -1;
	if ((signed char)mv->pathSlotID != temp)
	{
		ENMYPLAN_ReleasePlanningWorkspace((signed char)mv->pathSlotID);
		mv->pathSlotID = temp;
	}
}


void MON_SwitchStateDoEntry(struct _Instance* instance, enum MonsterState state)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	MON_SwitchState(instance, state);

	if (mv != NULL)
	{
		(((struct _MonsterState*)MONTABLE_GetStateFuncs(instance, instance->currentMainState))->entryFunction)(instance);
		mv->mvFlags &= ~1;
	}
}

int MON_TransNodeAnimation(struct _Instance* instance)  // Matching - 100%
{
	return G2Anim_SegmentHasActiveChannels(&instance->anim, 0, 0x700);
}

struct _MonsterAnim* MON_GetAnim(struct _Instance* instance, char* animList, int index)  // Matching - 100%
{
	int whichAnim;
	struct _MonsterAttributes* mv;  // not from SYMDUMP

	whichAnim = animList[index];

	if (whichAnim == -1)
	{
		return NULL;
	}

	mv = (struct _MonsterAttributes*)instance->data;

	return &mv->animList[whichAnim];
}


void MON_PlayAnimID(struct _Instance* instance, int index, int mode)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _MonsterAnim* manim;
	struct _MonsterAttributes* ma;
	int anim;
	int anim0;
	int i;
	int interpFrames;
	int alphaTable;
	typedef unsigned long fn(struct _G2Anim_Type*, int, enum _G2AnimCallbackMsg_Enum, long, long, struct _Instance*);  // not from SYMDUMP

	ma = (struct _MonsterAttributes*)instance->data;
	mv = (struct _MonsterVars*)instance->extraData;
	manim = &ma->animList[index];
	anim0 = manim->index[0];
	if ((anim0 < 0) || (anim0 >= instance->object->numAnims))
	{
		anim0 = 0;
	}
	G2Anim_SetCallback(&instance->anim, (fn*)&INSTANCE_DefaultAnimCallback, instance);
	if ((mv->anim != NULL) && ((mv->anim->interpOut != 0)))
	{
		interpFrames = mv->anim->interpOut;
		alphaTable = mv->anim->alphaTableOut;
	}
	else
	{
		interpFrames = manim->interpFrames;
		alphaTable = manim->alphaTable;
	}
	for (i = 0; i < mv->subAttr->numSections; i++)
	{
		anim = manim->index[i];
		if (anim == -1)
		{
			anim = anim0;
		}
		G2EmulationInstanceSwitchAnimationAlpha(instance, i, anim, manim->startFrame, interpFrames, mode, alphaTable);
		G2EmulationInstanceSetAnimSpeed(instance, i, manim->playSpeed);
	}
	mv->anim = manim;
	mv->mvFlags |= 0x4000000;
	(instance->anim.section + manim->controllingSection)->callback = (fn*)&MON_AnimCallback;
	(instance->anim.section + manim->controllingSection)->callbackData = instance;
}

void MON_PlayAnimFromList(struct _Instance* instance, char* animList, int animtype, int mode)  // Matching - 100%
{
	MON_PlayAnimID(instance, animList[animtype], mode);
}

int MON_AnimIDPlaying(struct _Instance* instance, int index)  // Matching - 100%
{
	struct _MonsterAttributes* ma;
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;
	ma = (struct _MonsterAttributes*)instance->data;

	return mv->anim == &ma->animList[index];
}

void MON_PlayAnimIDIfNotPlaying(struct _Instance* instance, int index, int mode)  // Matching - 100%
{
	if (!MON_AnimIDPlaying(instance, index))
	{
		MON_PlayAnimID(instance, index, mode);
	}
}

int MON_AnimPlayingFromList(struct _Instance* instance, char* animList, int animtype)  // Matching - 100%
{
	return MON_AnimIDPlaying(instance, animList[animtype]);
}

void MON_PlayAnimFromListIfNotPlaying(struct _Instance* instance, char* animList, int animtype, int mode)  // Matching - 100%
{
	int index;

	index = animList[animtype];

	if (MON_AnimIDPlaying(instance, index) == 0)
	{
		MON_PlayAnimID(instance, index, mode);
	}
}

void MON_PlayAnim(struct _Instance* instance, enum MonsterAnim animtype, int mode)  // Matching - 100%
{
	MON_PlayAnimFromList(instance, ((struct _MonsterVars*)instance->extraData)->subAttr->animList, animtype, mode);
}

int MON_AnimPlaying(struct _Instance* instance, enum MonsterAnim animtype)  // Matching - 100%
{
	return MON_AnimPlayingFromList(instance, ((struct _MonsterVars*)instance->extraData)->subAttr->animList, animtype);
}

void MON_PlayAnimIfNotPlaying(struct _Instance* instance, enum MonsterAnim animtype, int mode)  // Matching - 100%
{
	MON_PlayAnimFromListIfNotPlaying(instance, ((struct _MonsterVars*)instance->extraData)->subAttr->animList, animtype, mode);
}


long MON_AnimCallback(struct _G2Anim_Type* anim, int sectionID, enum _G2AnimCallbackMsg_Enum message, long messageDataA, long messageDataB, void* data)  // Matching - 100%
{
	struct _Instance* instance;
	struct _MonsterVars* mv;

	instance = (struct _Instance*)data;

	mv = (struct _MonsterVars*)instance->extraData;

	switch (message)
	{
	case 1:
		instance->flags2 |= 0x10;
		mv->mvFlags &= 0xFBFFFFFF;
		break;
	case 2:
		instance->flags2 |= 0x2;
		break;
	case 4:
		break;
	default:
		INSTANCE_DefaultAnimCallback(anim, sectionID, message, messageDataA, messageDataB, instance);
		break;
	}
	return messageDataA;
}


void MON_AnimInit(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _G2AnimSection_Type* animSection;
	int i;
	int startSection;
	int numSections;
	int sectionEnd;

	mv = (struct _MonsterVars*)instance->extraData;
	numSections = mv->subAttr->numSections;
	mv->anim = NULL;
	G2EmulationInstanceSetTotalSections(instance, numSections);

	startSection = 0;
	for (i = 0; i < numSections; i++)
	{
		sectionEnd = mv->subAttr->sectionEnd[i];
		animSection = &instance->anim.section[i];

		if (sectionEnd == 0)
		{
			G2EmulationInstanceSetStartAndEndSegment(instance, i, startSection, (short)instance->object->modelList[instance->currentModel]->numSegments - 1);
		}
		else
		{
			G2EmulationInstanceSetStartAndEndSegment(instance, i, startSection, sectionEnd);
			startSection = mv->subAttr->sectionEnd[i] + 1;
		}
		G2AnimSection_SetInterpInfo(animSection, &mv->interpInfo[i]);
		G2EmulationInstanceSetAnimation(instance, i, 0, 0, 0);
		G2EmulationInstanceSetMode(instance, i, 2);
	}
	G2EmulationInstanceInitSection(instance, 0, MON_AnimCallback, instance);
	MON_PlayRandomIdle(instance, 2);
}

short MON_FacingOffset(struct _Instance* instance, struct _Instance* target)  // Matching - 100%
{
	return MATH3D_AngleFromPosToPos(&target->position, &instance->position) - target->rotation.z;
}


// autogenerated function stub: 
// int /*$ra*/ MON_CheckConditions(struct _Instance *instance /*$a0*/, struct _MonsterIR *mir /*$a1*/, char *probArray /*$a2*/)
int MON_CheckConditions(struct _Instance *instance, struct _MonsterIR *mir, char *probArray)
{ // line 651, offset 0x8007ffe4
	/* begin block 1 */
		// Start line: 653
		// Start offset: 0x8007FFE4
		// Variables:
			struct _MonsterVars *mv; // $v0
			char *probability; // $a2
			int chance; // $a1
			int i; // $t1
			int prob; // $a3
			int nprob; // $t0

		/* begin block 1.1 */
			// Start line: 663
			// Start offset: 0x80080014
			// Variables:
				int conditionProb; // $v0
		/* end block 1.1 */
		// End offset: 0x80080078
		// End Line: 674
	/* end block 1 */
	// End offset: 0x80080088
	// End Line: 677

	/* begin block 2 */
		// Start line: 1341
	/* end block 2 */
	// End Line: 1342

	/* begin block 3 */
		// Start line: 1342
	/* end block 3 */
	// End Line: 1343

	/* begin block 4 */
		// Start line: 1346
	/* end block 4 */
	// End Line: 1347
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIAttackInstance(struct _Instance *instance /*$s2*/, struct _Instance *ei /*$s0*/)
int MON_ShouldIAttackInstance(struct _Instance *instance, struct _Instance *ei)
{ // line 695, offset 0x800800bc
	/* begin block 1 */
		// Start line: 696
		// Start offset: 0x800800BC

		/* begin block 1.1 */
			// Start line: 699
			// Start offset: 0x800800E4
			// Variables:
				struct _Instance *enemyAttackee; // $s1
				long mode; // $v1
				struct _MonsterVars *mv; // $s3

			/* begin block 1.1.1 */
				// Start line: 713
				// Start offset: 0x80080180
			/* end block 1.1.1 */
			// End offset: 0x800801C0
			// End Line: 719
		/* end block 1.1 */
		// End offset: 0x800801C0
		// End Line: 720
	/* end block 1 */
	// End offset: 0x800801C4
	// End Line: 723

	/* begin block 2 */
		// Start line: 1454
	/* end block 2 */
	// End Line: 1455

	/* begin block 3 */
		// Start line: 1455
	/* end block 3 */
	// End Line: 1456
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIAttack(struct _Instance *instance /*$s3*/, struct _MonsterIR *enemy /*$s1*/, struct _MonsterAttackAttributes *attack /*$s0*/)
int MON_ShouldIAttack(struct _Instance *instance, struct _MonsterIR *enemy, struct _MonsterAttackAttributes *attack)
{ // line 731, offset 0x800801e0
	/* begin block 1 */
		// Start line: 732
		// Start offset: 0x800801E0
		// Variables:
			struct _MonsterVars *mv; // $s4
			int rv; // $a0
			struct _Instance *ei; // $s2

		/* begin block 1.1 */
			// Start line: 751
			// Start offset: 0x8008024C
			// Variables:
				long distance; // $v1
		/* end block 1.1 */
		// End offset: 0x80080364
		// End Line: 803
	/* end block 1 */
	// End offset: 0x80080368
	// End Line: 809

	/* begin block 2 */
		// Start line: 1527
	/* end block 2 */
	// End Line: 1528
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// struct _MonsterAttackAttributes * /*$ra*/ MON_ChooseAttack(struct _Instance *instance /*$a0*/, struct _MonsterIR *enemy /*$a1*/)
struct _MonsterAttackAttributes * MON_ChooseAttack(struct _Instance *instance, struct _MonsterIR *enemy)
{ // line 818, offset 0x80080388
	/* begin block 1 */
		// Start line: 820
		// Start offset: 0x80080388
		// Variables:
			struct _MonsterVars *mv; // $t1
			struct _MonsterAttackAttributes *bestAttack; // $t5
			struct _MonsterAttributes *ma; // $t6
			struct _MonsterCombatAttributes *combat; // $t0
			long distance; // $t3
			long zdiff; // $t2
			long smallest; // $t4
			int i; // $a3
			char *attackIndex; // $t0

		/* begin block 1.1 */
			// Start line: 850
			// Start offset: 0x8008042C
			// Variables:
				struct _MonsterAttackAttributes *attack; // $a2
				long delta; // $a0
		/* end block 1.1 */
		// End offset: 0x800804CC
		// End Line: 864
	/* end block 1 */
	// End offset: 0x800804D8
	// End Line: 869

	/* begin block 2 */
		// Start line: 1705
	/* end block 2 */
	// End Line: 1706

	/* begin block 3 */
		// Start line: 1706
	/* end block 3 */
	// End Line: 1707

	/* begin block 4 */
		// Start line: 1707
	/* end block 4 */
	// End Line: 1708
				UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIEvade(struct _Instance *instance /*$s1*/)
int MON_ShouldIEvade(struct _Instance *instance)
{ // line 878, offset 0x800804e8
	/* begin block 1 */
		// Start line: 879
		// Start offset: 0x800804E8
		// Variables:
			struct _MonsterVars *mv; // $s0
			int rv; // $s3

		/* begin block 1.1 */
			// Start line: 886
			// Start offset: 0x80080520
			// Variables:
				struct _MonsterIR *enemy; // $s2
		/* end block 1.1 */
		// End offset: 0x80080574
		// End Line: 899
	/* end block 1 */
	// End offset: 0x80080574
	// End Line: 903

	/* begin block 2 */
		// Start line: 1869
	/* end block 2 */
	// End Line: 1870
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ChooseLeftOrRight(struct _Instance *instance /*$s0*/, struct _MonsterIR *enemy /*$a1*/)
int MON_ChooseLeftOrRight(struct _Instance *instance, struct _MonsterIR *enemy)
{ // line 913, offset 0x80080594
	/* begin block 1 */
		// Start line: 914
		// Start offset: 0x80080594

		/* begin block 1.1 */
			// Start line: 923
			// Start offset: 0x800805D4
			// Variables:
				int leftDist; // $s0
				int rightDist; // $v1
		/* end block 1.1 */
		// End offset: 0x80080628
		// End Line: 932
	/* end block 1 */
	// End offset: 0x80080628
	// End Line: 933

	/* begin block 2 */
		// Start line: 1940
	/* end block 2 */
	// End Line: 1941
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ChooseEvadeMove(struct _Instance *instance /*$a0*/)
int MON_ChooseEvadeMove(struct _Instance *instance)
{ // line 935, offset 0x80080638
	/* begin block 1 */
		// Start line: 936
		// Start offset: 0x80080638
		// Variables:
			int anim; // $v0
			struct _MonsterVars *mv; // $v0
			int leftOrRight; // $v1
	/* end block 1 */
	// End offset: 0x80080684
	// End Line: 964

	/* begin block 2 */
		// Start line: 1989
	/* end block 2 */
	// End Line: 1990
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ChooseCombatMove(struct _Instance *instance /*$s2*/, int reason /*$a1*/)
int MON_ChooseCombatMove(struct _Instance *instance, int reason)
{ // line 969, offset 0x80080694
	/* begin block 1 */
		// Start line: 970
		// Start offset: 0x80080694
		// Variables:
			struct _MonsterVars *mv; // $s3
			struct _MonsterSubAttributes *subAttr; // $s4
			int anim; // $s1
			int data; // $v0
			struct _MonsterIR *enemy; // $s0
			int infront; // $a0
			struct _MonsterAnim *manim; // $s0

		/* begin block 1.1 */
			// Start line: 1032
			// Start offset: 0x80080748

			/* begin block 1.1.1 */
				// Start line: 1036
				// Start offset: 0x80080768
				// Variables:
					int dir; // $v0
			/* end block 1.1.1 */
			// End offset: 0x800807B0
			// End Line: 1045
		/* end block 1.1 */
		// End offset: 0x800807C8
		// End Line: 1068

		/* begin block 1.2 */
			// Start line: 1072
			// Start offset: 0x800807D0
			// Variables:
				short zrot; // $s0

			/* begin block 1.2.1 */
				// Start line: 1108
				// Start offset: 0x800808C0
				// Variables:
					_Position temp; // stack offset -56
					SVECTOR New; // stack offset -48
					VECTOR OutTrans; // stack offset -40
			/* end block 1.2.1 */
			// End offset: 0x800809E0
			// End Line: 1148
		/* end block 1.2 */
		// End offset: 0x80080AB8
		// End Line: 1173
	/* end block 1 */
	// End offset: 0x80080AB8
	// End Line: 1177

	/* begin block 2 */
		// Start line: 2057
	/* end block 2 */
	// End Line: 2058
					UNIMPLEMENTED();
	return 0;
}


void MON_PlayRandomIdle(struct _Instance* instance, int mode)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _MonsterAttributes* ma;
	struct _MonsterBehavior* behavior;
	struct _MonsterIdle* idle;
	int chance;
	int i;
	char* idleIndex;

	mv = (struct _MonsterVars*)instance->extraData;
	ma = (struct _MonsterAttributes*)instance->data;

	idle = NULL;
	chance = rand() % 100;
	if (mv->mvFlags & 4)
	{
		behavior = ma->behaviorList;
		idle = &ma->idleList[behavior->idleList[0]];
	}
	else
	{
		if (mv->subAttr->behaviorList != NULL)
		{
			i = mv->subAttr->behaviorList[mv->behaviorState];
		}
		else
		{
			i = -1;
		}

		if (i == -1)
		{
			behavior = ma->behaviorList;
		}
		else
		{
			behavior = &ma->behaviorList[i];
		}

		if (mv->behaviorState == 0)
		{
			idle = &ma->idleList[((struct _MonsterBehavior*)((long)behavior + mv->ambient))->idleList[0]];
		}
		else
		{
			for (i = behavior->numIdles, idleIndex = &behavior->idleList[0]; i != 0; i--, idleIndex++)
			{
				if (idleIndex[0] < 0)
				{
					break;
				}

				idle = &ma->idleList[idleIndex[0]];
				if (chance < idle->probability)
				{
					break;
				}
				chance -= idle->probability;
			}
		}
	}

	if (idle != NULL)
	{
		MON_PlayAnimIDIfNotPlaying(instance, idle->anim, mode);
		mv->alertness = behavior->alertness;
	}
}

void MON_PlayCombatIdle(struct _Instance* instance, int mode)  // Matching - 100%
{
	int anim;

	if ((((struct _MonsterVars*)instance->extraData)->mvFlags & 0x10))
	{
		anim = 11;
	}
	else
	{
		anim = 10;
	}

	MON_PlayAnimIfNotPlaying(instance, (enum MonsterAnim)anim, mode);
}


// autogenerated function stub: 
// void /*$ra*/ MON_GetRandomPoint(_Position *out /*$s2*/, _Position *in /*$s1*/, short r /*$a2*/)
void MON_GetRandomPoint(_Position *out, _Position *in, short r)
{ // line 1290, offset 0x80080cc0
	/* begin block 1 */
		// Start line: 1291
		// Start offset: 0x80080CC0
		// Variables:
			int ang; // $s0
	/* end block 1 */
	// End offset: 0x80080CC0
	// End Line: 1291

	/* begin block 2 */
		// Start line: 2580
	/* end block 2 */
	// End Line: 2581
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ MON_GetRandomDestinationInWorld(struct _Instance *instance /*$s2*/, _Position *in /*$s0*/, short r /*$s4*/)
int MON_GetRandomDestinationInWorld(struct _Instance *instance, _Position *in, short r)
{ // line 1307, offset 0x80080d6c
	/* begin block 1 */
		// Start line: 1308
		// Start offset: 0x80080D6C

		/* begin block 1.1 */
			// Start line: 1311
			// Start offset: 0x80080DA0
			// Variables:
				struct _MonsterVars *mv; // $s1
				//struct evPhysicsLOSData data; // stack offset -48
				int result; // $s0
				int avoidEnemy; // $s3

			/* begin block 1.1.1 */
				// Start line: 1322
				// Start offset: 0x80080DDC
			/* end block 1.1.1 */
			// End offset: 0x80080E2C
			// End Line: 1328

			/* begin block 1.1.2 */
				// Start line: 1342
				// Start offset: 0x80080EA8
			/* end block 1.1.2 */
			// End offset: 0x80080EF8
			// End Line: 1348
		/* end block 1.1 */
		// End offset: 0x80080F30
		// End Line: 1357
	/* end block 1 */
	// End offset: 0x80080F34
	// End Line: 1360

	/* begin block 2 */
		// Start line: 2752
	/* end block 2 */
	// End Line: 2753
				UNIMPLEMENTED();
	return 0;
}

void MON_MoveForward(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	PhysicsSetVelFromRot(instance, &instance->rotation, mv->speed);

	instance->xAccl = 0;
	instance->yAccl = 0;
	instance->zAccl = 0;

	PhysicsMove(instance, &instance->position, gameTrackerX.timeMult);
}


int MON_TurnToPosition(struct _Instance* instance, struct _Position* position, short turnspeed) // Matching - 100%
{
	short temp;  // not from SYMDUMP

	temp = MATH3D_AngleFromPosToPos(&instance->position, position);

	AngleMoveToward(&instance->rotation.z, temp, (turnspeed * gameTrackerX.timeMult / 4096));

	return instance->rotation.z == temp;
}

void MON_MoveToPosition(struct _Instance* instance, struct _Position* position, short turnSpeed)  // Matching - 100%
{
	MON_TurnToPosition(instance, position, turnSpeed);

	if (MON_TransNodeAnimation(instance) == 0)
	{
		MON_MoveForward(instance);
	}
}


int MON_OnGround(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct evPhysicsGravityData data;
	int minUpper;
	long xyDist;

	mv = (struct _MonsterVars*)instance->extraData;

	xyDist = MATH3D_LengthXY(instance->oldPos.x - instance->position.x, instance->oldPos.y - instance->position.y);

	data.UpperOffset = instance->oldPos.z - instance->position.z;
	data.LowerOffset = (short)xyDist;
	minUpper = 400;
	if (mv->mvFlags & 2)
	{
		minUpper = 100;
	}

	if (data.UpperOffset < minUpper)
	{
		data.UpperOffset = minUpper;
	}

	if ((short)xyDist < 100)
	{
		data.LowerOffset = 100;
	}

	data.UpperOffset += mv->subAttr->upOnGroundOffset;
	data.LowerOffset += mv->subAttr->downOnGroundOffset;
	data.slipSlope = 3200;
	return PhysicsCheckGravity(instance, (int)&data.UpperOffset, (!(mv->mvFlags & 0x800)) * 4);
}

void MON_ApplyPhysics(struct _Instance* instance)  // Matching - 100%
{
	PhysicsMove(instance, &instance->position, gameTrackerX.timeMult);
}


// autogenerated function stub: 
// void /*$ra*/ MON_ChangeBehavior(struct _Instance *instance /*$a0*/, int behavior /*$s0*/)
void MON_ChangeBehavior(struct _Instance *instance, int behavior)
{ // line 1559, offset 0x8008116c
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_CheckEnvironment(struct _Instance *instance /*$s1*/)
void MON_CheckEnvironment(struct _Instance *instance)
{ // line 1596, offset 0x800811f4
	/* begin block 1 */
		// Start line: 1597
		// Start offset: 0x800811F4
		// Variables:
			struct _MonsterVars *mv; // $s0
			struct _MonsterAttributes *ma; // $s4
			int inwater; // $v0
			struct _SVector Hack; // stack offset -40

		/* begin block 1.1 */
			// Start line: 1637
			// Start offset: 0x80081328
			// Variables:
				int moveback; // $s2
				int onground; // $s3

			/* begin block 1.1.1 */
				// Start line: 1664
				// Start offset: 0x800813D4
				// Variables:
					int offset; // $a1
					//int result; // $v0
					_Position pos; // stack offset -32
			/* end block 1.1.1 */
			// End offset: 0x8008147C
			// End Line: 1684

			/* begin block 1.1.2 */
				// Start line: 1696
				// Start offset: 0x800814B8
				// Variables:
					//int result; // $v0
					//int offset; // $a1
			/* end block 1.1.2 */
			// End offset: 0x80081518
			// End Line: 1712

			/* begin block 1.1.3 */
				// Start line: 1719
				// Start offset: 0x80081520
				// Variables:
					//int result; // $v1
			/* end block 1.1.3 */
			// End offset: 0x8008157C
			// End Line: 1749
		/* end block 1.1 */
		// End offset: 0x800815E4
		// End Line: 1762
	/* end block 1 */
	// End offset: 0x80081608
	// End Line: 1767

	/* begin block 2 */
		// Start line: 3284
	/* end block 2 */
	// End Line: 3285
					UNIMPLEMENTED();
}


void MON_CheckTerrainAndRespond(struct _Instance* instance, struct BSPTree* bsp, struct _TFace* tface)  // Matching - 100%
{
	unsigned long results;

	results = MON_CheckTerrain(instance, bsp, tface);

	if (results & 0x10)
	{
		INSTANCE_Post(instance, 0x100000C, 16);
	}

	if (results & 0x20)
	{
		INSTANCE_Post(instance, 0x100000C, 32);
	}

	if (results & 0x40)
	{
		INSTANCE_Post(instance, 0x100000C, 64);
	}

}


unsigned long MON_CheckTerrain(struct _Instance* instance, struct BSPTree* bsp, struct _TFace* tface)  // Matching - 100%
{
	unsigned long rv;

	rv = 0;

	if (tface != NULL)
	{
		struct Level* level;

		level = STREAM_GetLevelWithID(instance->currentStreamUnitID);

		if (!(bsp->flags & 8) && ((level->unitFlags & 2) || (bsp->flags & 0x50)))
		{
			rv = 0x40;
		}

		if ((bsp->flags & 0x80) || (instance->waterFace != NULL))
		{
			rv |= 0x10;
		}

		if (bsp->flags & 0x20)
		{
			rv |= 0x20;
		}

	}

	return rv;
}


// autogenerated function stub: 
// int /*$ra*/ MON_CheckPointSuitability(struct _Instance *instance /*$s2*/, _Position *origin /*$a1*/, _Position *destination /*$s4*/)
int MON_CheckPointSuitability(struct _Instance *instance, _Position *origin, _Position *destination)
{ // line 1824, offset 0x8008176c
	/* begin block 1 */
		// Start line: 1825
		// Start offset: 0x8008176C
		// Variables:
			struct _MonsterVars *mv; // $s1
			int rc; // $s3
			int result; // $a0
			struct evPhysicsDropHeightData *data; // $s0
	/* end block 1 */
	// End offset: 0x80081820
	// End Line: 1851

	/* begin block 2 */
		// Start line: 3761
	/* end block 2 */
	// End Line: 3762
			UNIMPLEMENTED();
	return 0;
}

unsigned long MON_GetTime(struct _Instance* instance)  // Matching - 100%
{
	if ((instance->object->oflags & 0x80000))
	{
		return (unsigned long)gameTrackerX.currentTime;
	}
	else if ((instance->flags2 & 0x8000000) != 0)
	{
		return gameTrackerX.currentSpectralTime;
	}

	return gameTrackerX.currentMaterialTime;
}


// autogenerated function stub: 
// void /*$ra*/ MON_BirthSoul(struct _Instance *instance /*$s1*/, int link /*$s3*/)
void MON_BirthSoul(struct _Instance *instance, int link)
{ // line 1944, offset 0x80081898
	/* begin block 1 */
		// Start line: 1945
		// Start offset: 0x80081898
		// Variables:
			struct _MonsterVars *mv; // $s2

		/* begin block 1.1 */
			// Start line: 1952
			// Start offset: 0x800818E4
			// Variables:
				struct Object *soulob; // $a1

			/* begin block 1.1.1 */
				// Start line: 1959
				// Start offset: 0x800818F8
				// Variables:
					struct _Instance *isoul; // $s0

				/* begin block 1.1.1.1 */
					// Start line: 1980
					// Start offset: 0x8008195C
					// Variables:
						MATRIX *matrix; // $v1
				/* end block 1.1.1.1 */
				// End offset: 0x80081980
				// End Line: 1984
			/* end block 1.1.1 */
			// End offset: 0x80081988
			// End Line: 1990
		/* end block 1.1 */
		// End offset: 0x80081988
		// End Line: 1993

		/* begin block 1.2 */
			// Start line: 1996
			// Start offset: 0x80081990
			// Variables:
				//struct _Instance *isoul; // $a0
		/* end block 1.2 */
		// End offset: 0x800819E0
		// End Line: 2010
	/* end block 1 */
	// End offset: 0x800819E0
	// End Line: 2012

	/* begin block 2 */
		// Start line: 3923
	/* end block 2 */
	// End Line: 3924

	/* begin block 3 */
		// Start line: 3931
	/* end block 3 */
	// End Line: 3932
						UNIMPLEMENTED();
}


void MON_ProcessIntro(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	long initialBehavior;
	long triggeredBehavior;
	long activeBehavior;
	long guardRange;
	long wanderRange;
	long ambushRange;
	long hitPoints;
	int spectral;
	long flags;
	struct _MonsterAttributes* ma;

	initialBehavior = -1;
	triggeredBehavior = -1;
	activeBehavior = -1;
	guardRange = 0;
	wanderRange = 0;
	ambushRange = 0;
	spectral = 0;

	ma = (struct _MonsterAttributes*)instance->data;
	mv = (struct _MonsterVars*)instance->extraData;
	mv->age = ma->defaultAge;
	mv->ambushArc = 0x800;
	mv->ambushElevation = 0x400;
	hitPoints = -1;
	mv->auxFlags |= 0x80000000;
	flags = 0;

	if (instance->introData != NULL)
	{
		struct INICommand* command;

		command = (struct INICommand*)instance->introData;

		if ((instance->flags & 0x02) == 0)
		{
			while (command->command != 0)
			{
				switch (command->command)
				{
				case 255:
				{
					break;
				}
				case 1:
				{
					initialBehavior = command->parameter[0];
					break;
				}
				case 2:
				{
					triggeredBehavior = command->parameter[0];
					break;
				}
				case 3:
				{
					spectral = 1;
					break;
				}
				case 22:
				{
					ambushRange = command->parameter[0];
					break;
				}
				case 25:
				{
					mv->ambushJumpType = (char)command->parameter[0];
					break;
				}
				case 23:
				{
					mv->ambushArc = (short)((command->parameter[0] << 12) / 360);

					break;
				}
				case 24:
				{
					mv->ambushElevation = (short)((command->parameter[0] << 12) / 360);

					break;
				}
				case 4:
				{
					wanderRange = command->parameter[0];
					break;
				}
				case 5:
				{
					guardRange = command->parameter[0];
					break;
				}
				case 6:
				{
					mv->age = (unsigned char)command->parameter[0];
					break;
				}
				case 7:
				{
					flags |= 0x100000;
					break;
				}
				case 8:
				{
					hitPoints = command->parameter[0];
					break;
				}
				case 9:
				{
					instance->flags2 |= 0x20000;
					flags |= 0x1000000;

					if (command->numParameters != 0)
					{
						mv->regenTime = (short)command->parameter[0];
					}
					else
					{
						mv->regenTime = 0;
					}

					break;
				}
				case 10:
				{
					short* pmarker;
					long* param;
					int i;

					i = command->numParameters;;
					pmarker = mv->patrolMarkers;
					param = command->parameter;

					for (; i != 0; i--)
					{
						*pmarker = (short)*param;
						param++;
						pmarker++;
					}

					*pmarker = 0;
					mv->currentMarker = mv->patrolMarkers;

					break;
				}
				case 12:
				{
					mv->ambushMarker = (char)command->parameter[0];
					break;
				}
				case 13:
				{
					mv->fleeMarker = (short)command->parameter[0];
					break;
				}
				case 14:
				{
					int i;
					short* unit;

					unit = mv->validUnits;

					for (i = 0; i < command->numParameters; i++)
					{
						*unit = (short)command->parameter[i];
						unit++;
					}

					*unit = 0;

					break;
				}
				case 11:
				{
					mv->ambient = (unsigned char)command->parameter[0];
					break;
				}
				case 15:
				{
					mv->soulID = command->parameter[0];
					break;
				}
				case 16:
				{
					mv->causeOfDeath = (unsigned char)command->parameter[0];
					if (mv->soulID == 0)
					{
						mv->soulID = 0x7FFFFFFF;
					}
					break;
				}
				case 17:
				{
					mv->auxFlags &= 0x7FFFFFFF;
					break;
				}
				case 20:
				{
					activeBehavior = command->parameter[0];
					break;
				}
				}

				command = (struct INICommand*)(command->parameter + command->numParameters);
			}
		}
	}

	MON_SetDefaults(instance);

	mv->mvFlags ^= flags;

	if (initialBehavior != -1)
	{
		mv->initialBehavior = (char)initialBehavior;
		mv->behaviorState = (char)initialBehavior;
	}

	if (triggeredBehavior != -1)
	{
		mv->triggeredBehavior = (char)triggeredBehavior;
	}

	if (activeBehavior != -1)
	{
		mv->activeBehavior = (char)activeBehavior;
	}

	if (hitPoints != -1)
	{
		mv->hitPoints = (short)(hitPoints << 8);
	}

	if (spectral != 0)
	{
		if ((instance->flags2 & 0x8000000))
		{
			instance->flags2 &= 0xF7FFFFFF;
		}
		else
		{
			instance->flags2 |= 0x8000000;
		}
	}

	if (guardRange != 0)
	{
		mv->guardRange = (short)guardRange;
	}

	if (wanderRange != 0)
	{
		mv->wanderRange = (short)wanderRange;
	}

	if (ambushRange != 0)
	{
		mv->ambushRange = (short)ambushRange;
	}

	if ((mv->triggeredBehavior == 8) && (mv->initialBehavior != 4) && (mv->initialBehavior != 16))
	{
		mv->initialBehavior = 4;
		mv->behaviorState = 4;
	}
}


void MON_SetDefaults(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _MonsterAttributes* ma;
	struct _MonsterSubAttributes* subAttr;

	mv = (struct _MonsterVars*)instance->extraData;
	ma = (struct _MonsterAttributes*)instance->data;
	if (mv->age >= ma->numSubAttributes)
	{
		mv->age = ma->numSubAttributes - 1;
	}
	subAttr = ma->subAttributesList[mv->age];
	mv->subAttr = subAttr;
	instance->currentModel = subAttr->modelNum;
	instance->scale.x = instance->scale.y = instance->scale.z = subAttr->scale;
	mv->behaviorState = subAttr->defInitialBehavior;
	mv->initialBehavior = subAttr->defInitialBehavior;
	mv->triggeredBehavior = subAttr->defTriggeredBehavior;
	mv->wanderRange = subAttr->defWanderRange;
	mv->guardRange = subAttr->defGuardRange;
	mv->ambushRange = subAttr->defAmbushRange;
	mv->soulJuice = 4096;
	mv->alertness = 3;
	mv->lastSideMove = 8;
	if (subAttr->combatAttributes != NULL)
	{
		mv->hitPoints = (subAttr->combatAttributes->hitPoints) * 256;
		if (subAttr->combatAttributes->missileAttack != -1)
		{
			mv->mvFlags |= 0x20;
		}
	}
	if ((mv->age == 2) && (ma->whatAmI & 2))
	{
		mv->mvFlags |= 0x10000000;
	}
	if (subAttr->defSpectral != 0)
	{
		instance->flags2 |= 0x08000000;
	}
	mv->avoidMask = 0x100;
	if (subAttr->waterVuln != 0)
	{
		mv->avoidMask = 0x110;
	}
	if (subAttr->fireVuln != 0)
	{
		mv->avoidMask |= 0x20;
	}
	if (subAttr->sunVuln != 0)
	{
		mv->avoidMask |= 0x40;
	}
	if (subAttr->soundVuln != 0)
	{
		mv->avoidMask |= 0x200;
	}
	if (subAttr->impaleVuln != 0)
	{
		mv->avoidMask |= 0x80;
	}
}

void MON_GetPlanSlot(struct _MonsterVars* mv)  // Matching - 100%
{
	if (mv->pathSlotID != -1)
	{
		ENMYPLAN_ReleasePlanningWorkspace(mv->pathSlotID);
	}

	mv->pathSlotID = ENMYPLAN_GetInitializedPlanningWorkspaceFinal();
}


// autogenerated function stub: 
// int /*$ra*/ MON_DefaultPlanMovement(struct _Instance *instance /*$s2*/, int anim /*$s4*/, long distance /*$s5*/)
int MON_DefaultPlanMovement(struct _Instance *instance, int anim, long distance)
{ // line 2277, offset 0x8008216c
	/* begin block 1 */
		// Start line: 2278
		// Start offset: 0x8008216C
		// Variables:
			struct _MonsterVars *mv; // $s0
			int rc; // $s1
			int felloff; // $v1
			long length; // $s3
			struct _MonsterAnim *manim; // $s6

		/* begin block 1.1 */
			// Start line: 2307
			// Start offset: 0x80082260
			// Variables:
				_Position pos; // stack offset -40
				int planresult; // $v1

			/* begin block 1.1.1 */
				// Start line: 2348
				// Start offset: 0x80082318
				// Variables:
					short turnSpeed; // $a2
			/* end block 1.1.1 */
			// End offset: 0x80082394
			// End Line: 2365
		/* end block 1.1 */
		// End offset: 0x80082394
		// End Line: 2365
	/* end block 1 */
	// End offset: 0x800823E4
	// End Line: 2389

	/* begin block 2 */
		// Start line: 4771
	/* end block 2 */
	// End Line: 4772
					UNIMPLEMENTED();
	return 0;
}


void MON_DropAllObjects(struct _Instance* instance)  // Matching - 100%
{
	struct _Instance* child;
	struct _Instance* next;

	child = instance->LinkChild;
	while (child != NULL)
	{
		next = child->LinkSibling;
		while (FALSE)
		{

		}
		if (child->ParentLinkNode == 3)
		{
			INSTANCE_Post(child, 0x800008, 2);
		}
		else
		{
			INSTANCE_Post(child, 0x800008, 1);
		}
		child = next;
	}
}


// autogenerated function stub: 
// void /*$ra*/ MON_EnableHeadMove(struct _Instance *instance /*$a0*/)
void MON_EnableHeadMove(struct _Instance *instance)
{ // line 2407, offset 0x8008247c
	/* begin block 1 */
		// Start line: 2408
		// Start offset: 0x8008247C
		// Variables:
			struct _MonsterAttributes *ma; // $s0
	/* end block 1 */
	// End offset: 0x80082510
	// End Line: 2427

	/* begin block 2 */
		// Start line: 5042
	/* end block 2 */
	// End Line: 5043
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_DisableHeadMove(struct _Instance *instance /*$a0*/)
void MON_DisableHeadMove(struct _Instance *instance)
{ // line 2429, offset 0x80082524
	/* begin block 1 */
		// Start line: 2430
		// Start offset: 0x80082524
		// Variables:
			struct _MonsterAttributes *ma; // $s0
	/* end block 1 */
	// End offset: 0x8008259C
	// End Line: 2442

	/* begin block 2 */
		// Start line: 5086
	/* end block 2 */
	// End Line: 5087
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_LookInDirection(struct _Instance *instance /*$a0*/, short tx /*$a1*/, short tz /*$a2*/)
void MON_LookInDirection(struct _Instance *instance, short tx, short tz)
{ // line 2447, offset 0x800825b0
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_LookAtPos(struct _Instance *instance /*$s1*/, _Position *position /*$a1*/)
void MON_LookAtPos(struct _Instance *instance, _Position *position)
{ // line 2478, offset 0x80082724
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_ProcessLookAt(struct _Instance *instance /*$s1*/)
void MON_ProcessLookAt(struct _Instance *instance)
{ // line 2511, offset 0x80082800
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ MON_TakeDamage(struct _Instance *instance /*$a0*/, int damage /*$s2*/, int type /*$s1*/)
int MON_TakeDamage(struct _Instance *instance, int damage, int type)
{ // line 2545, offset 0x800828f4
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_SetUpSaveInfo(struct _Instance *instance /*$t0*/, struct _MonsterSaveInfo *saveData /*$a3*/)
void MON_SetUpSaveInfo(struct _Instance *instance, struct _MonsterSaveInfo *saveData)
{ // line 2582, offset 0x800829a0
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_GetSaveInfo(struct _Instance *instance /*$s1*/, struct _MonsterSaveInfo *saveData /*$s2*/)
void MON_GetSaveInfo(struct _Instance* instance, struct _MonsterSaveInfo* saveData)
{ // line 2616, offset 0x80082b0c
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_KillMonster(struct _Instance *instance /*$s5*/)
void MON_KillMonster(struct _Instance *instance)
{ // line 2694, offset 0x80082d50
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIAmbushEnemy(struct _Instance *instance /*$s3*/)
int MON_ShouldIAmbushEnemy(struct _Instance *instance)
{ // line 2755, offset 0x80082f28
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIFireAtTarget(struct _Instance *instance /*$a0*/, struct _MonsterIR *target /*$a1*/)
int MON_ShouldIFireAtTarget(struct _Instance *instance, struct _MonsterIR *target)
{ // line 2802, offset 0x80083094
	/* begin block 1 */
		// Start line: 2804
		// Start offset: 0x80083094
		// Variables:
			struct _MonsterVars *mv; // $a2

		/* begin block 1.1 */
			// Start line: 2810
			// Start offset: 0x800830C4
			// Variables:
				struct _MonsterAttributes *ma; // $v1
				struct _MonsterMissile *missileAttack; // $a0

			/* begin block 1.1.1 */
				// Start line: 2815
				// Start offset: 0x800830FC
				// Variables:
					long distance; // $a1

				/* begin block 1.1.1.1 */
					// Start line: 2819
					// Start offset: 0x80083114
					// Variables:
						struct _MonsterIR *known; // $v1
				/* end block 1.1.1.1 */
				// End offset: 0x8008317C
				// End Line: 2836
			/* end block 1.1.1 */
			// End offset: 0x8008317C
			// End Line: 2837
		/* end block 1.1 */
		// End offset: 0x8008317C
		// End Line: 2838
	/* end block 1 */
	// End offset: 0x8008317C
	// End Line: 2842

	/* begin block 2 */
		// Start line: 5881
	/* end block 2 */
	// End Line: 5882

	/* begin block 3 */
		// Start line: 5882
	/* end block 3 */
	// End Line: 5883
						UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIFlee(struct _Instance *instance /*$a0*/)
int MON_ShouldIFlee(struct _Instance *instance)
{ // line 2847, offset 0x80083184
	UNIMPLEMENTED();
	return 0;
}


void MON_RelocateCoords(struct _Instance* instance, struct _SVector* offset)  // Matching - 100%
{
	struct _MonsterVars* mv;
	int ox;
	int oy;
	int oz;

	mv = (struct _MonsterVars*)instance->extraData;

	ox = offset->x;
	oy = offset->y;
	oz = offset->z;

	mv->destination.x += ox;
	mv->destination.y += oy;
	mv->destination.z += oz;

	mv->lastValidPos.x += ox;
	mv->lastValidPos.y += oy;
	mv->lastValidPos.z += oz;

	if (mv->pathSlotID != -1)
	{
		ENMYPLAN_RelocatePlanPositions(mv->pathSlotID, (struct _Position*)offset);
	}
}

int MON_ValidUnit(struct _Instance* instance, unsigned long unitId)//Matching - 100%
{
	struct _MonsterVars* mv;
	short* unit;

	mv = (struct _MonsterVars*)instance->extraData;
	unit = &mv->validUnits[0];

	if (!*unit)
	{
		return 1;
	}

	while (*unit)
	{
		if (unitId == *(unsigned short*)unit++)
		{
			return 1;
		}
	}

	return 0;
}

int MON_ValidPosition(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;

	if (MON_ValidUnit(instance, instance->currentStreamUnitID) != 0)
	{
		mv = (struct _MonsterVars*)instance->extraData;
		mv->lastValidPos = instance->position;
		
		return 1;
	}

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_SphereWorldPos(MATRIX *mat /*$s1*/, struct _HSphere *sphere /*$a1*/, _Position *ret /*$s0*/)
void MON_SphereWorldPos(MATRIX *mat, struct _HSphere *sphere, _Position *ret)
{ // line 2936, offset 0x800833b4
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _HPrim * /*$ra*/ MON_FindSphereForTerrain(struct _Instance *instance /*$a0*/)
struct _HPrim * MON_FindSphereForTerrain(struct _Instance *instance)
{ // line 2945, offset 0x80083424
	UNIMPLEMENTED();
	return NULL;
}


// autogenerated function stub: 
// struct Intro * /*$ra*/ MON_FindNearestImpalingIntro(int unitID /*$a0*/, _Position *position /*$s4*/)
struct Intro * MON_FindNearestImpalingIntro(int unitID, _Position *position)
{ // line 2979, offset 0x800834b0
	/* begin block 1 */
		// Start line: 2980
		// Start offset: 0x800834B0
		// Variables:
			struct Intro *current; // $v1
			struct Intro *res; // $s2
			struct Level *level; // $v0
			int min_dist; // $s3
			int dist; // $v1
			int i; // $s1
	/* end block 1 */
	// End offset: 0x800835BC
	// End Line: 3023

	/* begin block 2 */
		// Start line: 6271
	/* end block 2 */
	// End Line: 6272
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// struct Intro * /*$ra*/ MON_TestForTerrainImpale(struct _Instance *instance /*$s0*/, struct _Terrain *terrain /*$s1*/)
struct Intro * MON_TestForTerrainImpale(struct _Instance *instance, struct _Terrain *terrain)
{ // line 3027, offset 0x800835e0
	/* begin block 1 */
		// Start line: 3028
		// Start offset: 0x800835E0
		// Variables:
			struct _MonsterVars *mv; // $v0
			struct Intro *current; // $s1
			struct _HPrim *prim; // $v1
			struct _HSphere *sphere; // $a1
			int i; // $s2
			int radius; // $s3
			_Position spherePos; // stack offset -32
	/* end block 1 */
	// End offset: 0x800836C0
	// End Line: 3070

	/* begin block 2 */
		// Start line: 6385
	/* end block 2 */
	// End Line: 6386
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ MON_MoveInstanceToImpalePoint(struct _Instance *instance /*$s0*/)
void MON_MoveInstanceToImpalePoint(struct _Instance *instance)
{ // line 3072, offset 0x800836dc
	/* begin block 1 */
		// Start line: 3073
		// Start offset: 0x800836DC
		// Variables:
			struct _MonsterVars *mv; // $v1
			struct Intro *impaler; // $t3
			_Position offset; // stack offset -16

		/* begin block 1.1 */
			// Start line: 3097
			// Start offset: 0x80083718
			// Variables:
				short _x0; // $v0
				short _y0; // $v1
				short _z0; // $a2
				short _y1; // $t0
				//short _z1; // $t2
				_Position *_v; // $a3
				//_Position *_v1; // $a1
		/* end block 1.1 */
		// End offset: 0x80083718
		// End Line: 3097

		/* begin block 1.2 */
			// Start line: 3097
			// Start offset: 0x80083718
			// Variables:
				short _x1; // $v1
				//short _y1; // $a2
				//short _z1; // $a3
				struct _Rotation *_v0; // $v0
				//struct _Rotation *_v1; // $v0
		/* end block 1.2 */
		// End offset: 0x80083718
		// End Line: 3097
	/* end block 1 */
	// End offset: 0x800837B0
	// End Line: 3107

	/* begin block 2 */
		// Start line: 6491
	/* end block 2 */
	// End Line: 6492
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ MON_ReachableIntro(struct _Instance *instance /*stack 0*/, _Position *pos /*$fp*/, _Position *introPos /*$s7*/, struct _Rotation *introRot /*stack 12*/, int checkOrientation /*stack 16*/)
int MON_ReachableIntro(struct _Instance *instance, _Position *pos, _Position *introPos, struct _Rotation *introRot, int checkOrientation)
{ // line 3121, offset 0x800837c0
	/* begin block 1 */
		// Start line: 3122
		// Start offset: 0x800837C0
		// Variables:
			struct _MonsterVars *mv; // $s2
			int angle; // $s5
			int angle2; // $s6
			int angle3; // $v1
			int flightAngle; // $v0
			int length; // $v0
			int length2; // $s4
			int newFVel; // $s0
			int newZVel; // $s1
			int zDiff; // $s1
			int zAccl; // $s3
			int tempFVel; // $v1
			int maxForwardVel; // $s1
			int res; // $s3
	/* end block 1 */
	// End offset: 0x80083B7C
	// End Line: 3241

	/* begin block 2 */
		// Start line: 6605
	/* end block 2 */
	// End Line: 6606

			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_SetVelocityTowardsImpalingObject(struct _Instance *instance /*$s3*/, int checkOrientation /*$s4*/)
int MON_SetVelocityTowardsImpalingObject(struct _Instance *instance, int checkOrientation)
{ // line 3244, offset 0x80083bac
	/* begin block 1 */
		// Start line: 3245
		// Start offset: 0x80083BAC
		// Variables:
			struct Level *level; // $s0
			struct Intro *currentI; // $s1
			struct _HPrim *usePrim; // $v0
			int i; // $s2
			_Position spherePos; // stack offset -32

		/* begin block 1.1 */
			// Start line: 3259
			// Start offset: 0x80083C04
			// Variables:
				struct _Instance *target; // $s0

			/* begin block 1.1.1 */
				// Start line: 3284
				// Start offset: 0x80083CA4
				// Variables:
					struct PhysObProperties *prop; // $v1

				/* begin block 1.1.1.1 */
					// Start line: 3287
					// Start offset: 0x80083CBC
				/* end block 1.1.1.1 */
				// End offset: 0x80083CEC
				// End Line: 3296
			/* end block 1.1.1 */
			// End offset: 0x80083CEC
			// End Line: 3297
		/* end block 1.1 */
		// End offset: 0x80083CFC
		// End Line: 3299
	/* end block 1 */
	// End offset: 0x80083D00
	// End Line: 3303

	/* begin block 2 */
		// Start line: 6905
	/* end block 2 */
	// End Line: 6906
					UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_TurnOffSphereCollisions(struct _Instance *instance /*$a0*/)
void MON_TurnOffSphereCollisions(struct _Instance *instance)
{ // line 3312, offset 0x80083d20
	/* begin block 1 */
		// Start line: 3314
		// Start offset: 0x80083D20
		// Variables:
			int i; // $a0
			struct _HPrim *hprim; // $v1
			struct _HModel *hmodel; // $v1
	/* end block 1 */
	// End offset: 0x80083D74
	// End Line: 3330

	/* begin block 2 */
		// Start line: 7064
	/* end block 2 */
	// End Line: 7065

	/* begin block 3 */
		// Start line: 7065
	/* end block 3 */
	// End Line: 7066

	/* begin block 4 */
		// Start line: 7067
	/* end block 4 */
	// End Line: 7068
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_TurnOnSphereCollisions(struct _Instance *instance /*$a0*/)
void MON_TurnOnSphereCollisions(struct _Instance *instance)
{ // line 3332, offset 0x80083d7c
	/* begin block 1 */
		// Start line: 3334
		// Start offset: 0x80083D7C
		// Variables:
			int i; // $a0
			struct _HPrim *hprim; // $v1
			struct _HModel *hmodel; // $v1
	/* end block 1 */
	// End offset: 0x80083DD0
	// End Line: 3350

	/* begin block 2 */
		// Start line: 7106
	/* end block 2 */
	// End Line: 7107

	/* begin block 3 */
		// Start line: 7107
	/* end block 3 */
	// End Line: 7108

	/* begin block 4 */
		// Start line: 7109
	/* end block 4 */
	// End Line: 7110
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_ProcessSpecialFade(struct _Instance *instance /*$s0*/)
void MON_ProcessSpecialFade(struct _Instance *instance)
{ // line 3352, offset 0x80083dd8
	/* begin block 1 */
		// Start line: 3353
		// Start offset: 0x80083DD8
		// Variables:
			struct _MonsterVars *mv; // $a0
			int currentFadeValue; // $a1
			int targetFadeValue; // $v1
			int fadeRate; // $a3
			struct _Instance *child; // $v1
	/* end block 1 */
	// End offset: 0x80084004
	// End Line: 3447

	/* begin block 2 */
		// Start line: 7148
	/* end block 2 */
	// End Line: 7149
			UNIMPLEMENTED();
}


void MON_StartSpecialFade(struct _Instance* instance, int fadeLevel, int fadeTime)  // Matching - 100%
{
	struct _MonsterVars* mv;
	int diff;

	mv = (struct _MonsterVars*)instance->extraData;

	mv->targetFade = fadeLevel;
	mv->auxFlags |= 0x8000000;

	diff = fadeLevel - instance->fadeValue;

	if (fadeTime <= 0)
	{
		fadeTime = 1;
	}

	mv->fadeRate = diff / fadeTime;

	if (((diff / fadeTime) << 16) == 0)
	{
		if (diff < 0)
		{
			mv->fadeRate = -1;
			return;
		}

		mv->fadeRate = 1;
	}

}


void MON_UnlinkFromRaziel(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct evPositionData* data;
	struct _Instance* enemy;

	mv = (struct _MonsterVars*)instance->extraData;
	enemy = mv->enemy->instance;
	INSTANCE_UnlinkFromParent(instance);
	MON_SwitchState(instance, MONSTER_STATE_FALL);
	data = (struct evPositionData*)INSTANCE_Query(enemy, 7);
	if (data != NULL)
	{
		instance->rotation.x = data->x;
		instance->rotation.y = data->y;
		instance->rotation.z = data->z + 2048;
	}
	INSTANCE_Post(enemy, 0x1000006, (int)instance);
}

// autogenerated function stub: 
// void /*$ra*/ MON_BurnInAir(struct _Instance *instance /*$s1*/, int currentState /*$s2*/)
void MON_BurnInAir(struct _Instance *instance, int currentState)
{ // line 3491, offset 0x8008411c
	/* begin block 1 */
		// Start line: 3492
		// Start offset: 0x8008411C
		// Variables:
			struct _MonsterVars *mv; // $s0
	/* end block 1 */
	// End offset: 0x8008419C
	// End Line: 3502

	/* begin block 2 */
		// Start line: 7436
	/* end block 2 */
	// End Line: 7437
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_BirthMana(struct _Instance *instance /*$s0*/)
void MON_BirthMana(struct _Instance *instance)
{ // line 3508, offset 0x800841d8
	/* begin block 1 */
		// Start line: 3509
		// Start offset: 0x800841D8

		/* begin block 1.1 */
			// Start line: 3512
			// Start offset: 0x800841F8
			// Variables:
				struct _MonsterVars *mv; // $v0

			/* begin block 1.1.1 */
				// Start line: 3516
				// Start offset: 0x80084214
				// Variables:
					int type; // $a0
					MATRIX *mat; // $a3
			/* end block 1.1.1 */
			// End offset: 0x80084280
			// End Line: 3519
		/* end block 1.1 */
		// End offset: 0x80084280
		// End Line: 3520
	/* end block 1 */
	// End offset: 0x80084280
	// End Line: 3521

	/* begin block 2 */
		// Start line: 7472
	/* end block 2 */
	// End Line: 7473
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_SoulSucked(struct _Instance *instance /*$s1*/)
void MON_SoulSucked(struct _Instance *instance)
{ // line 3523, offset 0x80084290
	/* begin block 1 */
		// Start line: 3524
		// Start offset: 0x80084290
		// Variables:
			struct _MonsterVars *mv; // $s0
	/* end block 1 */
	// End offset: 0x800842F4
	// End Line: 3535

	/* begin block 2 */
		// Start line: 7505
	/* end block 2 */
	// End Line: 7506
			UNIMPLEMENTED();
}


int MON_SetUpKnockBack(struct _Instance* instance, struct _Instance* enemy, struct evMonsterHitData* data)  // Matching - 100%
{
	struct _MonsterVars* mv;
	long d;
	long t;
	long a;
	long v;
	int front;

	mv = (struct _MonsterVars*)instance->extraData;
	d = data->knockBackDistance;
	t = data->knockBackDuration;
	a = PHYSICS_FindAFromDAndT(d, t);
	v = PHYSICS_FindVFromAAndD(a, d);
	if (((((unsigned short)instance->rotation.z - MATH3D_AngleFromPosToPos(&instance->position, &enemy->position)) + 1024) & 0xFFF) <= 2047)
	{
		MON_TurnToPosition(instance, &enemy->position, 4096);
		PHYSICS_SetVAndAFromRot(instance, &instance->rotation, -v, a);
		front = 1;
	}
	else
	{
		PHYSICS_SetVAndAFromRot(instance, &instance->rotation, v, -a);
		front = 0;
	}
	mv->generalTimer = MON_GetTime(instance) + t * 33;
	return front;
}


// autogenerated function stub: 
// void /*$ra*/ MON_DoDrainEffects(struct _Instance *instance /*$s1*/, struct _Instance *ei /*$s0*/)
void MON_DoDrainEffects(struct _Instance *instance, struct _Instance *ei)
{ // line 3575, offset 0x8008440c
	/* begin block 1 */
		// Start line: 3576
		// Start offset: 0x8008440C
		// Variables:
			struct _MonsterAttributes *ma; // $s3
			struct _MonsterVars *mv; // $s2
			MATRIX *mat; // $t2
			struct _SVector location; // stack offset -56
			struct _SVector position; // stack offset -48
			struct _SVector vel; // stack offset -40
			struct _SVector accel; // stack offset -32
	/* end block 1 */
	// End offset: 0x8008467C
	// End Line: 3621

	/* begin block 2 */
		// Start line: 7610
	/* end block 2 */
	// End Line: 7611
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_SetFXHitData(struct _Instance *instance /*$a0*/, struct evFXHitData *data /*$a1*/, int type /*$a2*/, int amount /*$a3*/)
void MON_SetFXHitData(struct _Instance *instance, struct evFXHitData *data, int type, int amount)
{ // line 3623, offset 0x80084698
	/* begin block 1 */
		// Start line: 3625
		// Start offset: 0x80084698

		/* begin block 1.1 */
			// Start line: 3629
			// Start offset: 0x800846B0
			// Variables:
				MATRIX *mat; // $v0
		/* end block 1.1 */
		// End offset: 0x800846B0
		// End Line: 3629
	/* end block 1 */
	// End offset: 0x80084714
	// End Line: 3640

	/* begin block 2 */
		// Start line: 7778
	/* end block 2 */
	// End Line: 7779

	/* begin block 3 */
		// Start line: 7779
	/* end block 3 */
	// End Line: 7780
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_LaunchMonster(struct _Instance *instance /*$s0*/, int zDirection /*$s1*/, int power /*$s2*/, int loft /*$s3*/)
void MON_LaunchMonster(struct _Instance *instance, int zDirection, int power, int loft)
{ // line 3645, offset 0x80084724
	/* begin block 1 */
		// Start line: 7822
	/* end block 1 */
	// End Line: 7823
	UNIMPLEMENTED();
}




