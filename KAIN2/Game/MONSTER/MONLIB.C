#include "Game/CORE.H"
#include "MONLIB.H"
#include "Game/PHYSICS.H"
#include "Game/G2/ANIMG2.H"
#include "Game/MATH3D.H"
#include "Game/PLAN/ENMYPLAN.H"
#include "Game/EVENT.H"
#include <Game/STATE.H>
#include "Game/G2/ANMG2ILF.H"

void MON_TurnOffWeaponSpheres(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	if (instance->LinkChild != NULL)
	{
		struct _Instance* weapon;

		for (weapon = instance->LinkChild; weapon != NULL; weapon = weapon->LinkSibling)
		{
			TurnOffCollisionPhysOb(weapon, 3);
		}
	}

	if (mv->mvFlags & 0x4000)
	{
		int i;
		struct _HPrim* hprim;
		struct _HModel* hmodel;

		hmodel = instance->hModelList + instance->currentModel;
		hprim = hmodel->hPrimList;
		for (i = hmodel->numHPrims; i != 0; i--, hprim++)
		{
			if ((hprim->type == 1) && (hprim->data.hsphere->id == 9))
			{
				hprim->hpFlags &= ~1;
			}
		}
		mv->mvFlags &= ~0x4000;
	}
}


void MON_TurnOnWeaponSpheres(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	int i;
	struct _HPrim* hprim;
	struct _HModel* hmodel;

	mv = (struct _MonsterVars*)instance->extraData;
	if (!(mv->mvFlags & 0x4000) && (instance->hModelList != NULL))
	{
		hmodel = instance->hModelList + instance->currentModel;
		hprim = hmodel->hPrimList;
		for (i = hmodel->numHPrims; i != 0; i--, hprim++)
		{
			if ((hprim->type == 1) && (hprim->data.hsphere->id == 9))
			{
				hprim->hpFlags |= 1;
				break;
			}
		}
		mv->mvFlags |= 0x4000;
	}
}


// autogenerated function stub: 
// void /*$ra*/ MON_TurnOnWeaponSphere(struct _Instance *instance /*$a0*/, int segment /*$a1*/)
void MON_TurnOnWeaponSphere(struct _Instance *instance, int segment)
{ // line 198, offset 0x8007f594
	/* begin block 1 */
		// Start line: 199
		// Start offset: 0x8007F594
		// Variables:
			struct _MonsterVars *mv; // $s0

		/* begin block 1.1 */
			// Start line: 204
			// Start offset: 0x8007F5B0
			// Variables:
				struct _Instance *weapon; // $v0
		/* end block 1.1 */
		// End offset: 0x8007F5C0
		// End Line: 208

		/* begin block 1.2 */
			// Start line: 214
			// Start offset: 0x8007F5F8
			// Variables:
				int i; // $a2
				struct _HPrim *hprim; // $a0
				struct _HModel *hmodel; // $v0
		/* end block 1.2 */
		// End offset: 0x8007F68C
		// End Line: 223
	/* end block 1 */
	// End offset: 0x8007F68C
	// End Line: 224

	/* begin block 2 */
		// Start line: 404
	/* end block 2 */
	// End Line: 405
				UNIMPLEMENTED();
}


void MON_TurnOffBodySpheres(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	int i;
	struct _HPrim* hprim;
	struct _HModel* hmodel;

	mv = (struct _MonsterVars*)instance->extraData;
	if (mv->mvFlags & 0x8000)
	{
		hmodel = instance->hModelList + instance->currentModel;
		hprim = hmodel->hPrimList;
		for (i = hmodel->numHPrims; i != 0; i--, hprim++)
		{
			if ((hprim->type == 1) && (hprim->data.hsphere->id == 8))
			{
				hprim->hpFlags &= 0xFE;
			}
		}
		mv->mvFlags &= 0xFFFF7FFF;
	}
}


void MON_TurnOnBodySpheres(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	int i;
	struct _HPrim* hprim;
	struct _HModel* hmodel;

	mv = (struct _MonsterVars*)instance->extraData;
	if (!(mv->mvFlags & 0x8000) && (instance->hModelList != NULL))
	{
		hmodel = instance->hModelList + instance->currentModel;
		hprim = hmodel->hPrimList;
		for (i = hmodel->numHPrims; i != 0; i--, hprim++)
		{
			if ((hprim->type == 1) && (hprim->data.hsphere->id == 8))
			{
				hprim->hpFlags |= 1;
			}
		}
		mv->mvFlags |= 0x8000;
	}
}

void MON_TurnOffAllSpheres(struct _Instance* instance)
{
	MON_TurnOffWeaponSpheres(instance);

	MON_TurnOffBodySpheres(instance);
}

void MON_TurnOnAllSpheres(struct _Instance* instance)
{
	MON_TurnOnWeaponSpheres(instance);

	MON_TurnOnBodySpheres(instance);
}


void MON_SwitchState(struct _Instance* instance, enum MonsterState state)  // Matching - 100%
{
	struct _MonsterVars* mv;
	int temp;  // not from SYMDUMP

	mv = (struct _MonsterVars*)instance->extraData;
	if (mv->mvFlags & 0x4000)
	{
		MON_TurnOffWeaponSpheres(instance);
	}
	if (!(mv->mvFlags & 1))
	{
		mv->previousMainState = (char)instance->currentMainState;
	}
	if ((state == MONSTER_STATE_GENERALDEATH) || (state == MONSTER_STATE_DEAD) || (state == MONSTER_STATE_IMPALEDEATH) || (state == MONSTER_STATE_GRABBED))
	{
		PurgeMessageQueue(&mv->messageQueue);
	}
	else
	{
		if (state == MONSTER_STATE_MISSILEHIT)
		{
			PurgeMessageQueue(&mv->messageQueue);
		}
	}
	instance->currentMainState = state;
	mv->mvFlags |= 1;
	mv->mvFlags &= ~0x1000;
	mv->mvFlags &= ~0x20000;
	mv->mvFlags &= ~0x40000000;
	mv->mvFlags &= ~0x4000000;
	temp = -1;
	if ((signed char)mv->pathSlotID != temp)
	{
		ENMYPLAN_ReleasePlanningWorkspace((signed char)mv->pathSlotID);
		mv->pathSlotID = temp;
	}
}


// autogenerated function stub: 
// void /*$ra*/ MON_SwitchStateDoEntry(struct _Instance *instance /*$s1*/, enum MonsterState state /*$a1*/)
void MON_SwitchStateDoEntry(struct _Instance *instance, enum MonsterState state)
{ // line 360, offset 0x8007f94c
	UNIMPLEMENTED();
}

int MON_TransNodeAnimation(struct _Instance* instance)
{
	return G2Anim_SegmentHasActiveChannels(&instance->anim, 0, 0x700);
}

struct _MonsterAnim* MON_GetAnim(struct _Instance* instance, char* animList, int index)
{
	int whichAnim;

	whichAnim = animList[index];

	if (whichAnim != -1)
	{
		return ((struct _MonsterAttributes*)instance->data)->animList + whichAnim;
	}

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_PlayAnimID(struct _Instance *instance /*$s3*/, int index /*$a1*/, int mode /*$fp*/)
void MON_PlayAnimID(struct _Instance *instance, int index, int mode)
{ // line 409, offset 0x8007fa10
	UNIMPLEMENTED();
}

void MON_PlayAnimFromList(struct _Instance* instance, char* animList, int animtype, int mode)
{
	MON_PlayAnimID(instance, animList[animtype], mode);
}

int MON_AnimIDPlaying(struct _Instance* instance, int index)
{
	//index <<= 4
	//v0 = instance->data
	//a0 = instance->extraData
	//v1 = ((struct _MonsterAttributes*)instance->data)[index].
	UNIMPLEMENTED();
	return 0;
	UNIMPLEMENTED();//structs need detecting for this!
}

void MON_PlayAnimIDIfNotPlaying(struct _Instance* instance, int index, int mode)
{
	if (!MON_AnimIDPlaying(instance, index))
	{
		MON_PlayAnimID(instance, index, mode);
	}
}

int MON_AnimPlayingFromList(struct _Instance* instance, char* animList, int animtype)
{
	return MON_AnimIDPlaying(instance, animList[animtype]);
}

void MON_PlayAnimFromListIfNotPlaying(struct _Instance* instance, char* animList, int animtype, int mode)//Matching - 90.45%
{
	int index;

	index = animList[animtype];

	if (MON_AnimIDPlaying(instance, index) == 0)
	{
		MON_PlayAnimID(instance, index, mode);
	}
}

void MON_PlayAnim(struct _Instance* instance, enum MonsterAnim animtype, int mode)
{
	MON_PlayAnimFromList(instance, ((struct _MonsterVars*)instance->extraData)->subAttr->animList, animtype, mode);
}

int MON_AnimPlaying(struct _Instance* instance, enum MonsterAnim animtype)
{
	return MON_AnimPlayingFromList(instance, ((struct _MonsterVars*)instance->extraData)->subAttr->animList, animtype);
}

void MON_PlayAnimIfNotPlaying(struct _Instance* instance, enum MonsterAnim animtype, int mode)
{
	MON_PlayAnimFromListIfNotPlaying(instance, ((struct _MonsterVars*)instance->extraData)->subAttr->animList, animtype, mode);
}


// autogenerated function stub: 
// long /*$ra*/ MON_AnimCallback(struct _G2Anim_Type *anim /*$a0*/, int sectionID /*$a1*/, enum _G2AnimCallbackMsg_Enum message /*$a2*/, long messageDataA /*$s0*/, long messageDataB /*stack 16*/, void *data /*stack 20*/)
long MON_AnimCallback(struct _G2Anim_Type *anim, int sectionID, enum _G2AnimCallbackMsg_Enum message, long messageDataA, long messageDataB, void *data)
{ // line 566, offset 0x8007fd80
	/* begin block 1 */
		// Start line: 567
		// Start offset: 0x8007FD80
		// Variables:
			struct _Instance *instance; // $a3
			struct _MonsterVars *mv; // $t0
	/* end block 1 */
	// End offset: 0x8007FE1C
	// End Line: 591

	/* begin block 2 */
		// Start line: 1132
	/* end block 2 */
	// End Line: 1133
			UNIMPLEMENTED();
	return 0;
}


void MON_AnimInit(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _G2AnimSection_Type* animSection;
	int i;
	int startSection;
	int numSections;
	int sectionEnd;

	mv = (struct _MonsterVars*)instance->extraData;
	numSections = mv->subAttr->numSections;
	mv->anim = NULL;
	G2EmulationInstanceSetTotalSections(instance, numSections);

	startSection = 0;
	for (i = 0; i < numSections; i++)
	{
		sectionEnd = mv->subAttr->sectionEnd[i];
		animSection = &instance->anim.section[i];

		if (sectionEnd == 0)
		{
			G2EmulationInstanceSetStartAndEndSegment(instance, i, startSection, (short)instance->object->modelList[instance->currentModel]->numSegments - 1);
		}
		else
		{
			G2EmulationInstanceSetStartAndEndSegment(instance, i, startSection, sectionEnd);
			startSection = mv->subAttr->sectionEnd[i] + 1;
		}
		G2AnimSection_SetInterpInfo(animSection, &mv->interpInfo[i]);
		G2EmulationInstanceSetAnimation(instance, i, 0, 0, 0);
		G2EmulationInstanceSetMode(instance, i, 2);
	}
	G2EmulationInstanceInitSection(instance, 0, MON_AnimCallback, instance);
	MON_PlayRandomIdle(instance, 2);
}

short MON_FacingOffset(struct _Instance* instance, struct _Instance* target)
{
	return MATH3D_AngleFromPosToPos(&target->position, &instance->position) - target->rotation.z;
}


// autogenerated function stub: 
// int /*$ra*/ MON_CheckConditions(struct _Instance *instance /*$a0*/, struct _MonsterIR *mir /*$a1*/, char *probArray /*$a2*/)
int MON_CheckConditions(struct _Instance *instance, struct _MonsterIR *mir, char *probArray)
{ // line 651, offset 0x8007ffe4
	/* begin block 1 */
		// Start line: 653
		// Start offset: 0x8007FFE4
		// Variables:
			struct _MonsterVars *mv; // $v0
			char *probability; // $a2
			int chance; // $a1
			int i; // $t1
			int prob; // $a3
			int nprob; // $t0

		/* begin block 1.1 */
			// Start line: 663
			// Start offset: 0x80080014
			// Variables:
				int conditionProb; // $v0
		/* end block 1.1 */
		// End offset: 0x80080078
		// End Line: 674
	/* end block 1 */
	// End offset: 0x80080088
	// End Line: 677

	/* begin block 2 */
		// Start line: 1341
	/* end block 2 */
	// End Line: 1342

	/* begin block 3 */
		// Start line: 1342
	/* end block 3 */
	// End Line: 1343

	/* begin block 4 */
		// Start line: 1346
	/* end block 4 */
	// End Line: 1347
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIAttackInstance(struct _Instance *instance /*$s2*/, struct _Instance *ei /*$s0*/)
int MON_ShouldIAttackInstance(struct _Instance *instance, struct _Instance *ei)
{ // line 695, offset 0x800800bc
	/* begin block 1 */
		// Start line: 696
		// Start offset: 0x800800BC

		/* begin block 1.1 */
			// Start line: 699
			// Start offset: 0x800800E4
			// Variables:
				struct _Instance *enemyAttackee; // $s1
				long mode; // $v1
				struct _MonsterVars *mv; // $s3

			/* begin block 1.1.1 */
				// Start line: 713
				// Start offset: 0x80080180
			/* end block 1.1.1 */
			// End offset: 0x800801C0
			// End Line: 719
		/* end block 1.1 */
		// End offset: 0x800801C0
		// End Line: 720
	/* end block 1 */
	// End offset: 0x800801C4
	// End Line: 723

	/* begin block 2 */
		// Start line: 1454
	/* end block 2 */
	// End Line: 1455

	/* begin block 3 */
		// Start line: 1455
	/* end block 3 */
	// End Line: 1456
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIAttack(struct _Instance *instance /*$s3*/, struct _MonsterIR *enemy /*$s1*/, struct _MonsterAttackAttributes *attack /*$s0*/)
int MON_ShouldIAttack(struct _Instance *instance, struct _MonsterIR *enemy, struct _MonsterAttackAttributes *attack)
{ // line 731, offset 0x800801e0
	/* begin block 1 */
		// Start line: 732
		// Start offset: 0x800801E0
		// Variables:
			struct _MonsterVars *mv; // $s4
			int rv; // $a0
			struct _Instance *ei; // $s2

		/* begin block 1.1 */
			// Start line: 751
			// Start offset: 0x8008024C
			// Variables:
				long distance; // $v1
		/* end block 1.1 */
		// End offset: 0x80080364
		// End Line: 803
	/* end block 1 */
	// End offset: 0x80080368
	// End Line: 809

	/* begin block 2 */
		// Start line: 1527
	/* end block 2 */
	// End Line: 1528
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// struct _MonsterAttackAttributes * /*$ra*/ MON_ChooseAttack(struct _Instance *instance /*$a0*/, struct _MonsterIR *enemy /*$a1*/)
struct _MonsterAttackAttributes * MON_ChooseAttack(struct _Instance *instance, struct _MonsterIR *enemy)
{ // line 818, offset 0x80080388
	/* begin block 1 */
		// Start line: 820
		// Start offset: 0x80080388
		// Variables:
			struct _MonsterVars *mv; // $t1
			struct _MonsterAttackAttributes *bestAttack; // $t5
			struct _MonsterAttributes *ma; // $t6
			struct _MonsterCombatAttributes *combat; // $t0
			long distance; // $t3
			long zdiff; // $t2
			long smallest; // $t4
			int i; // $a3
			char *attackIndex; // $t0

		/* begin block 1.1 */
			// Start line: 850
			// Start offset: 0x8008042C
			// Variables:
				struct _MonsterAttackAttributes *attack; // $a2
				long delta; // $a0
		/* end block 1.1 */
		// End offset: 0x800804CC
		// End Line: 864
	/* end block 1 */
	// End offset: 0x800804D8
	// End Line: 869

	/* begin block 2 */
		// Start line: 1705
	/* end block 2 */
	// End Line: 1706

	/* begin block 3 */
		// Start line: 1706
	/* end block 3 */
	// End Line: 1707

	/* begin block 4 */
		// Start line: 1707
	/* end block 4 */
	// End Line: 1708
				UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIEvade(struct _Instance *instance /*$s1*/)
int MON_ShouldIEvade(struct _Instance *instance)
{ // line 878, offset 0x800804e8
	/* begin block 1 */
		// Start line: 879
		// Start offset: 0x800804E8
		// Variables:
			struct _MonsterVars *mv; // $s0
			int rv; // $s3

		/* begin block 1.1 */
			// Start line: 886
			// Start offset: 0x80080520
			// Variables:
				struct _MonsterIR *enemy; // $s2
		/* end block 1.1 */
		// End offset: 0x80080574
		// End Line: 899
	/* end block 1 */
	// End offset: 0x80080574
	// End Line: 903

	/* begin block 2 */
		// Start line: 1869
	/* end block 2 */
	// End Line: 1870
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ChooseLeftOrRight(struct _Instance *instance /*$s0*/, struct _MonsterIR *enemy /*$a1*/)
int MON_ChooseLeftOrRight(struct _Instance *instance, struct _MonsterIR *enemy)
{ // line 913, offset 0x80080594
	/* begin block 1 */
		// Start line: 914
		// Start offset: 0x80080594

		/* begin block 1.1 */
			// Start line: 923
			// Start offset: 0x800805D4
			// Variables:
				int leftDist; // $s0
				int rightDist; // $v1
		/* end block 1.1 */
		// End offset: 0x80080628
		// End Line: 932
	/* end block 1 */
	// End offset: 0x80080628
	// End Line: 933

	/* begin block 2 */
		// Start line: 1940
	/* end block 2 */
	// End Line: 1941
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ChooseEvadeMove(struct _Instance *instance /*$a0*/)
int MON_ChooseEvadeMove(struct _Instance *instance)
{ // line 935, offset 0x80080638
	/* begin block 1 */
		// Start line: 936
		// Start offset: 0x80080638
		// Variables:
			int anim; // $v0
			struct _MonsterVars *mv; // $v0
			int leftOrRight; // $v1
	/* end block 1 */
	// End offset: 0x80080684
	// End Line: 964

	/* begin block 2 */
		// Start line: 1989
	/* end block 2 */
	// End Line: 1990
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ChooseCombatMove(struct _Instance *instance /*$s2*/, int reason /*$a1*/)
int MON_ChooseCombatMove(struct _Instance *instance, int reason)
{ // line 969, offset 0x80080694
	/* begin block 1 */
		// Start line: 970
		// Start offset: 0x80080694
		// Variables:
			struct _MonsterVars *mv; // $s3
			struct _MonsterSubAttributes *subAttr; // $s4
			int anim; // $s1
			int data; // $v0
			struct _MonsterIR *enemy; // $s0
			int infront; // $a0
			struct _MonsterAnim *manim; // $s0

		/* begin block 1.1 */
			// Start line: 1032
			// Start offset: 0x80080748

			/* begin block 1.1.1 */
				// Start line: 1036
				// Start offset: 0x80080768
				// Variables:
					int dir; // $v0
			/* end block 1.1.1 */
			// End offset: 0x800807B0
			// End Line: 1045
		/* end block 1.1 */
		// End offset: 0x800807C8
		// End Line: 1068

		/* begin block 1.2 */
			// Start line: 1072
			// Start offset: 0x800807D0
			// Variables:
				short zrot; // $s0

			/* begin block 1.2.1 */
				// Start line: 1108
				// Start offset: 0x800808C0
				// Variables:
					_Position temp; // stack offset -56
					SVECTOR New; // stack offset -48
					VECTOR OutTrans; // stack offset -40
			/* end block 1.2.1 */
			// End offset: 0x800809E0
			// End Line: 1148
		/* end block 1.2 */
		// End offset: 0x80080AB8
		// End Line: 1173
	/* end block 1 */
	// End offset: 0x80080AB8
	// End Line: 1177

	/* begin block 2 */
		// Start line: 2057
	/* end block 2 */
	// End Line: 2058
					UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_PlayRandomIdle(struct _Instance *instance /*$s4*/, int mode /*$s5*/)
void MON_PlayRandomIdle(struct _Instance *instance, int mode)
{ // line 1185, offset 0x80080adc
	/* begin block 1 */
		// Start line: 1186
		// Start offset: 0x80080ADC
		// Variables:
			struct _MonsterVars *mv; // $s3
			struct _MonsterAttributes *ma; // $s2
			struct _MonsterBehavior *behavior; // $s0
			struct _MonsterIdle *idle; // $s1
			int chance; // $a2
			int i; // $a0
			char *idleIndex; // $a1
	/* end block 1 */
	// End offset: 0x80080C5C
	// End Line: 1244

	/* begin block 2 */
		// Start line: 2527
	/* end block 2 */
	// End Line: 2528
			UNIMPLEMENTED();
}

void MON_PlayCombatIdle(struct _Instance* instance, int mode)
{
	int anim;

	if ((((struct _MonsterVars*)instance->extraData)->mvFlags & 0x10))
	{
		anim = 11;
	}
	else
	{
		anim = 10;
	}

	MON_PlayAnimIfNotPlaying(instance, (enum MonsterAnim)anim, mode);
}


// autogenerated function stub: 
// void /*$ra*/ MON_GetRandomPoint(_Position *out /*$s2*/, _Position *in /*$s1*/, short r /*$a2*/)
void MON_GetRandomPoint(_Position *out, _Position *in, short r)
{ // line 1290, offset 0x80080cc0
	/* begin block 1 */
		// Start line: 1291
		// Start offset: 0x80080CC0
		// Variables:
			int ang; // $s0
	/* end block 1 */
	// End offset: 0x80080CC0
	// End Line: 1291

	/* begin block 2 */
		// Start line: 2580
	/* end block 2 */
	// End Line: 2581
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ MON_GetRandomDestinationInWorld(struct _Instance *instance /*$s2*/, _Position *in /*$s0*/, short r /*$s4*/)
int MON_GetRandomDestinationInWorld(struct _Instance *instance, _Position *in, short r)
{ // line 1307, offset 0x80080d6c
	/* begin block 1 */
		// Start line: 1308
		// Start offset: 0x80080D6C

		/* begin block 1.1 */
			// Start line: 1311
			// Start offset: 0x80080DA0
			// Variables:
				struct _MonsterVars *mv; // $s1
				//struct evPhysicsLOSData data; // stack offset -48
				int result; // $s0
				int avoidEnemy; // $s3

			/* begin block 1.1.1 */
				// Start line: 1322
				// Start offset: 0x80080DDC
			/* end block 1.1.1 */
			// End offset: 0x80080E2C
			// End Line: 1328

			/* begin block 1.1.2 */
				// Start line: 1342
				// Start offset: 0x80080EA8
			/* end block 1.1.2 */
			// End offset: 0x80080EF8
			// End Line: 1348
		/* end block 1.1 */
		// End offset: 0x80080F30
		// End Line: 1357
	/* end block 1 */
	// End offset: 0x80080F34
	// End Line: 1360

	/* begin block 2 */
		// Start line: 2752
	/* end block 2 */
	// End Line: 2753
				UNIMPLEMENTED();
	return 0;
}

void MON_MoveForward(struct _Instance* instance)//Matching - 99.25%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	PhysicsSetVelFromRot(instance, &instance->rotation, mv->speed);

	instance->xAccl = 0;
	instance->yAccl = 0;
	instance->zAccl = 0;

	PhysicsMove(instance, &instance->position, gameTrackerX.timeMult);
}


// autogenerated function stub: 
// int /*$ra*/ MON_TurnToPosition(struct _Instance *instance /*$s1*/, _Position *position /*$a1*/, short turnspeed /*$a2*/)
int MON_TurnToPosition(struct _Instance *instance, _Position *position, short turnspeed)
{ // line 1468, offset 0x80080fa4
	/* begin block 1 */
		// Start line: 1469
		// Start offset: 0x80080FA4
	/* end block 1 */
	// End offset: 0x80080FA4
	// End Line: 1469

	/* begin block 2 */
		// Start line: 2989
	/* end block 2 */
	// End Line: 2990
	UNIMPLEMENTED();
	return 0;
}

void MON_MoveToPosition(struct _Instance* instance, _Position* position, short turnSpeed)
{
	MON_TurnToPosition(instance, position, turnSpeed);

	if (MON_TransNodeAnimation(instance) == 0)
	{
		MON_MoveForward(instance);
	}
}


// autogenerated function stub: 
// int /*$ra*/ MON_OnGround(struct _Instance *instance /*$s0*/)
int MON_OnGround(struct _Instance *instance)
{ // line 1504, offset 0x80081058
	/* begin block 1 */
		// Start line: 1505
		// Start offset: 0x80081058
		// Variables:
			struct _MonsterVars *mv; // $s1
			//struct evPhysicsGravityData data; // stack offset -32
			int minUpper; // $v1
			long xyDist; // $a1
	/* end block 1 */
	// End offset: 0x800810E8
	// End Line: 1532

	/* begin block 2 */
		// Start line: 3069
	/* end block 2 */
	// End Line: 3070
			UNIMPLEMENTED();
	return 0;
}

void MON_ApplyPhysics(struct _Instance* instance)
{
	PhysicsMove(instance, &instance->position, gameTrackerX.timeMult);
}


// autogenerated function stub: 
// void /*$ra*/ MON_ChangeBehavior(struct _Instance *instance /*$a0*/, int behavior /*$s0*/)
void MON_ChangeBehavior(struct _Instance *instance, int behavior)
{ // line 1559, offset 0x8008116c
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_CheckEnvironment(struct _Instance *instance /*$s1*/)
void MON_CheckEnvironment(struct _Instance *instance)
{ // line 1596, offset 0x800811f4
	/* begin block 1 */
		// Start line: 1597
		// Start offset: 0x800811F4
		// Variables:
			struct _MonsterVars *mv; // $s0
			struct _MonsterAttributes *ma; // $s4
			int inwater; // $v0
			struct _SVector Hack; // stack offset -40

		/* begin block 1.1 */
			// Start line: 1637
			// Start offset: 0x80081328
			// Variables:
				int moveback; // $s2
				int onground; // $s3

			/* begin block 1.1.1 */
				// Start line: 1664
				// Start offset: 0x800813D4
				// Variables:
					int offset; // $a1
					//int result; // $v0
					_Position pos; // stack offset -32
			/* end block 1.1.1 */
			// End offset: 0x8008147C
			// End Line: 1684

			/* begin block 1.1.2 */
				// Start line: 1696
				// Start offset: 0x800814B8
				// Variables:
					//int result; // $v0
					//int offset; // $a1
			/* end block 1.1.2 */
			// End offset: 0x80081518
			// End Line: 1712

			/* begin block 1.1.3 */
				// Start line: 1719
				// Start offset: 0x80081520
				// Variables:
					//int result; // $v1
			/* end block 1.1.3 */
			// End offset: 0x8008157C
			// End Line: 1749
		/* end block 1.1 */
		// End offset: 0x800815E4
		// End Line: 1762
	/* end block 1 */
	// End offset: 0x80081608
	// End Line: 1767

	/* begin block 2 */
		// Start line: 3284
	/* end block 2 */
	// End Line: 3285
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_CheckTerrainAndRespond(struct _Instance *instance /*$s1*/, struct BSPTree *bsp /*$a1*/, struct _TFace *tface /*$a2*/)
void MON_CheckTerrainAndRespond(struct _Instance *instance, struct BSPTree *bsp, struct _TFace *tface)
{ // line 1769, offset 0x80081628
	/* begin block 1 */
		// Start line: 1770
		// Start offset: 0x80081628
		// Variables:
			unsigned long results; // $s0
	/* end block 1 */
	// End offset: 0x80081698
	// End Line: 1781

	/* begin block 2 */
		// Start line: 3645
	/* end block 2 */
	// End Line: 3646
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// unsigned long /*$ra*/ MON_CheckTerrain(struct _Instance *instance /*$s2*/, struct BSPTree *bsp /*$s1*/, struct _TFace *tface /*$a2*/)
unsigned long MON_CheckTerrain(struct _Instance *instance, struct BSPTree *bsp, struct _TFace *tface)
{ // line 1786, offset 0x800816ac
	/* begin block 1 */
		// Start line: 1787
		// Start offset: 0x800816AC
		// Variables:
			unsigned long rv; // $s0

		/* begin block 1.1 */
			// Start line: 1793
			// Start offset: 0x800816D0
			// Variables:
				struct Level *level; // $v1
		/* end block 1.1 */
		// End offset: 0x80081750
		// End Line: 1813
	/* end block 1 */
	// End offset: 0x80081750
	// End Line: 1815

	/* begin block 2 */
		// Start line: 3679
	/* end block 2 */
	// End Line: 3680
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_CheckPointSuitability(struct _Instance *instance /*$s2*/, _Position *origin /*$a1*/, _Position *destination /*$s4*/)
int MON_CheckPointSuitability(struct _Instance *instance, _Position *origin, _Position *destination)
{ // line 1824, offset 0x8008176c
	/* begin block 1 */
		// Start line: 1825
		// Start offset: 0x8008176C
		// Variables:
			struct _MonsterVars *mv; // $s1
			int rc; // $s3
			int result; // $a0
			struct evPhysicsDropHeightData *data; // $s0
	/* end block 1 */
	// End offset: 0x80081820
	// End Line: 1851

	/* begin block 2 */
		// Start line: 3761
	/* end block 2 */
	// End Line: 3762
			UNIMPLEMENTED();
	return 0;
}

unsigned long MON_GetTime(struct _Instance* instance)//Matching - 99.29%
{
	if ((instance->object->oflags & 0x80000))
	{
		return (unsigned long)gameTrackerX.currentTime;
	}
	else if ((instance->flags2 & 0x8000000) != 0)
	{
		return gameTrackerX.currentSpectralTime;
	}

	return gameTrackerX.currentMaterialTime;
}


// autogenerated function stub: 
// void /*$ra*/ MON_BirthSoul(struct _Instance *instance /*$s1*/, int link /*$s3*/)
void MON_BirthSoul(struct _Instance *instance, int link)
{ // line 1944, offset 0x80081898
	/* begin block 1 */
		// Start line: 1945
		// Start offset: 0x80081898
		// Variables:
			struct _MonsterVars *mv; // $s2

		/* begin block 1.1 */
			// Start line: 1952
			// Start offset: 0x800818E4
			// Variables:
				struct Object *soulob; // $a1

			/* begin block 1.1.1 */
				// Start line: 1959
				// Start offset: 0x800818F8
				// Variables:
					struct _Instance *isoul; // $s0

				/* begin block 1.1.1.1 */
					// Start line: 1980
					// Start offset: 0x8008195C
					// Variables:
						MATRIX *matrix; // $v1
				/* end block 1.1.1.1 */
				// End offset: 0x80081980
				// End Line: 1984
			/* end block 1.1.1 */
			// End offset: 0x80081988
			// End Line: 1990
		/* end block 1.1 */
		// End offset: 0x80081988
		// End Line: 1993

		/* begin block 1.2 */
			// Start line: 1996
			// Start offset: 0x80081990
			// Variables:
				//struct _Instance *isoul; // $a0
		/* end block 1.2 */
		// End offset: 0x800819E0
		// End Line: 2010
	/* end block 1 */
	// End offset: 0x800819E0
	// End Line: 2012

	/* begin block 2 */
		// Start line: 3923
	/* end block 2 */
	// End Line: 3924

	/* begin block 3 */
		// Start line: 3931
	/* end block 3 */
	// End Line: 3932
						UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_ProcessIntro(struct _Instance *instance /*$s2*/)
void MON_ProcessIntro(struct _Instance *instance)
{ // line 2018, offset 0x800819fc
	/* begin block 1 */
		// Start line: 2019
		// Start offset: 0x800819FC
		// Variables:
			struct _MonsterVars *mv; // $s0
			long initialBehavior; // $s3
			long triggeredBehavior; // $s5
			long activeBehavior; // $s6
			long guardRange; // $s7
			long wanderRange; // $fp
			long ambushRange; // $t1
			long hitPoints; // $s4
			int spectral; // stack offset -56
			long flags; // $s1
			struct _MonsterAttributes *ma; // $v0

		/* begin block 1.1 */
			// Start line: 2039
			// Start offset: 0x80081AA0
			// Variables:
				struct INICommand *command; // $a2

			/* begin block 1.1.1 */
				// Start line: 2093
				// Start offset: 0x80081D14
				// Variables:
					short *pmarker; // $a0
					int i; // $a1
					long *param; // $v1
			/* end block 1.1.1 */
			// End offset: 0x80081D3C
			// End Line: 2108

			/* begin block 1.1.2 */
				// Start line: 2117
				// Start offset: 0x80081D64
				// Variables:
					//int i; // $a0
					short *unit; // $a1
			/* end block 1.1.2 */
			// End offset: 0x80081D9C
			// End Line: 2127
		/* end block 1.1 */
		// End offset: 0x80081E14
		// End Line: 2157
	/* end block 1 */
	// End offset: 0x80081EF8
	// End Line: 2198

	/* begin block 2 */
		// Start line: 4082
	/* end block 2 */
	// End Line: 4083
					UNIMPLEMENTED();
}


void MON_SetDefaults(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _MonsterAttributes* ma;
	struct _MonsterSubAttributes* subAttr;

	mv = (struct _MonsterVars*)instance->extraData;
	ma = (struct _MonsterAttributes*)instance->data;
	if (mv->age >= ma->numSubAttributes)
	{
		mv->age = ma->numSubAttributes - 1;
	}
	subAttr = ma->subAttributesList[mv->age];
	mv->subAttr = subAttr;
	instance->currentModel = subAttr->modelNum;
	instance->scale.x = instance->scale.y = instance->scale.z = subAttr->scale;
	mv->behaviorState = subAttr->defInitialBehavior;
	mv->initialBehavior = subAttr->defInitialBehavior;
	mv->triggeredBehavior = subAttr->defTriggeredBehavior;
	mv->wanderRange = subAttr->defWanderRange;
	mv->guardRange = subAttr->defGuardRange;
	mv->ambushRange = subAttr->defAmbushRange;
	mv->soulJuice = 4096;
	mv->alertness = 3;
	mv->lastSideMove = 8;
	if (subAttr->combatAttributes != NULL)
	{
		mv->hitPoints = (subAttr->combatAttributes->hitPoints) * 256;
		if (subAttr->combatAttributes->missileAttack != -1)
		{
			mv->mvFlags |= 0x20;
		}
	}
	if ((mv->age == 2) && (ma->whatAmI & 2))
	{
		mv->mvFlags |= 0x10000000;
	}
	if (subAttr->defSpectral != 0)
	{
		instance->flags2 |= 0x08000000;
	}
	mv->avoidMask = 0x100;
	if (subAttr->waterVuln != 0)
	{
		mv->avoidMask = 0x110;
	}
	if (subAttr->fireVuln != 0)
	{
		mv->avoidMask |= 0x20;
	}
	if (subAttr->sunVuln != 0)
	{
		mv->avoidMask |= 0x40;
	}
	if (subAttr->soundVuln != 0)
	{
		mv->avoidMask |= 0x200;
	}
	if (subAttr->impaleVuln != 0)
	{
		mv->avoidMask |= 0x80;
	}
}

void MON_GetPlanSlot(struct _MonsterVars* mv)
{
	if (mv->pathSlotID != -1)
	{
		ENMYPLAN_ReleasePlanningWorkspace(mv->pathSlotID);
	}

	mv->pathSlotID = ENMYPLAN_GetInitializedPlanningWorkspaceFinal();
}


// autogenerated function stub: 
// int /*$ra*/ MON_DefaultPlanMovement(struct _Instance *instance /*$s2*/, int anim /*$s4*/, long distance /*$s5*/)
int MON_DefaultPlanMovement(struct _Instance *instance, int anim, long distance)
{ // line 2277, offset 0x8008216c
	/* begin block 1 */
		// Start line: 2278
		// Start offset: 0x8008216C
		// Variables:
			struct _MonsterVars *mv; // $s0
			int rc; // $s1
			int felloff; // $v1
			long length; // $s3
			struct _MonsterAnim *manim; // $s6

		/* begin block 1.1 */
			// Start line: 2307
			// Start offset: 0x80082260
			// Variables:
				_Position pos; // stack offset -40
				int planresult; // $v1

			/* begin block 1.1.1 */
				// Start line: 2348
				// Start offset: 0x80082318
				// Variables:
					short turnSpeed; // $a2
			/* end block 1.1.1 */
			// End offset: 0x80082394
			// End Line: 2365
		/* end block 1.1 */
		// End offset: 0x80082394
		// End Line: 2365
	/* end block 1 */
	// End offset: 0x800823E4
	// End Line: 2389

	/* begin block 2 */
		// Start line: 4771
	/* end block 2 */
	// End Line: 4772
					UNIMPLEMENTED();
	return 0;
}


void MON_DropAllObjects(struct _Instance* instance)  // Matching - 100%
{
	struct _Instance* child;
	struct _Instance* next;

	child = instance->LinkChild;
	while (child != NULL)
	{
		next = child->LinkSibling;
		while (FALSE)
		{

		}
		if (child->ParentLinkNode == 3)
		{
			INSTANCE_Post(child, 0x800008, 2);
		}
		else
		{
			INSTANCE_Post(child, 0x800008, 1);
		}
		child = next;
	}
}


// autogenerated function stub: 
// void /*$ra*/ MON_EnableHeadMove(struct _Instance *instance /*$a0*/)
void MON_EnableHeadMove(struct _Instance *instance)
{ // line 2407, offset 0x8008247c
	/* begin block 1 */
		// Start line: 2408
		// Start offset: 0x8008247C
		// Variables:
			struct _MonsterAttributes *ma; // $s0
	/* end block 1 */
	// End offset: 0x80082510
	// End Line: 2427

	/* begin block 2 */
		// Start line: 5042
	/* end block 2 */
	// End Line: 5043
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_DisableHeadMove(struct _Instance *instance /*$a0*/)
void MON_DisableHeadMove(struct _Instance *instance)
{ // line 2429, offset 0x80082524
	/* begin block 1 */
		// Start line: 2430
		// Start offset: 0x80082524
		// Variables:
			struct _MonsterAttributes *ma; // $s0
	/* end block 1 */
	// End offset: 0x8008259C
	// End Line: 2442

	/* begin block 2 */
		// Start line: 5086
	/* end block 2 */
	// End Line: 5087
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_LookInDirection(struct _Instance *instance /*$a0*/, short tx /*$a1*/, short tz /*$a2*/)
void MON_LookInDirection(struct _Instance *instance, short tx, short tz)
{ // line 2447, offset 0x800825b0
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_LookAtPos(struct _Instance *instance /*$s1*/, _Position *position /*$a1*/)
void MON_LookAtPos(struct _Instance *instance, _Position *position)
{ // line 2478, offset 0x80082724
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_ProcessLookAt(struct _Instance *instance /*$s1*/)
void MON_ProcessLookAt(struct _Instance *instance)
{ // line 2511, offset 0x80082800
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ MON_TakeDamage(struct _Instance *instance /*$a0*/, int damage /*$s2*/, int type /*$s1*/)
int MON_TakeDamage(struct _Instance *instance, int damage, int type)
{ // line 2545, offset 0x800828f4
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_SetUpSaveInfo(struct _Instance *instance /*$t0*/, struct _MonsterSaveInfo *saveData /*$a3*/)
void MON_SetUpSaveInfo(struct _Instance *instance, struct _MonsterSaveInfo *saveData)
{ // line 2582, offset 0x800829a0
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_GetSaveInfo(struct _Instance *instance /*$s1*/, struct _MonsterSaveInfo *saveData /*$s2*/)
void MON_GetSaveInfo(struct _Instance* instance, struct _MonsterSaveInfo* saveData)
{ // line 2616, offset 0x80082b0c
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_KillMonster(struct _Instance *instance /*$s5*/)
void MON_KillMonster(struct _Instance *instance)
{ // line 2694, offset 0x80082d50
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIAmbushEnemy(struct _Instance *instance /*$s3*/)
int MON_ShouldIAmbushEnemy(struct _Instance *instance)
{ // line 2755, offset 0x80082f28
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIFireAtTarget(struct _Instance *instance /*$a0*/, struct _MonsterIR *target /*$a1*/)
int MON_ShouldIFireAtTarget(struct _Instance *instance, struct _MonsterIR *target)
{ // line 2802, offset 0x80083094
	/* begin block 1 */
		// Start line: 2804
		// Start offset: 0x80083094
		// Variables:
			struct _MonsterVars *mv; // $a2

		/* begin block 1.1 */
			// Start line: 2810
			// Start offset: 0x800830C4
			// Variables:
				struct _MonsterAttributes *ma; // $v1
				struct _MonsterMissile *missileAttack; // $a0

			/* begin block 1.1.1 */
				// Start line: 2815
				// Start offset: 0x800830FC
				// Variables:
					long distance; // $a1

				/* begin block 1.1.1.1 */
					// Start line: 2819
					// Start offset: 0x80083114
					// Variables:
						struct _MonsterIR *known; // $v1
				/* end block 1.1.1.1 */
				// End offset: 0x8008317C
				// End Line: 2836
			/* end block 1.1.1 */
			// End offset: 0x8008317C
			// End Line: 2837
		/* end block 1.1 */
		// End offset: 0x8008317C
		// End Line: 2838
	/* end block 1 */
	// End offset: 0x8008317C
	// End Line: 2842

	/* begin block 2 */
		// Start line: 5881
	/* end block 2 */
	// End Line: 5882

	/* begin block 3 */
		// Start line: 5882
	/* end block 3 */
	// End Line: 5883
						UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_ShouldIFlee(struct _Instance *instance /*$a0*/)
int MON_ShouldIFlee(struct _Instance *instance)
{ // line 2847, offset 0x80083184
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_RelocateCoords(struct _Instance *instance /*$a0*/, struct _SVector *offset /*$t0*/)
void MON_RelocateCoords(struct _Instance *instance, struct _SVector *offset)
{ // line 2877, offset 0x80083284
	UNIMPLEMENTED();
}

int MON_ValidUnit(struct _Instance* instance, unsigned long unitId)//Matching - 100%
{
	struct _MonsterVars* mv;
	short* unit;

	mv = (struct _MonsterVars*)instance->extraData;
	unit = &mv->validUnits[0];

	if (!*unit)
	{
		return 1;
	}

	while (*unit)
	{
		if (unitId == *(unsigned short*)unit++)
		{
			return 1;
		}
	}

	return 0;
}

int MON_ValidPosition(struct _Instance* instance)
{
	struct _MonsterVars* mv;

	if (MON_ValidUnit(instance, instance->currentStreamUnitID) != 0)
	{
		mv = (struct _MonsterVars*)instance->extraData;
		mv->lastValidPos = instance->position;
		
		return 1;
	}

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_SphereWorldPos(MATRIX *mat /*$s1*/, struct _HSphere *sphere /*$a1*/, _Position *ret /*$s0*/)
void MON_SphereWorldPos(MATRIX *mat, struct _HSphere *sphere, _Position *ret)
{ // line 2936, offset 0x800833b4
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _HPrim * /*$ra*/ MON_FindSphereForTerrain(struct _Instance *instance /*$a0*/)
struct _HPrim * MON_FindSphereForTerrain(struct _Instance *instance)
{ // line 2945, offset 0x80083424
	UNIMPLEMENTED();
	return NULL;
}


// autogenerated function stub: 
// struct Intro * /*$ra*/ MON_FindNearestImpalingIntro(int unitID /*$a0*/, _Position *position /*$s4*/)
struct Intro * MON_FindNearestImpalingIntro(int unitID, _Position *position)
{ // line 2979, offset 0x800834b0
	/* begin block 1 */
		// Start line: 2980
		// Start offset: 0x800834B0
		// Variables:
			struct Intro *current; // $v1
			struct Intro *res; // $s2
			struct Level *level; // $v0
			int min_dist; // $s3
			int dist; // $v1
			int i; // $s1
	/* end block 1 */
	// End offset: 0x800835BC
	// End Line: 3023

	/* begin block 2 */
		// Start line: 6271
	/* end block 2 */
	// End Line: 6272
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// struct Intro * /*$ra*/ MON_TestForTerrainImpale(struct _Instance *instance /*$s0*/, struct _Terrain *terrain /*$s1*/)
struct Intro * MON_TestForTerrainImpale(struct _Instance *instance, struct _Terrain *terrain)
{ // line 3027, offset 0x800835e0
	/* begin block 1 */
		// Start line: 3028
		// Start offset: 0x800835E0
		// Variables:
			struct _MonsterVars *mv; // $v0
			struct Intro *current; // $s1
			struct _HPrim *prim; // $v1
			struct _HSphere *sphere; // $a1
			int i; // $s2
			int radius; // $s3
			_Position spherePos; // stack offset -32
	/* end block 1 */
	// End offset: 0x800836C0
	// End Line: 3070

	/* begin block 2 */
		// Start line: 6385
	/* end block 2 */
	// End Line: 6386
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ MON_MoveInstanceToImpalePoint(struct _Instance *instance /*$s0*/)
void MON_MoveInstanceToImpalePoint(struct _Instance *instance)
{ // line 3072, offset 0x800836dc
	/* begin block 1 */
		// Start line: 3073
		// Start offset: 0x800836DC
		// Variables:
			struct _MonsterVars *mv; // $v1
			struct Intro *impaler; // $t3
			_Position offset; // stack offset -16

		/* begin block 1.1 */
			// Start line: 3097
			// Start offset: 0x80083718
			// Variables:
				short _x0; // $v0
				short _y0; // $v1
				short _z0; // $a2
				short _y1; // $t0
				//short _z1; // $t2
				_Position *_v; // $a3
				//_Position *_v1; // $a1
		/* end block 1.1 */
		// End offset: 0x80083718
		// End Line: 3097

		/* begin block 1.2 */
			// Start line: 3097
			// Start offset: 0x80083718
			// Variables:
				short _x1; // $v1
				//short _y1; // $a2
				//short _z1; // $a3
				struct _Rotation *_v0; // $v0
				//struct _Rotation *_v1; // $v0
		/* end block 1.2 */
		// End offset: 0x80083718
		// End Line: 3097
	/* end block 1 */
	// End offset: 0x800837B0
	// End Line: 3107

	/* begin block 2 */
		// Start line: 6491
	/* end block 2 */
	// End Line: 6492
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ MON_ReachableIntro(struct _Instance *instance /*stack 0*/, _Position *pos /*$fp*/, _Position *introPos /*$s7*/, struct _Rotation *introRot /*stack 12*/, int checkOrientation /*stack 16*/)
int MON_ReachableIntro(struct _Instance *instance, _Position *pos, _Position *introPos, struct _Rotation *introRot, int checkOrientation)
{ // line 3121, offset 0x800837c0
	/* begin block 1 */
		// Start line: 3122
		// Start offset: 0x800837C0
		// Variables:
			struct _MonsterVars *mv; // $s2
			int angle; // $s5
			int angle2; // $s6
			int angle3; // $v1
			int flightAngle; // $v0
			int length; // $v0
			int length2; // $s4
			int newFVel; // $s0
			int newZVel; // $s1
			int zDiff; // $s1
			int zAccl; // $s3
			int tempFVel; // $v1
			int maxForwardVel; // $s1
			int res; // $s3
	/* end block 1 */
	// End offset: 0x80083B7C
	// End Line: 3241

	/* begin block 2 */
		// Start line: 6605
	/* end block 2 */
	// End Line: 6606

			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ MON_SetVelocityTowardsImpalingObject(struct _Instance *instance /*$s3*/, int checkOrientation /*$s4*/)
int MON_SetVelocityTowardsImpalingObject(struct _Instance *instance, int checkOrientation)
{ // line 3244, offset 0x80083bac
	/* begin block 1 */
		// Start line: 3245
		// Start offset: 0x80083BAC
		// Variables:
			struct Level *level; // $s0
			struct Intro *currentI; // $s1
			struct _HPrim *usePrim; // $v0
			int i; // $s2
			_Position spherePos; // stack offset -32

		/* begin block 1.1 */
			// Start line: 3259
			// Start offset: 0x80083C04
			// Variables:
				struct _Instance *target; // $s0

			/* begin block 1.1.1 */
				// Start line: 3284
				// Start offset: 0x80083CA4
				// Variables:
					struct PhysObProperties *prop; // $v1

				/* begin block 1.1.1.1 */
					// Start line: 3287
					// Start offset: 0x80083CBC
				/* end block 1.1.1.1 */
				// End offset: 0x80083CEC
				// End Line: 3296
			/* end block 1.1.1 */
			// End offset: 0x80083CEC
			// End Line: 3297
		/* end block 1.1 */
		// End offset: 0x80083CFC
		// End Line: 3299
	/* end block 1 */
	// End offset: 0x80083D00
	// End Line: 3303

	/* begin block 2 */
		// Start line: 6905
	/* end block 2 */
	// End Line: 6906
					UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MON_TurnOffSphereCollisions(struct _Instance *instance /*$a0*/)
void MON_TurnOffSphereCollisions(struct _Instance *instance)
{ // line 3312, offset 0x80083d20
	/* begin block 1 */
		// Start line: 3314
		// Start offset: 0x80083D20
		// Variables:
			int i; // $a0
			struct _HPrim *hprim; // $v1
			struct _HModel *hmodel; // $v1
	/* end block 1 */
	// End offset: 0x80083D74
	// End Line: 3330

	/* begin block 2 */
		// Start line: 7064
	/* end block 2 */
	// End Line: 7065

	/* begin block 3 */
		// Start line: 7065
	/* end block 3 */
	// End Line: 7066

	/* begin block 4 */
		// Start line: 7067
	/* end block 4 */
	// End Line: 7068
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_TurnOnSphereCollisions(struct _Instance *instance /*$a0*/)
void MON_TurnOnSphereCollisions(struct _Instance *instance)
{ // line 3332, offset 0x80083d7c
	/* begin block 1 */
		// Start line: 3334
		// Start offset: 0x80083D7C
		// Variables:
			int i; // $a0
			struct _HPrim *hprim; // $v1
			struct _HModel *hmodel; // $v1
	/* end block 1 */
	// End offset: 0x80083DD0
	// End Line: 3350

	/* begin block 2 */
		// Start line: 7106
	/* end block 2 */
	// End Line: 7107

	/* begin block 3 */
		// Start line: 7107
	/* end block 3 */
	// End Line: 7108

	/* begin block 4 */
		// Start line: 7109
	/* end block 4 */
	// End Line: 7110
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_ProcessSpecialFade(struct _Instance *instance /*$s0*/)
void MON_ProcessSpecialFade(struct _Instance *instance)
{ // line 3352, offset 0x80083dd8
	/* begin block 1 */
		// Start line: 3353
		// Start offset: 0x80083DD8
		// Variables:
			struct _MonsterVars *mv; // $a0
			int currentFadeValue; // $a1
			int targetFadeValue; // $v1
			int fadeRate; // $a3
			struct _Instance *child; // $v1
	/* end block 1 */
	// End offset: 0x80084004
	// End Line: 3447

	/* begin block 2 */
		// Start line: 7148
	/* end block 2 */
	// End Line: 7149
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_StartSpecialFade(struct _Instance *instance /*$a0*/, int fadeLevel /*$a1*/, int fadeTime /*$a2*/)
void MON_StartSpecialFade(struct _Instance *instance, int fadeLevel, int fadeTime)
{ // line 3449, offset 0x80084014
	/* begin block 1 */
		// Start line: 3451
		// Start offset: 0x80084014
		// Variables:
			struct _MonsterVars *mv; // $a3
			int diff; // $a1
	/* end block 1 */
	// End offset: 0x80084074
	// End Line: 3464

	/* begin block 2 */
		// Start line: 7351
	/* end block 2 */
	// End Line: 7352

	/* begin block 3 */
		// Start line: 7352
	/* end block 3 */
	// End Line: 7353
			UNIMPLEMENTED();
}


void MON_UnlinkFromRaziel(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct evPositionData* data;
	struct _Instance* enemy;

	mv = (struct _MonsterVars*)instance->extraData;
	enemy = mv->enemy->instance;
	INSTANCE_UnlinkFromParent(instance);
	MON_SwitchState(instance, MONSTER_STATE_FALL);
	data = (struct evPositionData*)INSTANCE_Query(enemy, 7);
	if (data != NULL)
	{
		instance->rotation.x = data->x;
		instance->rotation.y = data->y;
		instance->rotation.z = data->z + 2048;
	}
	INSTANCE_Post(enemy, 0x1000006, (int)instance);
}

// autogenerated function stub: 
// void /*$ra*/ MON_BurnInAir(struct _Instance *instance /*$s1*/, int currentState /*$s2*/)
void MON_BurnInAir(struct _Instance *instance, int currentState)
{ // line 3491, offset 0x8008411c
	/* begin block 1 */
		// Start line: 3492
		// Start offset: 0x8008411C
		// Variables:
			struct _MonsterVars *mv; // $s0
	/* end block 1 */
	// End offset: 0x8008419C
	// End Line: 3502

	/* begin block 2 */
		// Start line: 7436
	/* end block 2 */
	// End Line: 7437
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_BirthMana(struct _Instance *instance /*$s0*/)
void MON_BirthMana(struct _Instance *instance)
{ // line 3508, offset 0x800841d8
	/* begin block 1 */
		// Start line: 3509
		// Start offset: 0x800841D8

		/* begin block 1.1 */
			// Start line: 3512
			// Start offset: 0x800841F8
			// Variables:
				struct _MonsterVars *mv; // $v0

			/* begin block 1.1.1 */
				// Start line: 3516
				// Start offset: 0x80084214
				// Variables:
					int type; // $a0
					MATRIX *mat; // $a3
			/* end block 1.1.1 */
			// End offset: 0x80084280
			// End Line: 3519
		/* end block 1.1 */
		// End offset: 0x80084280
		// End Line: 3520
	/* end block 1 */
	// End offset: 0x80084280
	// End Line: 3521

	/* begin block 2 */
		// Start line: 7472
	/* end block 2 */
	// End Line: 7473
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_SoulSucked(struct _Instance *instance /*$s1*/)
void MON_SoulSucked(struct _Instance *instance)
{ // line 3523, offset 0x80084290
	/* begin block 1 */
		// Start line: 3524
		// Start offset: 0x80084290
		// Variables:
			struct _MonsterVars *mv; // $s0
	/* end block 1 */
	// End offset: 0x800842F4
	// End Line: 3535

	/* begin block 2 */
		// Start line: 7505
	/* end block 2 */
	// End Line: 7506
			UNIMPLEMENTED();
}


int MON_SetUpKnockBack(struct _Instance* instance, struct _Instance* enemy, struct evMonsterHitData* data)  // Matching - 100%
{
	struct _MonsterVars* mv;
	long d;
	long t;
	long a;
	long v;
	int front;

	mv = (struct _MonsterVars*)instance->extraData;
	d = data->knockBackDistance;
	t = data->knockBackDuration;
	a = PHYSICS_FindAFromDAndT(d, t);
	v = PHYSICS_FindVFromAAndD(a, d);
	if (((((unsigned short)instance->rotation.z - MATH3D_AngleFromPosToPos(&instance->position, &enemy->position)) + 1024) & 0xFFF) <= 2047)
	{
		MON_TurnToPosition(instance, &enemy->position, 4096);
		PHYSICS_SetVAndAFromRot(instance, &instance->rotation, -v, a);
		front = 1;
	}
	else
	{
		PHYSICS_SetVAndAFromRot(instance, &instance->rotation, v, -a);
		front = 0;
	}
	mv->generalTimer = MON_GetTime(instance) + t * 33;
	return front;
}


// autogenerated function stub: 
// void /*$ra*/ MON_DoDrainEffects(struct _Instance *instance /*$s1*/, struct _Instance *ei /*$s0*/)
void MON_DoDrainEffects(struct _Instance *instance, struct _Instance *ei)
{ // line 3575, offset 0x8008440c
	/* begin block 1 */
		// Start line: 3576
		// Start offset: 0x8008440C
		// Variables:
			struct _MonsterAttributes *ma; // $s3
			struct _MonsterVars *mv; // $s2
			MATRIX *mat; // $t2
			struct _SVector location; // stack offset -56
			struct _SVector position; // stack offset -48
			struct _SVector vel; // stack offset -40
			struct _SVector accel; // stack offset -32
	/* end block 1 */
	// End offset: 0x8008467C
	// End Line: 3621

	/* begin block 2 */
		// Start line: 7610
	/* end block 2 */
	// End Line: 7611
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_SetFXHitData(struct _Instance *instance /*$a0*/, struct evFXHitData *data /*$a1*/, int type /*$a2*/, int amount /*$a3*/)
void MON_SetFXHitData(struct _Instance *instance, struct evFXHitData *data, int type, int amount)
{ // line 3623, offset 0x80084698
	/* begin block 1 */
		// Start line: 3625
		// Start offset: 0x80084698

		/* begin block 1.1 */
			// Start line: 3629
			// Start offset: 0x800846B0
			// Variables:
				MATRIX *mat; // $v0
		/* end block 1.1 */
		// End offset: 0x800846B0
		// End Line: 3629
	/* end block 1 */
	// End offset: 0x80084714
	// End Line: 3640

	/* begin block 2 */
		// Start line: 7778
	/* end block 2 */
	// End Line: 7779

	/* begin block 3 */
		// Start line: 7779
	/* end block 3 */
	// End Line: 7780
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MON_LaunchMonster(struct _Instance *instance /*$s0*/, int zDirection /*$s1*/, int power /*$s2*/, int loft /*$s3*/)
void MON_LaunchMonster(struct _Instance *instance, int zDirection, int power, int loft)
{ // line 3645, offset 0x80084724
	/* begin block 1 */
		// Start line: 7822
	/* end block 1 */
	// End Line: 7823
	UNIMPLEMENTED();
}




