#include "Game/CORE.H"
#include "MONAPI.H"
#include "Game/G2/ANMG2ILF.H"
#include "Game/G2/ANIMG2.H"
#include "Game/MATH3D.H"
#include "Game/SAVEINFO.H"

// autogenerated function stub: 
// void /*$ra*/ MonsterProcess(struct _Instance *instance /*$s1*/, struct GameTracker *gameTracker /*$a1*/)
void MonsterProcess(struct _Instance *instance, struct GameTracker *gameTracker)
{ // line 165, offset 0x8007da80
	/* begin block 1 */
		// Start line: 166
		// Start offset: 0x8007DA80
		// Variables:
			struct _MonsterState *state; // $s0
			struct _MonsterVars *mv; // $s2
			struct _MonsterAttributes *attributes; // $v0
	/* end block 1 */
	// End offset: 0x8007DBA0
	// End Line: 237

	/* begin block 2 */
		// Start line: 330
	/* end block 2 */
	// End Line: 331
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MonsterInit(struct _Instance *instance /*$s0*/, struct GameTracker *gameTracker /*$a1*/)
void MonsterInit(struct _Instance *instance, struct GameTracker *gameTracker)
{ // line 243, offset 0x8007dbb8
	/* begin block 1 */
		// Start line: 244
		// Start offset: 0x8007DBB8
		// Variables:
			struct _MonsterAttributes *attributes; // $s2
			struct _MonsterVars *mv; // $s1

		/* begin block 1.1 */
			// Start line: 262
			// Start offset: 0x8007DC24
		/* end block 1.1 */
		// End offset: 0x8007DC24
		// End Line: 282

		/* begin block 1.2 */
			// Start line: 349
			// Start offset: 0x8007DD7C
		/* end block 1.2 */
		// End offset: 0x8007DDA8
		// End Line: 354
	/* end block 1 */
	// End offset: 0x8007DDA8
	// End Line: 356

	/* begin block 2 */
		// Start line: 491
	/* end block 2 */
	// End Line: 492
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ SendHitObject(struct _Instance *instance /*$s1*/, struct _Instance *hit /*$s0*/, int type /*$s2*/)
void SendHitObject(struct _Instance *instance, struct _Instance *hit, int type)
{ // line 358, offset 0x8007ddc0
	/* begin block 1 */
		// Start line: 359
		// Start offset: 0x8007DDC0
		// Variables:
			struct _MonsterVars *mv; // $a1
			int i; // $a0

		/* begin block 1.1 */
			// Start line: 365
			// Start offset: 0x8007DE10
			// Variables:
				struct evMonsterHitObjectData *data1; // $v0
		/* end block 1.1 */
		// End offset: 0x8007DE28
		// End Line: 368

		/* begin block 1.2 */
			// Start line: 377
			// Start offset: 0x8007DE58
			// Variables:
				struct evMonsterHitObjectData *data; // $v0
		/* end block 1.2 */
		// End offset: 0x8007DE7C
		// End Line: 381
	/* end block 1 */
	// End offset: 0x8007DE7C
	// End Line: 382

	/* begin block 2 */
		// Start line: 732
	/* end block 2 */
	// End Line: 733
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MonsterCollide(struct _Instance *instance /*$s3*/, struct GameTracker *gameTracker /*$a1*/)
void MonsterCollide(struct _Instance *instance, struct GameTracker *gameTracker)
{ // line 388, offset 0x8007de94
	/* begin block 1 */
		// Start line: 389
		// Start offset: 0x8007DE94
		// Variables:
			struct _CollideInfo *collideInfo; // $s1
			struct _MonsterVars *mv; // $s6

		/* begin block 1.1 */
			// Start line: 398
			// Start offset: 0x8007DEE4
			// Variables:
				struct _HSphere *s0; // $v0

			/* begin block 1.1.1 */
				// Start line: 412
				// Start offset: 0x8007DF1C
				// Variables:
					struct _HSphere *s1; // $v0

				/* begin block 1.1.1.1 */
					// Start line: 415
					// Start offset: 0x8007DF34
					// Variables:
						struct _Instance *inst1; // $s4
						int power; // $s0
				/* end block 1.1.1.1 */
				// End offset: 0x8007DFF4
				// End Line: 436
			/* end block 1.1.1 */
			// End offset: 0x8007DFF4
			// End Line: 436

			/* begin block 1.1.2 */
				// Start line: 452
				// Start offset: 0x8007E010
				// Variables:
					int move; // $s7

				/* begin block 1.1.2.1 */
					// Start line: 458
					// Start offset: 0x8007E048
					// Variables:
						struct _HSphere *hsphere; // $s0
				/* end block 1.1.2.1 */
				// End offset: 0x8007E09C
				// End Line: 466

				/* begin block 1.1.2.2 */
					// Start line: 496
					// Start offset: 0x8007E11C
					// Variables:
						struct BSPTree *bsp; // $s4

					/* begin block 1.1.2.2.1 */
						// Start line: 503
						// Start offset: 0x8007E158
						// Variables:
							struct evMonsterHitTerrainData *data; // $s0
							struct Level *level; // $s5
							struct Intro *impaler; // $v0
							struct _TFace *tface; // $s2

						/* begin block 1.1.2.2.1.1 */
							// Start line: 534
							// Start offset: 0x8007E2A0
							// Variables:
							//	struct _CollideInfo parentCI; // stack offset -88
						/* end block 1.1.2.2.1.1 */
						// End offset: 0x8007E30C
						// End Line: 541
					/* end block 1.1.2.2.1 */
					// End offset: 0x8007E330
					// End Line: 545
				/* end block 1.1.2.2 */
				// End offset: 0x8007E334
				// End Line: 550
			/* end block 1.1.2 */
			// End offset: 0x8007E37C
			// End Line: 576
		/* end block 1.1 */
		// End offset: 0x8007E37C
		// End Line: 577
	/* end block 1 */
	// End offset: 0x8007E37C
	// End Line: 581

	/* begin block 2 */
		// Start line: 798
	/* end block 2 */
	// End Line: 799
							UNIMPLEMENTED();
}

void MonsterAdditionalCollide(struct _Instance* instance, struct GameTracker* gameTracker)
{
	if (instance->data != NULL)
	{
		MON_CheckEnvironment(instance);
	}
}


// autogenerated function stub: 
// unsigned long /*$ra*/ MonsterQuery(struct _Instance *instance /*$s1*/, unsigned long query /*$a1*/)
unsigned long MonsterQuery(struct _Instance *instance, unsigned long query)
{ // line 595, offset 0x8007e3d8
	/* begin block 1 */
		// Start line: 596
		// Start offset: 0x8007E3D8
		// Variables:
			struct _MonsterVars *mv; // $a2
			struct _MonsterAttributes *ma; // $s0
			unsigned long ret; // $a0

		/* begin block 1.1 */
			// Start line: 608
			// Start offset: 0x8007E424
			// Variables:
				struct evShadowSegmentData *shadowData; // $v0
		/* end block 1.1 */
		// End offset: 0x8007E424
		// End Line: 609

		/* begin block 1.2 */
			// Start line: 684
			// Start offset: 0x8007E590
			// Variables:
				struct _MonsterSaveInfo *saveInfo; // $s0
		/* end block 1.2 */
		// End offset: 0x8007E590
		// End Line: 684
	/* end block 1 */
	// End offset: 0x8007E624
	// End Line: 707

	/* begin block 2 */
		// Start line: 1228
	/* end block 2 */
	// End Line: 1229

				UNIMPLEMENTED();

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ MonsterMessage(struct _Instance *instance /*$s2*/, unsigned long message /*$s1*/, unsigned long data /*$s3*/)
void MonsterMessage(struct _Instance *instance, unsigned long message, unsigned long data)
{ // line 713, offset 0x8007e638
	/* begin block 1 */
		// Start line: 714
		// Start offset: 0x8007E638
		// Variables:
			struct _MonsterVars *mv; // $s0

		/* begin block 1.1 */
			// Start line: 739
			// Start offset: 0x8007E70C
		/* end block 1.1 */
		// End offset: 0x8007E718
		// End Line: 742

		/* begin block 1.2 */
			// Start line: 767
			// Start offset: 0x8007E80C
		/* end block 1.2 */
		// End offset: 0x8007E80C
		// End Line: 769

		/* begin block 1.3 */
			// Start line: 774
			// Start offset: 0x8007E820
		/* end block 1.3 */
		// End offset: 0x8007E820
		// End Line: 776
	/* end block 1 */
	// End offset: 0x8007E8E4
	// End Line: 815

	/* begin block 2 */
		// Start line: 1467
	/* end block 2 */
	// End Line: 1468
			UNIMPLEMENTED();
}

void AnimDistanceAndVel(struct Object* object, struct _MonsterAnim* mAnim)
{
	struct _G2Anim_Type anim;
	struct _G2AnimSection_Type* animSection;
	struct _G2AnimKeylist_Type* keylist;
	long total;
	struct _G2SVector3_Type dist;

	keylist = object->animList[mAnim->index[0]];

	G2Anim_Init(&anim, object->modelList[0]);

	animSection = &anim.section[0];
	
	animSection->firstSeg = 0;

	animSection->callback = NULL;

	animSection->callbackData = NULL;

	animSection->segCount = object->modelList[0]->numSegments;

	G2AnimSection_SetInterpInfo(animSection, NULL);

	G2AnimSection_SwitchToKeylistAtTime(animSection, keylist, mAnim->index[0], 0);

	if ((G2Anim_SegmentHasActiveChannels(&anim, 0, 0x700)))
	{
		G2Anim_GetRootMotionOverInterval(&anim, 0, G2AnimKeylist_GetDuration(keylist), &dist);
	
		total = MATH3D_FastSqrt0((dist.x * dist.x) + (dist.y * dist.y) + (dist.z * dist.z));
		
		mAnim->distance = total;
	
		mAnim->velocity = ((mAnim->playSpeed * (total * 100)) * 4096) / G2AnimKeylist_GetDuration(keylist);
	}

	G2Anim_Free(&anim);
}

void TranslateAnimList(struct Object* object, struct _MonsterAnim* animList, int numAnims)
{
	int i;
	struct _MonsterAnim* animPtr;
	int index;
	struct _G2AnimKeylist_Type* keylist;

	if (animList != NULL)
	{
		animPtr = animList;

		if (numAnims > 0)
		{
			for (i = 0; i < numAnims; i++)
			{
				index = animPtr[i].index[0];

				keylist = object->animList[index];

				if (index != -1)
				{
					AnimDistanceAndVel(object, &animPtr[i]);

					if (animPtr[i].startFrame >= (G2AnimKeylist_GetDuration(keylist) / 100))
					{
						animPtr[i].startFrame = G2AnimKeylist_GetKeyframeCount(keylist) - 1;
					}
				}
			}
		}
	}
}

void MonsterTranslateAnim(struct Object* object)
{
	struct _MonsterAttributes* attributes;
	int i;
	void* relocModule;
	struct _MonsterAttackAttributes* attackAttr;
	struct _MonsterCombatAttributes* combatAttr;
	int largest;
	int j;
	struct _MonsterAttackAttributes* attack;

	attributes = (struct _MonsterAttributes*)object->data;

	if (!(object->oflags2 & 0x10000000))
	{
		if ((object->oflags & 0x8000000))
		{
			relocModule = object->relocModule;

			if (relocModule != NULL)
			{
#if defined(PSX_VERSION) && defined (PSXPC_VERSION)
				if(0)///@FIXME Bypass version check
#else
				if (((unsigned int*)relocModule)[6] != (unsigned int)"June 30 1999")
#endif
				{
					object->data = NULL;
					return;
				}
			}
		}
		else
		{
			MONTABLE_SetupTablePointer(object);
		}

		if (attributes != NULL && attributes->magicnum == 0xACE00065)
		{
			TranslateAnimList(object, attributes->animList, attributes->numAnims);

			for (i = 0; i < attributes->numAttackAttributes; i++)
			{
				attackAttr = &attributes->attackAttributesList[i];

				if (attackAttr->sphereOnAnim >= attackAttr->numAnims || attackAttr->sphereOffAnim >= attackAttr->numAnims)
				{
					object->data = NULL;
				}
			}

			if (attributes->numCombatAttributes > 0)
			{
				for(i = 0; i < attributes->numCombatAttributes; i++)
				{
					combatAttr = attributes->combatAttributesList[i];

					if (combatAttr->combatRange == 0)
					{
						if (combatAttr->numAttacks > 0)
						{
							largest = 0;

							for (j = 0; j < combatAttr->numAttacks; j++)
							{
								attack = &attributes->attackAttributesList[combatAttr->attackList[j]];

								if (largest < attack->attackRange)
								{
									largest = attack->attackRange;
								}
							}
						}

						combatAttr->combatRange = largest + 200;
					}
				}
			}
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ MonsterRelocateTune(struct Object *object /*$a0*/, long offset /*$a1*/)
void MonsterRelocateTune(struct Object *object, long offset)
{ // line 1171, offset 0x8007ed1c
	/* begin block 1 */
		// Start line: 1173
		// Start offset: 0x8007ED1C
		// Variables:
			struct _MonsterAttributes *attributes; // $t0

		/* begin block 1.1 */
			// Start line: 1177
			// Start offset: 0x8007ED3C
			// Variables:
				int i; // $a3
				struct _MonsterSubAttributes *subAttr; // $a2
				struct _MonsterSubAttributes **pSubAttr; // $t1
				struct _MonsterCombatAttributes **pCombatAttr; // $v0

			/* begin block 1.1.1 */
				// Start line: 1196
				// Start offset: 0x8007EE2C
				// Variables:
					int j; // $v1
					struct _MonsterSubAttributes **oldSubAttr; // $a0
			/* end block 1.1.1 */
			// End offset: 0x8007EEE4
			// End Line: 1217
		/* end block 1.1 */
		// End offset: 0x8007EF30
		// End Line: 1221
	/* end block 1 */
	// End offset: 0x8007EF30
	// End Line: 1222

	/* begin block 2 */
		// Start line: 2498
	/* end block 2 */
	// End Line: 2499

	/* begin block 3 */
		// Start line: 2499
	/* end block 3 */
	// End Line: 2500
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MonsterRelocateInstanceObject(struct _Instance *instance /*$a0*/, long offset /*$a1*/)
void MonsterRelocateInstanceObject(struct _Instance *instance, long offset)
{ // line 1227, offset 0x8007ef38
	/* begin block 1 */
		// Start line: 1229
		// Start offset: 0x8007EF38
		// Variables:
			struct _MonsterVars *mv; // $v0
	/* end block 1 */
	// End offset: 0x8007F054
	// End Line: 1250

	/* begin block 2 */
		// Start line: 2640
	/* end block 2 */
	// End Line: 2641

	/* begin block 3 */
		// Start line: 2641
	/* end block 3 */
	// End Line: 2642
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MONAPI_TurnHead(struct _Instance *instance /*$a0*/, short *rotx /*$a1*/, short *rotz /*$a2*/, struct GameTracker *gameTracker /*$a3*/)
void MONAPI_TurnHead(struct _Instance *instance, short *rotx, short *rotz, struct GameTracker *gameTracker)
{ // line 1299, offset 0x8007f05c
	UNIMPLEMENTED();
}

void MONAPI_SetLookAround(struct _Instance* instance)
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	MON_EnableHeadMove(instance);

	mv->mode = 0x80000;
}

void MONAPI_ResetLookAround(struct _Instance* instance)
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	MON_DisableHeadMove(instance);

	mv->mode = 0x1;
}

long MONAPI_OkToLookAround(struct _Instance* instance)
{
	return instance->currentMainState == 2;
}

void MONAPI_DeleteRegen(struct _MONAPI_Regenerator* regen)//Matching - 88.68%
{
	--GlobalSave->numRegens;
	memcpy(regen, regen + 1, (GlobalSave->numRegens - (regen - GlobalSave->regenEntries)) * sizeof(struct _MONAPI_Regenerator));
}


// autogenerated function stub: 
// void /*$ra*/ MONAPI_ProcessGenerator()
void MONAPI_ProcessGenerator()
{ // line 1354, offset 0x8007f198
	/* begin block 1 */
		// Start line: 1355
		// Start offset: 0x8007F198
		// Variables:
			int i; // $s2
			struct _MONAPI_Regenerator *regen; // $s0

		/* begin block 1.1 */
			// Start line: 1363
			// Start offset: 0x8007F1D8
			// Variables:
				unsigned long time; // $v1

			/* begin block 1.1.1 */
				// Start line: 1372
				// Start offset: 0x8007F20C
				// Variables:
					struct Level *level; // $v0

				/* begin block 1.1.1.1 */
					// Start line: 1375
					// Start offset: 0x8007F220
					// Variables:
						struct Intro *intro; // $a0
						int j; // $a1
						long id; // $a2
				/* end block 1.1.1.1 */
				// End offset: 0x8007F280
				// End Line: 1393
			/* end block 1.1.1 */
			// End offset: 0x8007F288
			// End Line: 1396
		/* end block 1.1 */
		// End offset: 0x8007F2A4
		// End Line: 1404
	/* end block 1 */
	// End offset: 0x8007F2C0
	// End Line: 1406

	/* begin block 2 */
		// Start line: 2848
	/* end block 2 */
	// End Line: 2849

	/* begin block 3 */
		// Start line: 2852
	/* end block 3 */
	// End Line: 2853
						UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MONAPI_AddToGenerator(struct _Instance *instance /*$s2*/)
void MONAPI_AddToGenerator(struct _Instance *instance)
{ // line 1408, offset 0x8007f2d8
	/* begin block 1 */
		// Start line: 1409
		// Start offset: 0x8007F2D8

		/* begin block 1.1 */
			// Start line: 1413
			// Start offset: 0x8007F308
			// Variables:
				struct _MonsterVars *mv; // $s1
				struct _MONAPI_Regenerator *regen; // $s0
		/* end block 1.1 */
		// End offset: 0x8007F360
		// End Line: 1420
	/* end block 1 */
	// End offset: 0x8007F360
	// End Line: 1421

	/* begin block 2 */
		// Start line: 3028
	/* end block 2 */
	// End Line: 3029
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MONAPI_CheckGenerator(struct _Instance *instance /*$a0*/)
void MONAPI_CheckGenerator(struct _Instance* instance)
{ // line 1426, offset 0x8007f378
	UNIMPLEMENTED();
}