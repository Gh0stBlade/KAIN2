#include "Game/CORE.H"
#include "MONAPI.H"
#include "Game/G2/ANMG2ILF.H"
#include "Game/G2/ANIMG2.H"
#include "Game/MATH3D.H"
#include "Game/SAVEINFO.H"
#include "Game/STREAM.H"
#include "Game/STATE.H"
#include <Game/G2/INSTNCG2.H>
#include <Game/MEMPACK.H>
#include <Game/GENERIC.H>

void MonsterProcess(struct _Instance* instance, struct GameTracker* gameTracker)  // Matching - 100%
{
	struct _MonsterState* state;
	struct _MonsterVars* mv;
	struct _MonsterAttributes* attributes;
	typedef void (*MONTABLE_DamageEffectFunc)(struct _Instance*, int);  //  not from SYMDUMP 

	attributes = (struct _MonsterAttributes*)instance->data;
	mv = (struct _MonsterVars*)instance->extraData;
	if (((mv != NULL) && (attributes != NULL)) && (!(mv->mvFlags & 0x80000)))
	{
		instance->waterFace = NULL;
		instance->waterFaceTerrain = NULL;
		MONSENSE_DoSenses(instance);
		MON_DoCombatTimers(instance);
		state = MONTABLE_GetStateFuncs(instance, instance->currentMainState);
		instance->flags2 &= ~16;
		instance->flags2 &= ~2;
		if (!(mv->mvFlags & 128))
		{
			G2EmulationInstancePlayAnimation(instance);
		}
		(state->stateFunction)(instance);
		if (mv->mvFlags & 1)
		{
			state = MONTABLE_GetStateFuncs(instance, instance->currentMainState);
			((state)->entryFunction)(instance);
		}
		mv->mvFlags &= -66;
		if (instance->flags & 0x200)
		{
			((MONTABLE_DamageEffectFunc)MONTABLE_GetDamageEffectFunc(instance))(instance, 0);
		}
		MON_ProcessLookAt(instance);
		MON_ProcessSpecialFade(instance);
	}
}


void MonsterInit(struct _Instance* instance, struct GameTracker* gameTracker)  // Matching - 100%
{
	struct _MonsterState* state;
	struct _MonsterAttributes* attributes;
	struct _MonsterVars* mv;
	typedef void (*MONTABLE_CleanUpFunc)(struct _Instance*);      // not from SYMDUMP
	typedef void (*MONTABLE_InitFunc)(struct _Instance*);         // not from SYMDUMP
	typedef void (*MONTABLE_StateFuncs)(struct _Instance*, int);  // not from SYMDUMP

	attributes = (struct _MonsterAttributes*)instance->data;
	if (instance->flags & 0x20000)
	{
		mv = (struct _MonsterVars*)instance->extraData;
		((MONTABLE_CleanUpFunc)MONTABLE_GetCleanUpFunc(instance))(instance);
		MONSENSE_RemoveSenses(instance);
		MEMPACK_Free((char*)mv);
		return;
	}
	if ((attributes == NULL) || (attributes->magicnum != 2900361317))
	{
		instance->data = NULL;
		G2Anim_SwitchToKeylist(&instance->anim, G2Instance_GetKeylist(instance, 0), 0);
	}
	else
	{
		mv = (struct _MonsterVars*)MEMPACK_Malloc(608, 23);
		instance->extraData = mv;
		if (instance->instanceID == 0)
		{
			if (instance->extraData == NULL)
			{
				return;
			}
			MEMPACK_Free((char*)mv);
			return;
		}
		if (mv == NULL)
		{
			instance->data = NULL;
			G2Anim_SwitchToKeylist(&instance->anim, G2Instance_GetKeylist(instance, 0), 0);
		}
		else
		{
			memset(mv, 0, 608);
			InitMessageQueue(&mv->messageQueue);
			instance->currentMainState = -1;
			mv->pathSlotID = -1;
			mv->lastValidPos = instance->position;
			mv->terrainImpaleID = -1;
			mv->mode = 0;
			instance->flags |= 0x10000;
			instance->flags |= 64;
			if (!(attributes->whatAmI & 0x10000))
			{
				instance->flags2 |= 0x100;
			}
			instance->maxXVel = 400;
			instance->maxYVel = 400;
			instance->maxZVel = 400;
			instance->xVel = 0;
			instance->yVel = 0;
			instance->zVel = 0;
			MONTABLE_SetQueryFunc(instance);
			MONTABLE_SetMessageFunc(instance);
			MON_ProcessIntro(instance);
			mv->maxHitPoints = mv->hitPoints;
			MON_TurnOnAllSpheres(instance);
			MON_TurnOffWeaponSpheres(instance);
			MONSENSE_SetupSenses(instance);
			MON_AnimInit(instance);
			((MONTABLE_InitFunc)MONTABLE_GetInitFunc(instance))(instance);
			if (mv->mvFlags & 1)
			{
				state = MONTABLE_GetStateFuncs(instance, instance->currentMainState);
				mv->mvFlags &= ~1;
				((state)->entryFunction)(instance);
			}
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ SendHitObject(struct _Instance *instance /*$s1*/, struct _Instance *hit /*$s0*/, int type /*$s2*/)
void SendHitObject(struct _Instance *instance, struct _Instance *hit, int type)
{ // line 358, offset 0x8007ddc0
	/* begin block 1 */
		// Start line: 359
		// Start offset: 0x8007DDC0
		// Variables:
			struct _MonsterVars *mv; // $a1
			int i; // $a0

		/* begin block 1.1 */
			// Start line: 365
			// Start offset: 0x8007DE10
			// Variables:
				struct evMonsterHitObjectData *data1; // $v0
		/* end block 1.1 */
		// End offset: 0x8007DE28
		// End Line: 368

		/* begin block 1.2 */
			// Start line: 377
			// Start offset: 0x8007DE58
			// Variables:
				struct evMonsterHitObjectData *data; // $v0
		/* end block 1.2 */
		// End offset: 0x8007DE7C
		// End Line: 381
	/* end block 1 */
	// End offset: 0x8007DE7C
	// End Line: 382

	/* begin block 2 */
		// Start line: 732
	/* end block 2 */
	// End Line: 733
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MonsterCollide(struct _Instance *instance /*$s3*/, struct GameTracker *gameTracker /*$a1*/)
void MonsterCollide(struct _Instance *instance, struct GameTracker *gameTracker)
{ // line 388, offset 0x8007de94
	/* begin block 1 */
		// Start line: 389
		// Start offset: 0x8007DE94
		// Variables:
			struct _CollideInfo *collideInfo; // $s1
			struct _MonsterVars *mv; // $s6

		/* begin block 1.1 */
			// Start line: 398
			// Start offset: 0x8007DEE4
			// Variables:
				struct _HSphere *s0; // $v0

			/* begin block 1.1.1 */
				// Start line: 412
				// Start offset: 0x8007DF1C
				// Variables:
					struct _HSphere *s1; // $v0

				/* begin block 1.1.1.1 */
					// Start line: 415
					// Start offset: 0x8007DF34
					// Variables:
						struct _Instance *inst1; // $s4
						int power; // $s0
				/* end block 1.1.1.1 */
				// End offset: 0x8007DFF4
				// End Line: 436
			/* end block 1.1.1 */
			// End offset: 0x8007DFF4
			// End Line: 436

			/* begin block 1.1.2 */
				// Start line: 452
				// Start offset: 0x8007E010
				// Variables:
					int move; // $s7

				/* begin block 1.1.2.1 */
					// Start line: 458
					// Start offset: 0x8007E048
					// Variables:
						struct _HSphere *hsphere; // $s0
				/* end block 1.1.2.1 */
				// End offset: 0x8007E09C
				// End Line: 466

				/* begin block 1.1.2.2 */
					// Start line: 496
					// Start offset: 0x8007E11C
					// Variables:
						struct BSPTree *bsp; // $s4

					/* begin block 1.1.2.2.1 */
						// Start line: 503
						// Start offset: 0x8007E158
						// Variables:
							struct evMonsterHitTerrainData *data; // $s0
							struct Level *level; // $s5
							struct Intro *impaler; // $v0
							struct _TFace *tface; // $s2

						/* begin block 1.1.2.2.1.1 */
							// Start line: 534
							// Start offset: 0x8007E2A0
							// Variables:
							//	struct _CollideInfo parentCI; // stack offset -88
						/* end block 1.1.2.2.1.1 */
						// End offset: 0x8007E30C
						// End Line: 541
					/* end block 1.1.2.2.1 */
					// End offset: 0x8007E330
					// End Line: 545
				/* end block 1.1.2.2 */
				// End offset: 0x8007E334
				// End Line: 550
			/* end block 1.1.2 */
			// End offset: 0x8007E37C
			// End Line: 576
		/* end block 1.1 */
		// End offset: 0x8007E37C
		// End Line: 577
	/* end block 1 */
	// End offset: 0x8007E37C
	// End Line: 581

	/* begin block 2 */
		// Start line: 798
	/* end block 2 */
	// End Line: 799
							UNIMPLEMENTED();
}

void MonsterAdditionalCollide(struct _Instance* instance, struct GameTracker* gameTracker)  // Matching - 100%
{
	if (instance->data != NULL)
	{
		MON_CheckEnvironment(instance);
	}
}


unsigned long MonsterQuery(struct _Instance* instance, unsigned long query)  // Matching - 100%
{
	struct _MonsterVars* mv;
	struct _MonsterAttributes* ma;
	unsigned long ret;
	struct evShadowSegmentData* shadowData;
	struct _MonsterSaveInfo* saveInfo;

	mv = (struct _MonsterVars*)instance->extraData;
	ma = (struct _MonsterAttributes*)instance->data;
	ret = 0;
	if (ma == NULL)
	{
		return ret;
	}
	switch (query)
	{
	case 38:
		shadowData = (struct evShadowSegmentData*)SetShadowSegmentData(2);
		shadowData->shadowSegments[0] = ma->leftFootSegment;
		shadowData->shadowSegments[1] = ma->rightFootSegment;
		ret = (int)shadowData;
		break;
	case 0:
		if (mv->mvFlags & 0x200)
		{
			ret = 0x40000000;
			break;
		}
		if (instance->currentMainState == 30)
		{
			ret = 0x12000000;
			break;
		}
		ret = 0;
		if (!(mv->mvFlags & 0x200000))
		{
			if ((mv->mvFlags & 16) || (mv->enemy == NULL) || (instance->currentMainState == 24))
			{
				if (mv->subAttr->grabable != 0)
				{
					ret |= 0x90000000;
				}
				else
				{
					ret |= 0x10000000;
				}
			}
		}
		else
		{
			ret = 0x4000000;
		}
		if (mv->mvFlags & 0x100)
		{
			ret |= 0x20000000;
		}
		break;
	case 1:
		ret = ma->whatAmI;
		break;
	case 2:
		ret = (int)mv->subAttr->physAbility;
		break;
	case 9:
		if (mv->mvFlags & 0x400)
		{
			ret = 16;
		}
		else
		{
			ret = 32;
		}
		break;
	case 10:
		ret = mv->mode;
		break;
	case 13:
		if (instance->matrix != NULL)
		{
			ret = (int)instance->matrix + 32;
		}
		else
		{
			ret = 0;
		}
		break;
	case 12:
		if (instance->matrix != NULL)
		{
			ret = (int)instance->matrix + (ma->headSegment << 5);
		}
		else
		{
			ret = 0;
		}
		break;
	case 15:
		ret = (int)ma->neckSegment;
		break;
	case 25:
		ret = (int)mv->soulJuice;
		break;
	case 24:
		saveInfo = (struct _MonsterSaveInfo*)CIRC_Alloc(sizeof(struct _MonsterSaveInfo));
		MON_SetUpSaveInfo(instance, saveInfo);
		ret = SetControlSaveDataData(sizeof(struct _MonsterSaveInfo), saveInfo);
		break;
	case 33:
		ret = mv->mvFlags >> 29;
		ret &= 1;
		break;
	case 35:
		ret = (int)PeekMessageQueue(&mv->messageQueue);
		break;
	case 47:
		ret = 0;
		if ((instance->currentMainState == 11) || (instance->currentMainState == 12) || (instance->currentMainState == 4) || (instance->currentMainState == 10))
		{
			ret = 1;
		}
		break;
	case 37:
		ret = 1;
		break;
	default:
		ret = GenericQuery(instance, query);
	}
	return ret;
}


void MonsterMessage(struct _Instance* instance, unsigned long message, unsigned long data)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	if (mv != NULL)
	{
		switch (message)
		{
		case 0x40026:
			PurgeMessageQueue(&mv->messageQueue);
			break;
		case 0x1000020:
			if (mv->enemy != NULL)
			{
				mv->enemy->mirFlags &= 0xEFFF;
			}

			break;
		case 0x100007:
			MON_GetSaveInfo(instance, (struct _MonsterSaveInfo*)((struct evControlSaveDataData*)data)->data);
			break;
		}

		if (!(instance->flags2 & 0x4000000))
		{
			switch (message)
			{
			case 0x1000024:
				mv->mvFlags |= 0x40;
				return;
			case 0x200000:
				MONSENSE_StartMonsterIRList(instance);
				return;
			case 0x200001:
				MONSENSE_SenseInstance(instance, (struct evCollideInstanceStatsData*)data);
				return;
			case 0x100008:
				MON_RelocateCoords(instance, (struct _SVector*)data);
				return;
			case 0x4000A:
				STREAM_SetInstancePosition(instance, (struct evPositionData*)data);
				return;
			case 0x4000B:
				instance->rotation.x = ((struct evPositionData*)data)->x;
				instance->rotation.y = ((struct evPositionData*)data)->y;
				instance->rotation.z = ((struct evPositionData*)data)->z;
				return;
			case 0x4000E:
				if (data != NULL)
				{
					mv->mvFlags |= 4;
				}
				else
				{
					mv->mvFlags &= ~4;
				}

				if ((instance->currentMainState == 1) || (instance->currentMainState == 5) || (instance->currentMainState == 28) || (instance->currentMainState == 19))
				{
					MON_SwitchStateDoEntry(instance, MONSTER_STATE_IDLE);
				}

				return;
			case 0x40013:
				if (data != NULL)
				{
					mv->mvFlags |= 0x80000;
				}
				else
				{
					mv->mvFlags &= ~0x80000;
				}

				return;
			}

			EnMessageQueueData(&mv->messageQueue, message, data);
		}
	}
}

void AnimDistanceAndVel(struct Object* object, struct _MonsterAnim* mAnim)  // Matching - 100%
{
	struct _G2Anim_Type anim;
	struct _G2AnimSection_Type* animSection;
	struct _G2AnimKeylist_Type* keylist;
	long total;

	keylist = object->animList[mAnim->index[0]];

	G2Anim_Init(&anim, object->modelList[0]);

	animSection = &anim.section[0];

	animSection->firstSeg = 0;

	animSection->segCount = (unsigned char)object->modelList[0]->numSegments;

	animSection->callback = NULL;

	animSection->callbackData = NULL;

	G2AnimSection_SetInterpInfo(animSection, NULL);

	G2AnimSection_SwitchToKeylistAtTime(animSection, keylist, mAnim->index[0], 0);

	if ((G2Anim_SegmentHasActiveChannels(&anim, 0, 0x700)) != G2FALSE)
	{
		struct _G2SVector3_Type dist;

		G2Anim_GetRootMotionOverInterval(&anim, 0, G2AnimKeylist_GetDuration(keylist), &dist);

		total = (int)MATH3D_FastSqrt0((dist.x * dist.x) + (dist.y * dist.y) + (dist.z * dist.z));

		mAnim->velocity = ((mAnim->playSpeed * 100) * (int)total) / (G2AnimKeylist_GetDuration(keylist) << 12);

		mAnim->distance = (int)total;
	}

	G2Anim_Free(&anim);
}

void TranslateAnimList(struct Object* object, struct _MonsterAnim* animList, int numAnims)  // Matching - 100%
{
	int i;

	if (animList != NULL)
	{
		struct _MonsterAnim* animPtr;

		animPtr = animList;

		for (i = 0; i < numAnims; i++, animPtr++)
		{
			int index;
			struct _G2AnimKeylist_Type* keylist;

			index = animPtr->index[0];

			keylist = object->animList[index];

			if (index != -1)
			{
				AnimDistanceAndVel(object, animPtr);

				if (animPtr->startFrame >= (G2AnimKeylist_GetDuration(keylist) / 100))
				{
					animPtr->startFrame = G2AnimKeylist_GetKeyframeCount(keylist) - 1;
				}
			}
		}
	}
}

void MonsterTranslateAnim(struct Object* object)  // Matching - 100%
{
	struct _MonsterAttributes* attributes;
	int i;
	void* relocModule;
	struct _MonsterAttackAttributes* attackAttr;
	struct _MonsterCombatAttributes* combatAttr;
	int largest;
	int j;
	struct _MonsterAttackAttributes* attack;

	attributes = (struct _MonsterAttributes*)object->data;

	if (!(object->oflags2 & 0x10000000))
	{
		if ((object->oflags & 0x8000000))
		{
			relocModule = object->relocModule;

			if (relocModule == NULL) //|| (((unsigned int*)relocModule)[6] != (unsigned int)"June 30 1999"))  // @FIXME Bypass version check. Also relocModule cast needs revalidating.
			{
				object->data = NULL;
				return;
			}
		}
		else
		{
			MONTABLE_SetupTablePointer(object);
		}

		if (attributes != NULL && attributes->magicnum == 0xACE00065)
		{
			TranslateAnimList(object, attributes->animList, attributes->numAnims);

			for (i = 0; i < attributes->numAttackAttributes; i++)
			{
				attackAttr = &attributes->attackAttributesList[i];

				if (attackAttr->sphereOnAnim >= attackAttr->numAnims || attackAttr->sphereOffAnim >= attackAttr->numAnims)
				{
					object->data = NULL;
				}
			}

			for (i = 0; i < attributes->numCombatAttributes; i++)
			{
				combatAttr = attributes->combatAttributesList[i];

				if (combatAttr->combatRange == 0)
				{
					largest = 0;

					for (j = 0; j < combatAttr->numAttacks; j++)
					{
						attack = &attributes->attackAttributesList[combatAttr->attackList[j]];

						if (largest < attack->attackRange)
						{
							largest = attack->attackRange;
						}
					}

					combatAttr->combatRange = largest + 200;
				}
			}
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ MonsterRelocateTune(struct Object *object /*$a0*/, long offset /*$a1*/)
void MonsterRelocateTune(struct Object *object, long offset)
{ // line 1171, offset 0x8007ed1c
	/* begin block 1 */
		// Start line: 1173
		// Start offset: 0x8007ED1C
		// Variables:
			struct _MonsterAttributes *attributes; // $t0

		/* begin block 1.1 */
			// Start line: 1177
			// Start offset: 0x8007ED3C
			// Variables:
				int i; // $a3
				struct _MonsterSubAttributes *subAttr; // $a2
				struct _MonsterSubAttributes **pSubAttr; // $t1
				struct _MonsterCombatAttributes **pCombatAttr; // $v0

			/* begin block 1.1.1 */
				// Start line: 1196
				// Start offset: 0x8007EE2C
				// Variables:
					int j; // $v1
					struct _MonsterSubAttributes **oldSubAttr; // $a0
			/* end block 1.1.1 */
			// End offset: 0x8007EEE4
			// End Line: 1217
		/* end block 1.1 */
		// End offset: 0x8007EF30
		// End Line: 1221
	/* end block 1 */
	// End offset: 0x8007EF30
	// End Line: 1222

	/* begin block 2 */
		// Start line: 2498
	/* end block 2 */
	// End Line: 2499

	/* begin block 3 */
		// Start line: 2499
	/* end block 3 */
	// End Line: 2500
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MonsterRelocateInstanceObject(struct _Instance *instance /*$a0*/, long offset /*$a1*/)
void MonsterRelocateInstanceObject(struct _Instance *instance, long offset)
{ // line 1227, offset 0x8007ef38
	/* begin block 1 */
		// Start line: 1229
		// Start offset: 0x8007EF38
		// Variables:
			struct _MonsterVars *mv; // $v0
	/* end block 1 */
	// End offset: 0x8007F054
	// End Line: 1250

	/* begin block 2 */
		// Start line: 2640
	/* end block 2 */
	// End Line: 2641

	/* begin block 3 */
		// Start line: 2641
	/* end block 3 */
	// End Line: 2642
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ MONAPI_TurnHead(struct _Instance *instance /*$a0*/, short *rotx /*$a1*/, short *rotz /*$a2*/, struct GameTracker *gameTracker /*$a3*/)
void MONAPI_TurnHead(struct _Instance *instance, short *rotx, short *rotz, struct GameTracker *gameTracker)
{ // line 1299, offset 0x8007f05c
	UNIMPLEMENTED();
}

void MONAPI_SetLookAround(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	MON_EnableHeadMove(instance);

	mv->mode = 0x80000;
}

void MONAPI_ResetLookAround(struct _Instance* instance)  // Matching - 100%
{
	struct _MonsterVars* mv;

	mv = (struct _MonsterVars*)instance->extraData;

	MON_DisableHeadMove(instance);

	mv->mode = 0x1;
}

long MONAPI_OkToLookAround(struct _Instance* instance)  // Matching - 100%
{
	return instance->currentMainState == 2;
}

void MONAPI_DeleteRegen(struct _MONAPI_Regenerator* regen)  // Matching - 100%
{
	--GlobalSave->numRegens;
	memcpy(regen, regen + 1, ((signed char)GlobalSave->numRegens - (regen - GlobalSave->regenEntries)) * sizeof(struct _MONAPI_Regenerator));
}

void MONAPI_ProcessGenerator()  // Matching - 99.31%
{
	int i;
	struct _MONAPI_Regenerator* regen;

	regen = &GlobalSave->regenEntries[0];

	if (!(GlobalSave->flags & 1))
	{
		for (i = 0; i < GlobalSave->numRegens;)
		{
			unsigned long time;

			if (gameTrackerX.gameData.asmData.MorphType)
			{
				time = gameTrackerX.currentSpectralTime;
			}
			else
			{
				time = gameTrackerX.currentMaterialTime;
			}

			if (regen->regenTime < time)
			{
				struct Level* level;

				level = STREAM_GetLevelWithID(regen->streamUnitID);
				if (level != NULL)
				{
					struct Intro* intro;
					int j;
					long id;

					id = regen->introUniqueID;

					for (j = level->numIntros, intro = level->introList; j != 0; intro++)
					{
						--j;
						if (intro->UniqueID == id)
						{
							if ((intro->flags & 0x400) != 0 || !INSTANCE_IntroduceInstance(intro, regen->streamUnitID))
							{
								MONAPI_DeleteRegen(regen);
							}

							break;
						}
					}
				}
				else
				{
					MONAPI_DeleteRegen(regen);
				}
			}
			else
			{
				++i;
				++regen;
			}
		}
	}
}

// autogenerated function stub: 
// void /*$ra*/ MONAPI_AddToGenerator(struct _Instance *instance /*$s2*/)
void MONAPI_AddToGenerator(struct _Instance *instance)
{ // line 1408, offset 0x8007f2d8
	/* begin block 1 */
		// Start line: 1409
		// Start offset: 0x8007F2D8

		/* begin block 1.1 */
			// Start line: 1413
			// Start offset: 0x8007F308
			// Variables:
				struct _MonsterVars *mv; // $s1
				struct _MONAPI_Regenerator *regen; // $s0
		/* end block 1.1 */
		// End offset: 0x8007F360
		// End Line: 1420
	/* end block 1 */
	// End offset: 0x8007F360
	// End Line: 1421

	/* begin block 2 */
		// Start line: 3028
	/* end block 2 */
	// End Line: 3029
				UNIMPLEMENTED();
}


void MONAPI_CheckGenerator(struct _Instance* instance)  // Matching - 100%
{
	int i;
	struct _MONAPI_Regenerator* regen;
	int id;

	regen = GlobalSave->regenEntries;
	id = instance->introUniqueID;

	for (i = 0; i < GlobalSave->numRegens; i++, regen++)
	{
		if (regen->introUniqueID == id)
		{
			MONAPI_DeleteRegen(regen);
			break;
		}

	}

}