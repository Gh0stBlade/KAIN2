#include "CORE.H"
#include "STREAM.H"
#include "OBTABLE.H"
#include "GAMELOOP.H"
#include "SAVEINFO.H"
#include "LIGHT3D.H"
#include "SCRIPT.H"
#include "OBTABLE.H"
#include "SPLINE.H"
#include "EVENT.H"
#include "STATE.H"
#include "LIST.H"
#include "G2/ANIMG2.H"
#include "G2/INSTNCG2.H"
#include "G2/ANMG2ILF.H"
#include "MEMPACK.H"
#include "FX.H"
#include "SOUND.H"
#include "FONT.H"

#ifdef PC_VERSION
#pragma warning(disable: 4101)
#endif

// autogenerated function stub: 
// void /*$ra*/ INSTANCE_ClearTfaces(struct _Instance *instance /*$a0*/)
void INSTANCE_ClearTfaces(struct _Instance* instance)
{ // line 52, offset 0x80031ed8
#if defined(PC_VERSION)
	instance->oldWaterFace = 0;
	instance->waterFace = 0;
	instance->waterFaceTerrain = 0;
	instance->tface = 0;
	instance->oldTFace = 0;
	instance->tfaceLevel = 0;
	instance->cachedTFace = -1;
	instance->cachedBSPTree = 0;
	instance->cachedTFaceLevel = 0;
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_Deactivate(struct _Instance *instance /*$s0*/)
void INSTANCE_Deactivate(struct _Instance* instance)
{ // line 66, offset 0x80031f04
	/* begin block 1 */
		// Start line: 67
		// Start offset: 0x80031F04
		// Variables:
	struct Object* object; // $a2
/* end block 1 */
// End offset: 0x80031FB0
// End Line: 91

/* begin block 2 */
	// Start line: 138
/* end block 2 */
// End Line: 139
	UNIMPLEMENTED();
}

void INSTANCE_Reactivate(struct _Instance* instance)
{
	struct Object* object;

	object = instance->object;

	instance->flags2 &= 0xFFFFFFFE;

	if ((instance->flags & 0x40000))
	{
		instance->flags &= 0xFFFBFFFF;
		instance->flags2 |= 0x20000000;
	}
	else
	{
		instance->flags2 &= 0xDFFFFFFF;
	}

	if (object->animList != NULL)
	{
		if (!(object->oflags2 & 0x40000000))
		{
			G2Anim_Restore(&instance->anim);
		}
	}
}

void INSTANCE_ForceActive(struct _Instance* instance)
{
#if defined(PSX_VERSION)

	if ((instance->flags2 & 0x1))
	{
		INSTANCE_Reactivate(instance);
	}

#elif defined(PC_VERSION)
	int flags2; // eax
	int flags; // edx
	struct Object* object; // esi
	int v4; // eax

	flags2 = instance->flags2;
	if ((flags2 & 1) != 0)
	{
		flags = instance->flags;
		object = instance->object;
		flags2 = flags2 & ~1;
		instance->flags2 = flags2;
		if ((flags & 0x40000) != 0)
		{
			v4 = flags2 | 0x20000000;
			instance->flags = flags & ~0x40000u;
		}
		else
		{
			v4 = flags2 & ~0x20000000u;
		}
		instance->flags2 = v4;
		if (object->animList)
		{
			if ((object->oflags2 & 0x40000000) == 0)
				G2Anim_Restore(&instance->anim);
		}
	}
#endif
}

void INSTANCE_DeactivatedProcess(struct _Instance* instance, struct GameTracker* gameTracker)
{
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_DeactivateFarInstances(struct GameTracker *gameTracker /*$s3*/)
void INSTANCE_DeactivateFarInstances(struct GameTracker* gameTracker)
{ // line 136, offset 0x80032094
#if 0//defined(PC_VERSION)
	struct _InstanceList* instanceList; // edi
	struct _Instance* first; // esi
	char* ScratchAddr; // eax
	int v4; // ecx
	int numInstances; // eax
	int v6; // edi
	int v7; // eax
	unsigned int(__stdcall * queryFunc)(); // eax
	int v9; // eax
	unsigned int(__stdcall * v10)(); // eax
	int v11; // eax
	__int16 v12; // cx
	int v13; // eax
	int v14; // eax
	struct Object* v15; // edx
	int flags2; // eax
	int v17; // eax
	int v18; // ecx
	struct Object* v19; // eax
	unsigned int v20; // edx
	unsigned int v21; // ecx
	int v22; // ecx
	struct Object* v23; // edi
	int v24; // eax
	int v25; // eax
	int v26; // ecx
	struct Object* object; // eax
	int v28; // edx
	int v29; // ecx
	unsigned int v30; // ecx
	struct Object* v31; // edx
	int v32; // eax
	int v33; // eax
	int v34; // ecx
	struct Object* v35; // eax
	unsigned int v36; // edx
	unsigned int v37; // ecx
	int flags; // ecx
	unsigned int v39; // edx
	int v40; // [esp+10h] [ebp-8h]
	struct _SVector* v41; // [esp+14h] [ebp-4h]

	instanceList = gameTracker->instanceList;
	first = instanceList->first;
	ScratchAddr = getScratchAddr(0);
	v4 = dword_C550A0;
	v41 = (struct _SVector*)ScratchAddr;
	numInstances = instanceList->numInstances;
	v6 = (instanceList->numInstances >> 3) + 1;
	v40 = v6;
	if (dword_C550A0 >= numInstances)
		v4 = 0;
	dword_C550A0 = v6 + v4;
	if (v6 + v4 >= numInstances)
		dword_C550A0 = 0;
	if (v4)
	{
		v7 = v4;
		do
		{
			first = first->next;
			--v7;
		} while (v7);
	}
	while (first)
	{
		if (!v6)
			return;
		if ((first->flags2 & 0x80)
			|| (first->object->oflags & 0x10000) != 0
			|| ((queryFunc = first->queryFunc) != 0
				? (v9 = ((int(__cdecl*)(struct _Instance*, int))queryFunc)(first, 35))
				: (v9 = 0),
				v9
				|| ((v10 = first->queryFunc) != 0
					? (v11 = ((int(__cdecl*)(struct _Instance*, int))v10)(first, 47))
					: (v11 = 0),
					v11 || first->LinkParent || !first->matrix)))
		{
			if ((first->flags2 & 1) != 0)
			{
				flags = first->flags;
				object = first->object;
				first->flags2 &= ~1u;
				if ((flags & 0x40000) != 0)
				{
					v39 = flags & ~0x40000u;
					v30 = first->flags2 | 0x20000000;
					first->flags = v39;
				}
				else
				{
					v30 = first->flags2 & ~0x20000000u;
				}
				goto LABEL_76;
			}
		}
		else
		{
			v41->x = first->position.x - theCamera.core.position.x;
			v41->y = first->position.y - theCamera.core.position.y;
			v12 = first->position.z - theCamera.core.position.z;
			v41->z = v12;
			v14 = v41->x * v41->x + v12 * v12 + v41->y * v41->y;
			if ((first->flags & 0x200) != 0)
			{
				v15 = first->object;
				if (v14 <= v15->vvRemoveDist * v15->vvRemoveDist)
				{
					if ((first->flags2 & 1) == 0)
						goto LABEL_79;
					v18 = first->flags;
					v19 = first->object;
					first->flags2 &= ~1u;
					if ((v18 & 0x40000) != 0)
					{
						v20 = v18 & ~0x40000u;
						v21 = first->flags2 | 0x20000000;
						first->flags = v20;
					}
					else
					{
						v21 = first->flags2 & ~0x20000000u;
					}
					first->flags2 = v21;
					if (!v19->animList || (v19->oflags2 & 0x40000000) != 0)
						goto LABEL_79;
					goto LABEL_78;
				}
				flags2 = first->flags2;
				if ((flags2 & 1) != 0 || (gameTrackerX.streamFlags & 0x2000000) != 0)
					goto LABEL_79;
				flags2 = flags2 | 1;
				first->flags2 = flags2;
				if ((flags2 & 0x20000000) != 0)
				{
					first->flags |= 0x40000u;
				}
				else
				{
					v17 = first->flags2 | 0x20000000;
					first->flags &= ~0x40000u;
					first->flags2 = v17;
				}
				if (!v15->animList || (v15->oflags2 & 0x40000000) != 0)
					goto LABEL_64;
				goto LABEL_31;
			}
			v22 = first->flags2;
			if ((v22 & 0x80000) != 0)
			{
				if (v14 <= gameTracker->defRemoveDist * gameTracker->defRemoveDist)
				{
					if ((v22 & 1) == 0)
						goto LABEL_79;
					v34 = first->flags;
					v35 = first->object;
					first->flags2 &= ~1u;
					if ((v34 & 0x40000) != 0)
					{
						v36 = v34 & 0xFFFBFFFF;
						v37 = first->flags2 | 0x20000000;
						first->flags = v36;
					}
					else
					{
						v37 = first->flags2 & 0xDFFFFFFF;
					}
					first->flags2 = v37;
					if (!v35->animList || (v35->oflags2 & 0x40000000) != 0)
						goto LABEL_79;
					goto LABEL_78;
				}
				if ((v22 & 1) != 0)
					goto LABEL_79;
				v31 = first->object;
				if ((gameTrackerX.streamFlags & 0x2000000) != 0)
					goto LABEL_79;
				v32 = first->flags2;
				v32 = v22 | 1;
				first->flags2 = v32;
				if ((v32 & 0x20000000) != 0)
				{
					first->flags |= 0x40000u;
				}
				else
				{
					v33 = first->flags2 | 0x20000000;
					first->flags &= ~0x40000u;
					first->flags2 = v33;
				}
				if (v31->animList && (v31->oflags2 & 0x40000000) == 0)
					G2Anim_Free(&first->anim);
			LABEL_64:
				first->oldWaterFace = 0;
				first->waterFace = 0;
				first->waterFaceTerrain = 0;
				first->tface = 0;
				first->oldTFace = 0;
				first->tfaceLevel = 0;
				first->cachedTFace = -1;
				first->cachedBSPTree = 0;
				first->cachedTFaceLevel = 0;
				goto LABEL_79;
			}
			v23 = first->object;
			if (v14 > v23->removeDist * v23->removeDist)
			{
				if ((v22 & 1) != 0 || (gameTrackerX.streamFlags & 0x2000000) != 0)
					goto LABEL_79;
				v24 = first->flags2;
				v24 = v22 | 1;
				first->flags2 = v24;
				if ((v24 & 0x20000000) != 0)
				{
					first->flags |= 0x40000u;
				}
				else
				{
					v25 = first->flags2 | 0x20000000;
					first->flags &= ~0x40000u;
					first->flags2 = v25;
				}
				if (!v23->animList || (v23->oflags2 & 0x40000000) != 0)
					goto LABEL_64;
			LABEL_31:
				G2Anim_Free(&first->anim);
				first->oldWaterFace = 0;
				first->waterFace = 0;
				first->waterFaceTerrain = 0;
				first->tface = 0;
				first->oldTFace = 0;
				first->tfaceLevel = 0;
				first->cachedTFace = -1;
				first->cachedBSPTree = 0;
				first->cachedTFaceLevel = 0;
				goto LABEL_79;
			}
			if ((v22 & 1) != 0)
			{
				v26 = first->flags;
				object = first->object;
				first->flags2 &= ~1u;
				if ((v26 & 0x40000) != 0)
				{
					v28 = v26;
					v29 = first->flags2;
					first->flags = v28 & ~0x40000u;
					v30 = v29 | 0x20000000;
				LABEL_76:
					first->flags2 = v30;
					if (!object->animList || (object->oflags2 & 0x40000000) != 0)
						goto LABEL_79;
				}
				else
				{
					first->flags2 &= ~0x20000000u;
					if (!object->animList || (object->oflags2 & 0x40000000) != 0)
						goto LABEL_79;
				}
			LABEL_78:
				G2Anim_Restore(&first->anim);
			}
		}
	LABEL_79:
		first = first->next;
		v6 = --v40;
	}
#endif
	UNIMPLEMENTED();
}

void INSTANCE_InitInstanceList(struct _InstanceList* list, struct _InstancePool* pool)
{
#if defined(PSX_VERSION)

	long i;

	pool->numFreeInstances = 60;
	
	for (i = 1; i < 59; i++)
	{
		pool->instance[i].next = &pool->instance[i + 1];
		pool->instance[i].prev = &pool->instance[i - 1];
	}

	pool->instance[0].next = &pool->instance[1];
	pool->instance[0].prev = NULL;

	pool->instance[59].prev = &pool->instance[58];
	pool->instance[59].next = NULL;
	
	pool->first_free = &pool->instance[0];

	list->pool = pool;
	list->numInstances = 0;
	list->first = NULL;

	for (i = 0; i < 32; i++)
	{
		list->group[i].next = NULL;
		list->group[i].prev = NULL;
	}

	pool->nextInstanceID = 1;

#elif defined(PC_VERSION)
	struct _Instance** p_next; // eax
	struct NodeType* group; // eax
	int i; // edx MAPDST

	i = 60;
	pool->numFreeInstances = 62;
	p_next = &pool->instance[1].next;
	do
	{
		*p_next = (struct _Instance*)(p_next + 152);
		p_next[1] = (struct _Instance*)(p_next - 156);
		p_next += 154;
		--i;
	} while (i);
	pool->instance[0].next = &pool->instance[1];
	pool->first_free = pool->instance;
	pool->instance[0].prev = 0;
	pool->instance[61].next = 0;
	pool->instance[61].prev = &pool->instance[60];
	list->pool = pool;
	list->numInstances = 0;
	list->first = 0;
	group = list->group;
	i = 32;
	do
	{
		group->next = 0;
		group->prev = 0;
		++group;
		--i;
	} while (i);
	pool->nextInstanceID = 1;
#endif
}

struct _Instance* INSTANCE_NewInstance(struct _InstanceList* list)
{
#if defined(PSX_VERSION)
	struct _Instance* temp;
	struct _Instance* instance;

	if (list->pool->numFreeInstances != 0)
	{
		list->pool->numFreeInstances--;
		instance = list->pool->first_free;
		list->pool->first_free = instance->next;

		temp = list->first;
		list->first = instance;
		instance->next = temp;

		if (instance->next != NULL)
		{
			list->first->prev = instance;
		}
	
		instance->prev = NULL;
		instance->instanceID = list->pool->nextInstanceID++;

		list->numInstances++;

		return instance;
	}
	
	return NULL;

#elif defined(PC_VERSION)
	struct _InstancePool* pool; // eax
	int numFreeInstances; // edx
	struct _InstancePool* v3; // edx
	struct _Instance* result; // eax
	struct _Instance* first; // edx

	pool = list->pool;
	numFreeInstances = pool->numFreeInstances;
	if (numFreeInstances)
	{
		pool->numFreeInstances = numFreeInstances - 1;
		v3 = list->pool;
		result = v3->first_free;
		v3->first_free = result->next;
		first = list->first;
		list->first = result;
		result->next = first;
		if (first)
			first->prev = result;
		result->prev = 0;
		result->instanceID = list->pool->nextInstanceID++;
		++list->numInstances;
	}
	else
	{
		GXFilePrint("ran out of instances need more than %d - contact a programmer\n", 62);
		return 0;
	}
	return result;
#endif
}

long INSTANCE_InstanceGroupNumber(struct _Instance* instance)
{
#if defined(PSX_VERSION)
	long result;

	result = 0;

	if ((instance->object->oflags & 0x80))
	{
		result = (unsigned)(instance->flags & 0x8000) < 1;
	}
	
	if ((instance->object->oflags & 0x20) && !(instance->flags & 0x2000))
	{
		result |= 0x2;
	}
	
	if ((instance->object->oflags & 0x40) && !(instance->flags & 0x4000))
	{
		result |= 0x4;
	}

	if ((instance->object->oflags & 0x10) && !(instance->flags & 0x1000))
	{
		result |= 0x10;
	}

	if ((instance->object->oflags & 0x1))
	{
		result |= 0x8;
	}
	else
	{
		if (strcmp(instance->object->name, "raziel__"))
		{
			result &= 0xFFFFFFFD;
			result &= 0xFFFFFFFE;
		}
	}

	return result;

#elif defined(PC_VERSION)
	int v1; // ebx
	struct Object* object; // ecx
	int oflags; // eax

	v1 = 0;
	object = instance->object;
	oflags = object->oflags;
	if ((object->oflags & 0x80u) != 0 && (instance->flags & 0x8000u) == 0)
		v1 = 1;
	if ((oflags & 0x20) != 0 && (instance->flags & 0x2000) == 0)
		v1 |= 2u;
	if ((oflags & 0x40) != 0 && (instance->flags & 0x4000) == 0)
		v1 |= 4u;
	if ((oflags & 0x10) != 0 && (instance->flags & 0x1000) == 0)
		v1 |= 0x10u;
	if ((oflags & 1) != 0)
		return v1 | 8;
	if (strcmp(object->name, "raziel__"))
	{
		if ((v1 & 3) != 0)
		{
			printf("Object %s\n", object->name);
			FONT_Print("Object %s\n", instance->object->name);
		}
		return v1 & ~3u;
	}
	return v1;
#endif
}

void INSTANCE_InsertInstanceGroup(struct _InstanceList* list, struct _Instance* instance)
{
#if defined(PSX_VERSION)
	LIST_InsertFunc(&list->group[INSTANCE_InstanceGroupNumber(instance)], &instance->node);
#elif defined(PC_VERSION)
	int v2; // eax

	v2 = INSTANCE_InstanceGroupNumber(instance);
	LIST_InsertFunc(&list->group[v2], &instance->node);
#endif
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_ReallyRemoveInstance(struct _InstanceList *list /*$s1*/, struct _Instance *instance /*$s0*/, long reset /*$s2*/)
void INSTANCE_ReallyRemoveInstance(struct _InstanceList* list, struct _Instance* instance, long reset)
{ // line 499, offset 0x800325a0
#if defined(PC_VERSION)
	struct Intro* intro; // eax
	struct _Instance* prev; // ecx
	struct _Instance* next; // ecx
	struct _InstancePool* pool; // ecx
	struct _InstancePool* v7; // eax
	struct _Instance* first_free; // ecx
	int flags; // eax
	struct Object* object; // eax
	struct Object* v11; // eax
	struct _Instance* LinkChild; // edi
	void(* messageFunc)(); // ebx
	struct _Instance* LinkSibling; // ebp
	int flags2; // eax
	int v16; // ecx
	struct Object* v17; // edx
	int v18; // eax
	int i; // ecx
	struct LightInstance* lightInstances; // eax

	EVENT_RemoveInstanceFromInstanceList(instance);
	if ((instance->flags & 0x800000) != 0)
		SAVE_DoInstanceDeadDead(instance);
	if ((instance->flags & 2) == 0)
	{
		intro = instance->intro;
		if (intro)
		{
			intro->flags &= ~reset;
			instance->intro->instance = 0;
		}
	}
	prev = instance->prev;
	if (prev)
		prev->next = instance->next;
	else
		list->first = instance->next;
	next = instance->next;
	if (next)
		next->prev = instance->prev;
	instance->instanceID = 0;
	pool = list->pool;
	--list->numInstances;
	++pool->numFreeInstances;
	v7 = list->pool;
	first_free = v7->first_free;
	v7->first_free = instance;
	instance->next = first_free;
	instance->prev = 0;
	if (first_free)
		first_free->prev = instance;
	LIST_DeleteFunc(&instance->node);
	FX_EndInstanceEffects(instance);
	flags = instance->flags;
	if ((flags & 0x10000) != 0)
	{
		instance->flags = flags | 0x20000;
		OBTABLE_InstanceInit(instance);
	}
	object = instance->object;
	if (object->animList && (object->oflags2 & 0x40000000) == 0)
		G2Anim_Free(&instance->anim);
	v11 = instance->object;
	if ((v11->oflags2 & 4) != 0)
		SOUND_EndInstanceSounds(v11->soundData, instance->soundInstanceTbl);
	if (instance->LinkParent)
		INSTANCE_UnlinkFromParent(instance);
	LinkChild = instance->LinkChild;
	if (LinkChild)
	{
		do
		{
			messageFunc = instance->messageFunc;
			LinkSibling = LinkChild->LinkSibling;
			if (messageFunc)
			{
				flags2 = instance->flags2;
				if ((flags2 & 1) != 0)
				{
					v16 = instance->flags;
					v17 = instance->object;
					flags2 = flags2 & ~1;
					instance->flags2 = flags2;
					if ((v16 & 0x40000) != 0)
					{
						v18 = flags2 | 0x20000000;
						instance->flags = v16 & 0xFFFBFFFF;
					}
					else
					{
						v18 = flags2 & ~0x20000000u;
					}
					instance->flags2 = v18;
					if (v17->animList)
					{
						if ((v17->oflags2 & 0x40000000) == 0)
							G2Anim_Restore(&instance->anim);
					}
				}
				((void(__cdecl*)(struct _Instance*, int, struct _Instance*))messageFunc)(instance, 1048595, LinkChild);
			}
			LinkChild->LinkParent = 0;
			LinkChild->LinkSibling = 0;
			LinkChild = LinkSibling;
		} while (LinkSibling);
		instance->LinkChild = 0;
	}
	if (instance->hModelList)
		MEMPACK_Free((char*)instance->hModelList);
	if (instance->perVertexColor)
	{
		MEMPACK_Free((char*)instance->perVertexColor);
		instance->perVertexColor = 0;
	}
	i = 0;
	lightInstances = gameTrackerX.gameData.asmData.lightInstances;
	while (lightInstances->lightInstance != instance)
	{
		++lightInstances;
		++i;
		if ((int)lightInstances >= (int)&gameTrackerX.menu)
			return;
	}
	gameTrackerX.gameData.asmData.lightInstances[i].lightInstance = 0;
#else
UNIMPLEMENTED();
#endif
}

void INSTANCE_CleanUpInstanceList(struct _InstanceList* list, long reset)
{
	struct _Instance* instance;
	struct _Instance* next;

	instance = list->first;
	
	while (instance != NULL)
	{
		next = instance->next;

		if ((instance->flags & 0x400))
		{
			if ((instance->flags & 0x20))
			{
				instance->flags &= 0xFFFFFFDF;
			}
		}
		else
		{
			instance->flags |= 0x20;
		}
		
		instance = next;
	}

	while (instance != NULL)
	{
		next = instance->next;

		if ((instance->flags & 0x20))
		{
			INSTANCE_ReallyRemoveInstance(instanceList, instance, reset);
		}

		instance = next;
	}
}

long INSTANCE_Introduced(struct Intro* intro, short streamUnitID)
{ 
#if defined(PSX_VERSION)
	struct _Instance* instance;
	struct _Instance* next;
	long ret;

	instance = gameTrackerX.instanceList->first;
	
	ret = 0;

	while (instance != NULL)
	{
		next = instance->next;

		if (intro->UniqueID == instance->introUniqueID)
		{
			ret = 1;

			intro->flags |= 0x8;
			
			break;
		}

		instance = next;
	}

	if (SAVE_HasSavedIntro(intro, streamUnitID) == 0)
	{
		if (SAVE_IsIntroDeadDead(intro) == 0)
		{
			return ret;
		}
	}
	else
	{
		intro->flags |= 0x8;
		ret = 1;
	}

	return ret;

#elif defined(PC_VERSION)
	struct _Instance* first; // eax
	int v3; // edi
	struct _Instance* next; // ecx
	int flags; // eax
	int v6; // eax

	first = gameTrackerX.instanceList->first;
	v3 = 0;
	if (first)
	{
		while (1)
		{
			next = first->next;
			if (intro->UniqueID == first->introUniqueID)
				break;
			first = first->next;
			if (!next)
				goto LABEL_6;
		}
		flags = intro->flags;
		v3 = 1;
		flags = flags | 8;
		intro->flags = flags;
	}
LABEL_6:
	if (!v3 && (SAVE_HasSavedIntro(intro) || SAVE_IsIntroDeadDead(intro)))
	{
		v6 = intro->flags;
		v3 = 1;
		v6 = v6 | 8;
		intro->flags = v6;
	}
	return v3;
#else
	UNIMPLEMENTED();
#endif
}

struct INICommand* INSTANCE_GetIntroCommand(struct INICommand* command, int cmd)
{
#if defined(PSX_VERSION)

	if (command != NULL)
	{
		while (command->command != 0)
		{
			if (command->command != cmd)
			{
				command += command->numParameters + 1;
			}
			else
			{
				return command;
			}
		}
	}

	return 0;

#elif defined(PC_VERSION)
	struct INICommand* result; // eax
	__int16 v3; // cx

	result = command;
	if (!command)
		return 0;
	v3 = command->command;
	if (!command->command)
		return 0;
	while (v3 != cmd)
	{
		result += result->numParameters + 1;
		v3 = result->command;
		if (!result->command)
			return 0;
	}
	return result;
#endif
}

struct INICommand* INSTANCE_FindIntroCommand(struct _Instance* instance, int cmd)//Matching - 99.44%
{
#if defined(PSX_VERSION)
	return INSTANCE_GetIntroCommand((struct INICommand*)instance->introData, cmd);
#elif defined(PC_VERSION)
	struct INICommand* result; // eax
	__int16 command; // cx

	result = (struct INICommand*)instance->introData;
	if (!result)
		return 0;
	command = result->command;
	if (!result->command)
		return 0;
	while (command != cmd)
	{
		result += result->numParameters + 1;
		command = result->command;
		if (!result->command)
			return 0;
	}
	return result;
#endif
}

void INSTANCE_ProcessIntro(struct _Instance* instance)
{
#if defined(PSX_VERSION)
	struct INICommand* command;
	
	if (instance->introData != NULL)
	{
		command = (struct INICommand*)instance->introData;

		if (!(instance->flags & 0x2))
		{
			while (command->command != 0)
			{
				if (command->command == 0x12)
				{

					instance->currentModel = command->parameter[0];
					command += command->numParameters + 1;
				}
			}
		}
	}

#elif defined(PC_VERSION)
	struct INICommand* introData; // esi
	__int16 i; // ax
	__int16 v3; // ax
	struct Object* object; // ecx
	__int16 numModels; // cx
	int numParameters; // ecx

	introData = (struct INICommand*)instance->introData;
	if (introData)
	{
		if ((instance->flags & 2) == 0)
		{
			for (i = introData->command; i; introData += numParameters + 1)
			{
				if (i == 18)
				{
					v3 = introData->parameter[0];
					object = instance->object;
					instance->currentModel = v3;
					numModels = object->numModels;
					if (numModels <= v3)
						GXFilePrint(
							"Error: Specify model num %d on a instance(%s%d) with %d models.\n",
							v3,
							instance->introName,
							instance->introNum,
							numModels);
				}
				numParameters = introData->numParameters;
				i = introData[numParameters + 1].command;
			}
		}
	}
#endif
}

void INSTANCE_InitEffects(struct _Instance* instance, struct Object* object)
{
#if defined(PSX_VERSION)
	int i;
	
	if (!(object->oflags2 & 0x100))
	{
		if (object->numberOfEffects != 0 && object->numberOfEffects > 0)
		{
			for (i = 0; i < object->numberOfEffects; i++)
			{
				FX_StartInstanceEffect(instance, &object->effectList[i], 1);
			}
		}
	}

#elif 0//defined(PC_VERSION)
	__int16 numberOfEffects; // ax
	int v3; // esi

	if ((object->oflags2 & 0x100) == 0)
	{
		numberOfEffects = object->numberOfEffects;
		if (numberOfEffects)
		{
			v3 = 0;
			if (numberOfEffects > 0)
			{
				do
					FX_StartInstanceEffect(instance, (unsigned __int8*)&object->effectList[v3++], 1);
				while (v3 < object->numberOfEffects);
			}
		}
	}
#endif
}

struct _Instance* INSTANCE_IntroduceInstance(struct Intro* intro, short streamUnitID)
{
	struct Object* object;
	struct _Instance* instance;
	struct _Instance* attachInst;
	struct _ObjectTracker* objectTracker;
	struct INICommand* index;
	long attachedUniqueID;
	struct SavedIntroSpline* savedIntroSpline;
	struct MultiSpline* spline;
	struct SavedIntroSmall* savedIntroSmall;
	
	attachInst = NULL;
	index = NULL;

	if (!(INSTANCE_Introduced(intro, streamUnitID)))
	{
		attachedUniqueID = 0;
		index = INSTANCE_GetIntroCommand(index, 26);

		if (index != NULL)
		{
			attachedUniqueID = index->parameter[0];
		}

		objectTracker = STREAM_GetObjectTracker(intro->name);

		if (objectTracker != NULL)
		{
			object = objectTracker->object;

			if (objectTracker->objectStatus == 2)
			{
				savedIntroSmall = NULL;

				if (attachedUniqueID != 0)
				{
					attachInst = INSTANCE_Find(attachedUniqueID);
					if (attachInst == NULL)
					{
						return 0;
					}
				}


				if ((object->oflags2 & 0x10000000))
				{
					OBTABLE_InitAnimPointers(objectTracker);

					if ((object->oflags2 & 0x10000000))
					{
						return 0;
					}
				}

				instance = INSTANCE_NewInstance(gameTrackerX.instanceList);

				if (instance != NULL)
				{
					intro->flags |= 0x8;

					objectTracker->numInUse++;

					INSTANCE_DefaultInit(instance, object, 0);

					strcpy(instance->introName, intro->name);

					instance->introUniqueID = intro->UniqueID;
					instance->introNum = intro->intronum;
					instance->birthStreamUnitID = streamUnitID;
					instance->currentStreamUnitID = streamUnitID;

					intro->instance = instance;

					instance->intro = intro;
					instance->introData = intro->multiSpline;
					instance->position = intro->position;

					if (gameTrackerX.gameData.asmData.MorphType == 1)
					{
						if (intro->spectralPosition.x != 0 && intro->spectralPosition.y != 0 && intro->spectralPosition.z != 0)
						{
							instance->position.x = intro->position.x + intro->spectralPosition.x;
							instance->position.y = intro->position.y + intro->spectralPosition.y;
							instance->position.z = intro->position.z + intro->spectralPosition.z;
						}
					}

					instance->initialPos = instance->position;
					instance->oldPos = intro->position;

					LIGHT_GetAmbient((struct _ColorType*)&instance->light_color, instance);

					instance->rotation = intro->rotation;
					if ((instance->object->oflags & 0x100))
					{
						INSTANCE_BuildStaticShadow(instance);
					}

					instance->scale.x = 4096;
					instance->scale.y = 4096;
					instance->scale.z = 4096;

					if ((intro->flags & 0x2000))
					{
						instance->flags |= 0x400;
					}

					if ((intro->flags & 0x10000))
					{
						instance->flags2 |= 0x20000;
					}

					if (attachInst != NULL)
					{
						INSTANCE_ForceActive(attachInst);
						attachInst->flags2 |= 0x80;
					}

					if ((object->oflags2 & 0x80))
					{
						instance->flags |= 0x800;
					}

					if ((intro->flags & 0x800) && object->id == -1)
					{
						SCRIPTCountFramesInSpline(instance);
						SCRIPT_InstanceSplineSet(instance, -1, NULL, NULL, NULL);
						instance->flags = (instance->flags ^ 0x1000000) | 0x100000;
					}

					instance->lightGroup = (unsigned char)intro->rotation.pad;
					instance->spectralLightGroup = intro->specturalLightGroup;

					INSTANCE_InsertInstanceGroup(gameTrackerX.instanceList, instance);
					OBTABLE_GetInstanceCollideFunc(instance);
					OBTABLE_GetInstanceProcessFunc(instance);
					OBTABLE_GetInstanceQueryFunc(instance);
					OBTABLE_GetInstanceMessageFunc(instance);
					OBTABLE_GetInstanceAdditionalCollideFunc(instance);

					if (!(intro->flags & 0x10))
					{
						OBTABLE_InstanceInit(instance);
					}

					MORPH_SetupInstanceFlags(instance);

					if ((intro->flags & 0x80))
					{
						instance->flags |= 0x800;
						instance->flags2 |= 0x20000000;

						if ((object->oflags2 & 0x80000))
						{
							instance->flags2 |= 0x10000000;
						}
					}

					if (SCRIPT_GetMultiSpline(instance, NULL, NULL) == NULL)
					{
						instance->flags = (instance->flags & 0xFDFFFFFF) | 0x100000;
					}
					else
					{
						spline = SCRIPT_GetMultiSpline(instance, NULL, NULL);
						savedIntroSpline = SAVE_GetIntroSpline(instance);

						if (savedIntroSpline != NULL)
						{
							SCRIPT_InstanceSplineSet(instance, savedIntroSpline->splineKeyFrame, NULL, NULL, NULL);

							instance->oldPos = instance->position;
							instance->splineFlags = savedIntroSpline->splineFlags;
							instance->clipBeg = savedIntroSpline->splineClipBeg;
							instance->clipEnd = savedIntroSpline->splineClipEnd;

							if ((instance->splineFlags & 0x80))
							{
								instance->flags |= 0x1000000;
							}

							if ((instance->splineFlags & 0x100))
							{
								instance->flags |= 0x2000000;
							}

							if ((savedIntroSpline->splineFlags & 0x10))
							{
								if (spline->positional != NULL)
								{
									spline->positional->flags |= 0x1;
								}

								if (spline->rotational != NULL)
								{
									spline->rotational->flags |= 0x1;
								}

								if (spline->scaling != NULL)
								{
									spline->scaling->flags |= 0x1;
								}

								if (spline->color != NULL)
								{
									spline->color->flags |= 0x1;
								}
							}
							else if ((instance->splineFlags & 0x20))
							{
								if (spline->positional != NULL)
								{
									spline->positional->flags |= 0x2;
								}

								if (spline->rotational != NULL)
								{
									spline->rotational->flags |= 0x2;
								}

								if (spline->scaling != NULL)
								{
									spline->scaling->flags |= 0x2;
								}

								if (spline->color != NULL)
								{
									spline->color->flags |= 0x2;
								}
							}
							else if ((instance->splineFlags & 0x40))
							{
								if (spline->positional != NULL)
								{
									spline->positional->flags |= 0x4;
								}

								if (spline->rotational != NULL)
								{
									spline->rotational->flags |= 0x4;
								}

								if (spline->scaling != NULL)
								{
									spline->scaling->flags |= 0x4;
								}

								if (spline->color != NULL)
								{
									spline->color->flags |= 0x4;
								}
							}
						}
					}

					EVENT_AddInstanceToInstanceList(instance);

					INSTANCE_ProcessIntro(instance);
					INSTANCE_InitEffects(instance, object);

					savedIntroSmall = SAVE_GetSavedSmallIntro(instance);

					if (savedIntroSmall != NULL)
					{
						INSTANCE_Post(instance, 0x100007, SetControlSaveDataData((savedIntroSmall->shiftedSaveSize << 2) - 4, savedIntroSmall + 1));
					}

					return instance;
				}
			}
		}
	}
	return NULL;
}

void INSTANCE_AdditionalCollideFunctions(struct _InstanceList* instanceList)
{
#if defined(PSX_VERSION)

	struct _Instance* instance;

	instance = instanceList->first;

	while (instance != NULL)
	{
		if (gameTrackerX.gameMode != 6 || (instance->object->oflags & 0x20000))
		{
			if (!(gameTrackerX.streamFlags & 0x100000) || (instance->object->oflags & 0x40000))
			{
				if (instance->additionalCollideFunc != NULL)
				{
					if (!(instance->flags2 & 0x24000000))
					{
						if (instance->object != NULL)
						{
							if ((instance->object->oflags2 & 0x2000000))
							{
								if ((instance->flags2 & 0x8000000))
								{
									gameTrackerX.timeMult = gameTrackerX.spectralTimeMult;
								}
								else
								{
									gameTrackerX.timeMult = gameTrackerX.materialTimeMult;
								}
							}
							else
							{
								gameTrackerX.timeMult = gameTrackerX.globalTimeMult;
							}
						}
						else
						{
							gameTrackerX.timeMult = gameTrackerX.globalTimeMult;
						}

						instance->additionalCollideFunc(instance, &gameTrackerX);
					}
				}
			}
		}

		instance = instance->next;
	}
	gameTrackerX.timeMult = gameTrackerX.globalTimeMult;

#elif defined(PC_VERSION)
	struct _Instance* i; // esi
	int flags2; // ecx
	struct Object* object; // eax

	for (i = instanceList->first; i; i = i->next)
	{
		if ((gameTrackerX.gameMode != 6 || (i->object->oflags & 0x20000) != 0)
			&& ((gameTrackerX.streamFlags & 0x100000) == 0 || (i->object->oflags & 0x40000) != 0))
		{
			if (i->additionalCollideFunc)
			{
				flags2 = i->flags2;
				if ((flags2 & 0x24000000) == 0)
				{
					object = i->object;
					if (object && (object->oflags2 & 0x2000000) != 0)
					{
						if ((flags2 & 0x8000000) != 0)
							gameTrackerX.timeMult = gameTrackerX.spectralTimeMult;
						else
							gameTrackerX.timeMult = gameTrackerX.materialTimeMult;
					}
					else
					{
						gameTrackerX.timeMult = gameTrackerX.globalTimeMult;
					}
					((void(__cdecl*)(struct _Instance*, struct GameTracker*))i->additionalCollideFunc)(i, &gameTrackerX);
				}
			}
		}
	}
	gameTrackerX.timeMult = gameTrackerX.globalTimeMult;
#endif
}

long INSTANCE_GetSplineFrameNumber(struct _Instance* instance, struct MultiSpline* spline)
{
#if defined(PSX_VERSION)
	return SCRIPT_GetSplineFrameNumber(instance, SCRIPT_GetPosSplineDef(instance, spline, 0, 0));
#elif defined(PC_VERSION)
	int* PosSplineDef; // eax

	PosSplineDef = SCRIPT_GetPosSplineDef(instance, spline, 0, 0);
	return SCRIPT_GetSplineFrameNumber(instance, PosSplineDef);
#endif
}

void INSTANCE_ProcessFunctions(struct _InstanceList* instanceList)
{
	struct _Instance* instance;
	int hidden;
	int burning;
	long prevFrame;
	struct MultiSpline* multi;
	long endOfSpline;
	short direction;
	long frame;
	long maxFrames;
	int killTest;

	if (!(gameTrackerX.debugFlags & 0x8000010))
	{
		if (gameTrackerX.gameMode != 6 && !(gameTrackerX.streamFlags & 0x100000))
		{
			gameTrackerX.streamFlags &= 0xFFFFFFFB;
		}

		instance = instanceList->first;

		while (instance != NULL)
		{
			if (instance->object != NULL && (instance->object->oflags2 & 0x2000000))
			{
				if ((instance->flags2 & 0x8000000))
				{
					gameTrackerX.timeMult = gameTrackerX.spectralTimeMult;
				}
				else
				{
					gameTrackerX.timeMult = gameTrackerX.materialTimeMult;
				}
			}
			else
			{
				gameTrackerX.timeMult = gameTrackerX.globalTimeMult;
			}

			burning = 0;

			if ((instance->object->oflags2 & 0x4))
			{
				hidden = instance->flags & 0x800;

				if ((INSTANCE_Query(instance, 0x2) & 0x80))
				{
					burning = burning < INSTANCE_Query(instance, 0x3) & 0x10000;
				}
				else
				{
					if ((instance->object->oflags2 & 0x80000) && ((unsigned int*)instance->extraData)[0] & 0x400000)
					{
						burning = 1;
					}
				}

				SOUND_ProcessInstanceSounds(instance->object->soundData, &instance->soundInstanceTbl[0], &instance->position, instance->object->oflags2 & 0x2000000, instance->flags2 & 0x8000000, hidden, burning, &instance->flags2);
			}

			if (instance->intro == NULL || (instance->intro->flags & 0x100))
			{
				if(gameTrackerX.gameMode != 6 || (instance->object->oflags & 0x20000))
				{
					if (!(gameTrackerX.streamFlags & 0x100000) || (instance->object->oflags & 0x40000))
					{
						if (!(instance->flags2 & 0x10000000))
						{
							instance->oldPos.x = instance->position.x;
							instance->oldPos.y = instance->position.y;
							instance->oldPos.z = instance->position.z;

							instance->oldRotation.x = instance->rotation.x;
							instance->oldRotation.y = instance->rotation.y;
							instance->oldRotation.z = instance->rotation.z;

							if (!(instance->flags & 0x10000000))
							{
								multi = SCRIPT_GetMultiSpline(instance, NULL, NULL);

								if (multi != NULL && (instance->flags & 0x2000000))
								{
									if ((instance->flags & 0x1000000))
									{
										direction = -1;
									}
									else
									{
										direction = 1;
									}

									if ((instance->object->oflags & 0x10000000))
									{
										instance->flags |= 0x400;
										
										if (SplineMultiIsWhere(multi) != 0)
										{
											if (direction > 0)
											{
												instance->intro->flags |= 0x800;
											}
											else
											{
												instance->intro->flags &= 0xFFFFF7FF;
											}
										}
									}

									prevFrame = INSTANCE_GetSplineFrameNumber(instance, multi);

									endOfSpline = SCRIPT_InstanceSplineProcess(instance, &multi->curPositional, &multi->curRotational, &multi->curScaling, direction);
								
									if (instance->splineFlags != 0)
									{
										frame = INSTANCE_GetSplineFrameNumber(instance, multi);

										maxFrames = SCRIPTCountFramesInSpline(instance);
									
										if ((instance->splineFlags & 0x1))
										{
											if ((gameTrackerX.debugFlags2 & 0x400000))
											{
												printf("Spline %s%ld playto %d preveFram=%ld frame=%ld endOfSpline=%ld, maxFrames=%ld\n", instance->introName, instance->introNum, instance->targetFrame, prevFrame, frame, endOfSpline, maxFrames);
											}

											if (direction > 0)
											{
												if (maxFrames < prevFrame)
												{
													prevFrame = maxFrames;
												}

												if (frame >= instance->targetFrame && instance->targetFrame < prevFrame)
												{
													if (frame >= prevFrame)
													{
														instance->flags &= 0xFDFFFFFF;
														SCRIPT_InstanceSplineSet(instance, instance->targetFrame, NULL, NULL, NULL);
													}
												}
												else
												{
													if (frame < prevFrame && frame >= instance->targetFrame)
													{
														if (instance->targetFrame + maxFrames >= prevFrame)
														{
															instance->flags &= 0xFDFFFFFF;
															SCRIPT_InstanceSplineSet(instance, instance->targetFrame, NULL, NULL, NULL);
														}
													}
												}
											}
											else
											{
												if (instance->targetFrame >= frame && prevFrame < instance->targetFrame)
												{
													instance->flags &= 0xFDFFFFFF;
													SCRIPT_InstanceSplineSet(instance, instance->targetFrame, NULL, NULL, NULL);
												}
												else
												{
													if (prevFrame < frame)
													{
														if (prevFrame + maxFrames >= instance->targetFrame)
														{
															instance->flags &= 0xFDFFFFFF;
															SCRIPT_InstanceSplineSet(instance, instance->targetFrame, NULL, NULL, NULL);
														}
													}
												}
											}
										}

										if ((instance->splineFlags & 0x2))
										{
											if ((gameTrackerX.debugFlags2 & 0x400000))
											{
												FONT_Print("Spline %s%d : clip(%d,%d) prevFrame=%d, frame=%d\n", instance->introName, instance->introNum, instance->clipBeg, instance->clipEnd, frame, prevFrame);
											}

											if (direction == 1)
											{
												if (instance->clipEnd < prevFrame || frame < instance->clipEnd && frame < instance->clipBeg)
												{
													if (*(unsigned int*)&multi->positional->numkeys & 0x6000000)
													{
														SCRIPT_InstanceSplineSet(instance, instance->clipBeg, NULL, NULL, NULL);
													}
													else
													{
														killTest = 1;

														SCRIPT_InstanceSplineSet(instance, instance->clipEnd, NULL, NULL, NULL);
													}
												}
											}
											else
											{
												if (prevFrame < instance->clipBeg || instance->clipBeg >= frame && instance->clipEnd < frame)
												{
													if (*(unsigned int*)&multi->positional->numkeys & 0x6000000)
													{
														SCRIPT_InstanceSplineSet(instance, instance->clipBeg, NULL, NULL, NULL);
													}
													else
													{
														killTest = 1;

														SCRIPT_InstanceSplineSet(instance, instance->clipEnd, NULL, NULL, NULL);
													}
												}
											}
										}
									}
									else
									{
										if ((gameTrackerX.debugFlags2 & 0x400000))
										{
											FONT_Print("Spline %s%d prevFrame=%d, frame=%d\n", instance->introName, instance->introNum, prevFrame, INSTANCE_GetSplineFrameNumber(instance, multi));
										}
									}
									
									if (endOfSpline > 0)
									{
										if ((instance->object->oflags & 0x10000000))
										{
											instance->flags &= 0xFFFFFBFF;
											instance->flags &= 0xFDFFFFFF;
											instance->flags |= 0x100000;
										}

										if ((instance->object->oflags & 0x20000000))
										{
											instance->flags |= 0x100000;

											INSTANCE_KillInstance(instance);
										}
										else
										{
											if ((instance->object->oflags & 0x1000))
											{
												instance->flags &= 0xFDFFFFFF;

												if ((instance->object->oflags & 0x800000))
												{
													SCRIPT_InstanceSplineInit(instance);
												}
											}
											else if ((instance->object->oflags & 0x1000000))
											{
												instance->flags &= 0xFDFFFFFF;
											}

											if (multi->positional != NULL)
											{
												if (!(multi->positional->flags & 0x4))
												{
													if (!(instance->object->oflags & 0x800000))
													{
														instance->flags ^= 0x1000000;
													}
												}
											}
											else if (multi->rotational != NULL)
											{
												if (!(multi->rotational->flags & 0x4))
												{
													if (!(instance->object->oflags & 0x800000))
													{
														instance->flags ^= 0x1000000;
													}
												}
											}

											if ((instance->object->oflags & 0x200000) && instance->introData != NULL && ((unsigned int*)instance->introData)[0] != NULL)
											{
												SIGNAL_HandleSignal(instance, (struct Signal*)(((unsigned int*)instance->introData)[0] + 8), 0);
											}
											else
											{
												if (instance->processFunc != NULL)
												{
													if ((instance->flags2 & 0x1))
													{
														INSTANCE_DeactivatedProcess(instance, &gameTrackerX);
													}
													else
													{
														instance->processFunc(instance, &gameTrackerX);
													}
												}

												if (32768 < instance->position.z - instance->oldPos.z)
												{
													INSTANCE_PlainDeath(instance);
												}

												if (instance->position.z - instance->oldPos.z < -32768)
												{
													INSTANCE_PlainDeath(instance);
												}

												if (INSTANCE_Query(instance, 0x2F) != 0)
												{
													gameTrackerX.streamFlags |= 0x4;
												}
											}
										}
									}
									else
									{
										if (instance->processFunc != NULL)
										{
											if ((instance->flags2 & 0x1))
											{
												INSTANCE_DeactivatedProcess(instance, &gameTrackerX);
											}
											else
											{
												instance->processFunc(instance, &gameTrackerX);
											}
										}

										if (32768 < instance->position.z - instance->oldPos.z)
										{
											INSTANCE_PlainDeath(instance);
										}

										if (instance->position.z - instance->oldPos.z < -32768)
										{
											INSTANCE_PlainDeath(instance);
										}

										if (INSTANCE_Query(instance, 0x2F) != 0)
										{
											gameTrackerX.streamFlags |= 0x4;
										}
									}
								}
								else
								{
									if (instance->processFunc != NULL)
									{
										if ((instance->flags2 & 0x1))
										{
											INSTANCE_DeactivatedProcess(instance, &gameTrackerX);
										}
										else
										{
											instance->processFunc(instance, &gameTrackerX);
										}
									}

									if (32768 < instance->position.z - instance->oldPos.z)
									{
										INSTANCE_PlainDeath(instance);
									}

									if (instance->position.z - instance->oldPos.z < -32768)
									{
										INSTANCE_PlainDeath(instance);
									}

									if (INSTANCE_Query(instance, 0x2F) != 0)
									{
										gameTrackerX.streamFlags |= 0x4;
									}
								}
							}
							else
							{
								if (instance->processFunc != NULL)
								{
									if ((instance->flags2 & 0x1))
									{
										INSTANCE_DeactivatedProcess(instance, &gameTrackerX);
									}
									else
									{
										instance->processFunc(instance, &gameTrackerX);
									}
								}

								if (32768 < instance->position.z - instance->oldPos.z)
								{
									INSTANCE_PlainDeath(instance);
								}

								if (instance->position.z - instance->oldPos.z < -32768)
								{
									INSTANCE_PlainDeath(instance);
								}

								if (INSTANCE_Query(instance, 0x2F) != 0)
								{
									gameTrackerX.streamFlags |= 0x4;
								}
							}
						}
					}
				}
			}

			instance = instance->next;
		}
	}
}

struct _Instance* INSTANCE_BirthObject(struct _Instance* parent, struct Object* object, int modelNum)
{
#if defined(PSX_VERSION)
	struct _Instance* instance;
	int i;

	if (object != NULL)
	{
		instance = INSTANCE_NewInstance(gameTrackerX.instanceList);

		if (instance != NULL)
		{
			INSTANCE_DefaultInit(instance, object, modelNum);
			
			instance->position.x = parent->position.x;
			instance->position.y = parent->position.y;
			instance->position.z = parent->position.z;
			
			instance->initialPos.x = instance->position.x;
			instance->initialPos.y = instance->position.y;
			instance->initialPos.z = instance->position.z;
			
			instance->oldPos.x = parent->position.x;
			instance->oldPos.y = parent->position.y;
			instance->oldPos.z = parent->position.z;
			
			instance->rotation.x = parent->rotation.x;
			instance->rotation.y = parent->rotation.y;
			instance->rotation.z = parent->rotation.z;
			
			instance->scale.x = parent->scale.x;
			instance->scale.y = parent->scale.y;
			instance->scale.z = parent->scale.z;
			instance->scale.pad = parent->scale.pad;
			
			instance->lightGroup = parent->lightGroup;
			instance->spectralLightGroup = parent->spectralLightGroup;
			
			instance->currentStreamUnitID = parent->currentStreamUnitID;
			instance->birthStreamUnitID = parent->birthStreamUnitID;
			instance->introUniqueID = GlobalSave->CurrentBirthID;

			GlobalSave->CurrentBirthID++;
			
			strcpy(instance->introName, object->name);

			i = 0;

			do
			{
				if (i >= strlen(instance->introName))
				{
					goto loc_80034008;//:(
				}

			} while (instance->introName[i++] != '\x5F');

			instance->introName[i] = 0;

loc_80034008://:(

			instance->parent = parent;
			instance->intro = parent->intro;
			instance->introData = parent->introData;

			LIGHT_GetAmbient((struct _ColorType*)&instance->light_color, instance);

			if ((instance->object->oflags & 0x100))
			{
				INSTANCE_BuildStaticShadow(instance);
			}

			if (SCRIPT_GetMultiSpline(instance, NULL, NULL) == NULL)
			{
				instance->flags |= 0x100000;
			}

			if ((parent->flags2 & 0x8000000))
			{
				instance->flags2 |= 0x8000000;
			}

			INSTANCE_InsertInstanceGroup(gameTrackerX.instanceList, instance);

			OBTABLE_GetInstanceCollideFunc(instance);
			OBTABLE_GetInstanceProcessFunc(instance);
			OBTABLE_GetInstanceQueryFunc(instance);
			OBTABLE_GetInstanceMessageFunc(instance);
			OBTABLE_GetInstanceAdditionalCollideFunc(instance);

			instance->flags |= 0x2;

			OBTABLE_InstanceInit(instance);

			EVENT_AddInstanceToInstanceList(instance);

			INSTANCE_InitEffects(instance, object);

			return instance;
		}
	}
	
	return NULL;

#elif 0//defined(PC_VERSION)
	struct _InstanceList* instanceList; // eax
	struct _InstancePool* pool; // ecx
	int numFreeInstances; // edx
	struct _InstancePool* v6; // ecx
	struct _Instance* first_free; // ebp
	struct _Instance* first; // ecx
	int v9; // esi
	struct _InstanceList* v10; // esi
	int v11; // eax
	__int16 numberOfEffects; // ax
	int v13; // esi

	if (!object)
		return 0;
	instanceList = gameTrackerX.instanceList;
	pool = gameTrackerX.instanceList->pool;
	numFreeInstances = pool->numFreeInstances;
	if (numFreeInstances)
	{
		pool->numFreeInstances = numFreeInstances - 1;
		v6 = instanceList->pool;
		first_free = v6->first_free;
		v6->first_free = first_free->next;
		first = instanceList->first;
		instanceList->first = first_free;
		first_free->next = first;
		if (first)
			first->prev = first_free;
		first_free->prev = 0;
		first_free->instanceID = instanceList->pool->nextInstanceID++;
		++instanceList->numInstances;
	}
	else
	{
		GXFilePrint("ran out of instances need more than %d - contact a programmer\n", 62);
		first_free = 0;
	}
	if (!first_free)
		return 0;
	INSTANCE_DefaultInit(first_free, object, modelNum);
	first_free->position = parent->position;
	first_free->initialPos = parent->position;
	first_free->oldPos = parent->position;
	first_free->rotation = parent->rotation;
	first_free->scale = parent->scale;
	first_free->lightGroup = parent->lightGroup;
	first_free->spectralLightGroup = parent->spectralLightGroup;
	first_free->currentStreamUnitID = parent->currentStreamUnitID;
	first_free->birthStreamUnitID = parent->birthStreamUnitID;
	first_free->introUniqueID = GlobalSave->CurrentBirthID++;
	strcpy(first_free->introName, object->name);
	v9 = 0;
	if (strlen(first_free->introName))
	{
		while (first_free->introName[v9] != 95)
		{
			if (++v9 >= strlen(first_free->introName))
				goto LABEL_13;
		}
		first_free->introName[v9] = 0;
	}
LABEL_13:
	first_free->parent = parent;
	first_free->intro = parent->intro;
	first_free->introData = parent->introData;
	LIGHT_GetAmbient((struct _ColorType*)&first_free->light_color, first_free);
	if (!SCRIPT_GetMultiSpline(first_free, 0, 0))
		first_free->flags |= 0x100000u;
	if ((parent->flags2 & 0x8000000) != 0)
		first_free->flags2 |= 0x8000000u;
	v10 = gameTrackerX.instanceList;
	v11 = INSTANCE_InstanceGroupNumber(first_free);
	LIST_InsertFunc(&v10->group[v11], &first_free->node);
	OBTABLE_GetInstanceCollideFunc(first_free);
	OBTABLE_GetInstanceProcessFunc(first_free);
	OBTABLE_GetInstanceQueryFunc(first_free);
	OBTABLE_GetInstanceMessageFunc(first_free);
	OBTABLE_GetInstanceAdditionalCollideFunc(first_free);
	first_free->flags |= 2u;
	OBTABLE_InstanceInit(first_free);
	EVENT_AddInstanceToInstanceList(first_free);
	if ((object->oflags2 & 0x100) == 0)
	{
		numberOfEffects = object->numberOfEffects;
		if (numberOfEffects)
		{
			v13 = 0;
			if (numberOfEffects > 0)
			{
				do
					FX_StartInstanceEffect(first_free, (unsigned __int8*)&object->effectList[v13++], 1);
				while (v13 < object->numberOfEffects);
			}
		}
	}
	return first_free;
#endif
}

void INSTANCE_BuildStaticShadow(struct _Instance* instance)
{
}

void INSTANCE_DefaultInit(struct _Instance* instance, struct Object* object, int modelNum)//Matching - 96.32%
{
	int i;
	int j;
	int numHPrims;
	int numModels;
	struct _HPrim* hprim;
	struct _Model** pModel;
	struct _HModel* hmodel;
	struct _Model* model;
	struct _Segment* seg;
	struct _HInfo* hinfo;
	int k;
	struct _HFace* hface;
	struct _HSphere* hsphere;
	struct _HBox* hbox;

	memset(&instance->flags, 0, sizeof(struct _Instance) - 0x14);

	instance->object = object;
	instance->data = object->data;
	instance->currentModel = modelNum;
	instance->cachedTFace = -1;
	instance->cachedTFaceLevel = NULL;

	if (object->animList != NULL && !(object->oflags2 & 0x40000000))
	{
		G2Anim_Init(&instance->anim, object->modelList[modelNum]);
		G2Anim_SwitchToKeylist(&instance->anim, G2Instance_GetKeylist(instance, 0), 0);
		G2Anim_SetCallback(&instance->anim, INSTANCE_DefaultAnimCallback, instance);
	}

	if ((object->oflags & 0x4000000))
	{
		instance->flags2 |= 0x4;
	}

	if ((object->oflags & 0x200))
	{
		instance->flags2 |= 0x40;
	}

	if ((object->oflags & 0x8))
	{
		instance->flags2 |= 0x8000000;
	}

	if (!(object->oflags & 0x1000800))
	{
		instance->flags |= 0x2000000;
	}

	if ((object->oflags & 0x20000000))
	{
		instance->flags2 |= 0x20;
	}

	numModels = object->numModels;
	pModel = object->modelList;

	numHPrims = 0;

	for (i = numModels; i != 0; i--, pModel++)
	{
		for (j = pModel[0]->numSegments, seg = pModel[0]->segmentList; j != 0; seg++, j--)
		{


			hinfo = seg->hInfo;

			if (hinfo != NULL)
			{
				numHPrims += hinfo->numHFaces + hinfo->numHSpheres + hinfo->numHBoxes;
			}
		}
	}

	if (numHPrims != 0)
	{
		hmodel = (struct _HModel*)MEMPACK_Malloc((instance->object->numModels + numHPrims) * 8, 0xE);

		instance->hModelList = hmodel;
		pModel = object->modelList;
		hprim = (struct _HPrim*)hmodel + object->numModels;

		for (i = numModels; i != 0; i--, pModel++, hmodel++)
		{
			model = pModel[0];
			hmodel->numHPrims = 0;
			hmodel->hPrimList = hprim;
			seg = model->segmentList;

			for (j = 0; j < model->numSegments; j++, seg++)
			{
				hinfo = seg->hInfo;
				if (hinfo != NULL)
				{
					hface = hinfo->hfaceList;
					hsphere = hinfo->hsphereList;
					hbox = hinfo->hboxList;

					hmodel->numHPrims += hinfo->numHFaces + hinfo->numHSpheres + hinfo->numHBoxes;
					for (k = hinfo->numHFaces; k != 0; hprim++, hface++, k--)
					{
						hprim->hpFlags = 0x4D;
						hprim->withFlags = 0x24;
						hprim->type = 2;
						hprim->segment = j;
						hprim->data.hface = hface;
					}

					for (k = hinfo->numHSpheres; k != 0; hprim++, hsphere++, k--)
					{
						hprim->hpFlags = 0x2F;
						hprim->withFlags = 0x76;
						hprim->type = 1;
						hprim->segment = j;
						hprim->data.hsphere = hsphere;
					}

					for (k = hinfo->numHBoxes; k != 0; hprim++, hbox++, k--)
					{
						hprim->hpFlags = 0x1D;
						hprim->withFlags = 0x24;
						hprim->type = 5;
						hprim->segment = j;
						hprim->data.hbox = hbox;
					}
				}
			}
		}
	}
	else
	{
		instance->hModelList = NULL;
		instance->flags2 |= 0x40000;
	}

	if (instance->maxCheckDistance == 0)
	{
		instance->maxCheckDistance = 12000;
	}
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_PlainDeath(struct _Instance *instance /*$s5*/)
void INSTANCE_PlainDeath(struct _Instance* instance)
{ // line 1793, offset 0x80034230
#if defined(PC_VERSION)
	struct _Instance* v1; // edi
	int flags; // ecx
	struct Object* object; // ecx
	int flags2; // ebx
	struct _Instance* v5; // eax
	int v6; // ecx
	int v7; // eax

	v1 = instance;
	flags = instance->flags;
	flags &= ~4u;
	instance->flags = flags;
	object = instance->object;
	if ((object->oflags2 & 4) != 0)
	{
		flags2 = instance->flags2;
		flags2 |= 0x10u;
		instance->flags2 = flags2;
		SOUND_ProcessInstanceSounds(
			object->soundData,
			instance->soundInstanceTbl,
			&instance->position,
			object->oflags2 & 0x2000000,
			flags2 & 0x8000000,
			0,
			0,
			&instance->flags2);
		SOUND_ProcessInstanceSounds(
			instance->object->soundData,
			instance->soundInstanceTbl,
			&instance->position,
			instance->object->oflags2 & 0x2000000,
			instance->flags2 & 0x8000000,
			0,
			0,
			&instance->flags2);
	}
	v5 = (struct _Instance*)*((DWORD*)gameTrackerX.instanceList + 1);
	if (v5)
	{
		do
		{
			if (v5->introUniqueID == v1->attachedID)
				break;
			v5 = v5->next;
		} while (v5);
		if (v5)
		{
			v6 = v5->flags2;
			v6 = v6 & ~0x80;
			v5->flags2 = v6;
		}
	}
	SAVE_MarkDeadDead(v1);
	v7 = v1->flags;
	v7 = v7 | 0x20;
	v1->flags = v7;
#else
	UNIMPLEMENTED();
#endif
}

void INSTANCE_KillInstance(struct _Instance* instance)
{
#if defined(PSX_VERSION)

	if (!(instance->flags & 0x20))
	{
		INSTANCE_PlainDeath(instance);
	}

#elif defined(PC_VERSION)
	if ((instance->flags & 0x20) == 0)
		INSTANCE_PlainDeath(instance);
#endif
}

unsigned long INSTANCE_Query(struct _Instance* Inst, int Query)
{
#if defined(PSX_VERSION)
	unsigned long (*Func)(struct _Instance*, unsigned long);

	Func = Inst->queryFunc;

	if (Func != NULL)
	{
		return Func(Inst, Query);
	}

	return 0;

#elif defined(PC_VERSION)
	unsigned int result; // eax

	result = (unsigned int)Inst->queryFunc;
	if (result)
		return ((int(__cdecl*)(struct _Instance*, int))result)(Inst, Query);
	return result;
#endif
}

void INSTANCE_Post(struct _Instance* Inst, int Message, int Data)
{
#if defined(PSX_VERSION)

	void (*Func)(_Instance*, unsigned long, unsigned long);

	Func = Inst->messageFunc;

	if (Func != NULL)
	{
		INSTANCE_ForceActive(Inst);

		Func(Inst, Message, Data);
	}

#elif defined(PC_VERSION)
	void(* messageFunc)(); // edi
	int flags2; // eax
	int flags; // ecx
	struct Object* object; // edx
	int v7; // eax

	messageFunc = Inst->messageFunc;
	if (messageFunc)
	{
		flags2 = Inst->flags2;
		if ((flags2 & 1) != 0)
		{
			flags = Inst->flags;
			object = Inst->object;
			flags2 = flags2 & ~1;
			Inst->flags2 = flags2;
			if ((flags & 0x40000) != 0)
			{
				v7 = flags2 | 0x20000000;
				Inst->flags = flags & ~0x40000u;
			}
			else
			{
				v7 = flags2 & ~0x20000000u;
			}
			Inst->flags2 = v7;
			if (object->animList)
			{
				if ((object->oflags2 & 0x40000000) == 0)
					G2Anim_Restore(&Inst->anim);
			}
		}
		((void(__cdecl*)(struct _Instance*, int, int))messageFunc)(Inst, Message, Data);
	}
#endif
}

void INSTANCE_Broadcast(struct _Instance* sender, long whatAmIMask, int Message, int Data)
{
#if defined(PSX_VERSION)
	struct _Instance* instance;
	int plane;

	instance = gameTrackerX.instanceList->first;

	plane = gameTrackerX.gameData.asmData.MorphType;

	while (instance != NULL)
	{
		if (instance != sender)
		{
			if ((INSTANCE_Query(instance, 1) & whatAmIMask))
			{
				if (INSTANCE_InPlane(instance, plane))
				{
					INSTANCE_Post(instance, Message, Data);
				}
			}
		}

		instance = instance->next;
	}

#elif defined(PC_VERSION)
	int MorphType; // ebp
	struct _Instance* i; // esi
	int queryFunc; // eax
	struct Object* object; // eax
	int v8; // eax
	void(* messageFunc)(); // edi
	int flags; // ecx
	struct Object* v11; // eax
	unsigned int v12; // edx
	unsigned int v13; // ecx

	MorphType = gameTrackerX.gameData.asmData.MorphType;
	for (i = (struct _Instance*)*((DWORD*)gameTrackerX.instanceList + 1); i; i = i->next)
	{
		if (i != sender)
		{
			queryFunc = (int)i->queryFunc;
			if (queryFunc)
				queryFunc = ((int(__cdecl*)(struct _Instance*, int))queryFunc)(i, 1);
			if ((queryFunc & whatAmIMask) != 0)
			{
				object = i->object;
				if (object)
				{
					if ((object->oflags2 & 0x2000000) == 0
						|| ((i->flags2 & 0x8000000) == 0 ? (v8 = MorphType == 0) : (v8 = MorphType), v8))
					{
						messageFunc = i->messageFunc;
						if (messageFunc)
						{
							if ((i->flags2 & 1) != 0)
							{
								flags = i->flags;
								v11 = i->object;
								i->flags2 &= ~1u;
								if ((flags & 0x40000) != 0)
								{
									v12 = flags & ~0x40000u;
									v13 = i->flags2 | 0x20000000;
									i->flags = v12;
								}
								else
								{
									v13 = i->flags2 & ~0x20000000u;
								}
								i->flags2 = v13;
								if (v11->animList)
								{
									if ((v11->oflags2 & 0x40000000) == 0)
										G2Anim_Restore(&i->anim);
								}
							}
							((void(__cdecl*)(struct _Instance*, int, int))messageFunc)(i, Message, Data);
						}
					}
				}
			}
		}
	}
#endif
}

int INSTANCE_InPlane(struct _Instance* instance, int plane)
{
#if defined(PSX_VERSION)
	UNIMPLEMENTED();
	return 0;
#elif defined(PC_VERSION)
	struct Object* object; // eax
	int result; // eax

	object = instance->object;
	result = 0;
	if (object)
	{
		if ((object->oflags2 & 0x2000000) == 0)
			return 1;
		if ((instance->flags2 & 0x8000000) != 0 ? plane : plane == 0)
			return 1;
	}
	return result;
#endif
}

long INSTANCE_FindWithID(long uniqueID)
{
#if defined(PSX_VERSION)
	struct _Instance* instance;
	struct _Instance* next;
	long ret;

	instance = gameTrackerX.instanceList->first;
	ret = 0;

	while (instance != NULL)
	{
		next = instance->next;

		if (instance->introUniqueID == uniqueID)
		{
			ret = 1;
			break;
		}

		instance = next;
	}

	return ret;

#elif defined(PC_VERSION)
	struct _Instance* v1; // ecx
	int result; // eax
	struct _Instance* v3; // edx

	v1 = (struct _Instance*)*((DWORD*)gameTrackerX.instanceList + 1);
	result = 0;
	if (v1)
	{
		while (1)
		{
			v3 = v1->next;
			if (v1->introUniqueID == uniqueID)
				break;
			v1 = v1->next;
			if (!v3)
				return result;
		}
		return 1;
	}
	return result;
#endif
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ INSTANCE_FindWithName(long areaID /*$s3*/, char *instanceName /*$s4*/, struct _Instance *startInstance /*$a2*/)
struct _Instance* INSTANCE_FindWithName(long areaID, char* instanceName, struct _Instance* startInstance)
{ // line 1995, offset 0x8003457c
#if defined(PC_VERSION)
	struct _Instance* next; // esi
	struct _Instance* v4; // edi
	struct _Instance* v6; // edi
	struct _Instance* v7; // [esp+10h] [ebp-4h]

	next = (struct _Instance*)*((DWORD*)gameTrackerX.instanceList + 1);
	v7 = 0;
	if (startInstance)
		next = startInstance->next;
	if (areaID)
	{
		if (next)
		{
			while (1)
			{
				v4 = next->next;
				if (next->birthStreamUnitID == areaID && !_strcmpi(next->introName, instanceName))
					break;
				next = v4;
				if (!v4)
					return 0;
			}
			return next;
		}
	}
	else if (next)
	{
		while (1)
		{
			v6 = next->next;
			if (!_strcmpi(next->introName, instanceName))
				break;
			next = v6;
			if (!v6)
				return 0;
		}
		return next;
	}
	return v7;
#else
	UNIMPLEMENTED();
	return NULL;
#endif
}


// autogenerated function stub: 
// struct Intro * /*$ra*/ INSTANCE_FindIntro(long areaID /*$a0*/, long introUniqueID /*$s1*/)
struct Intro* INSTANCE_FindIntro(long areaID, long introUniqueID)
{ // line 2065, offset 0x80034650
#if defined(PC_VERSION)
	struct Intro* v2; // ebx
	struct Level* LevelWithID; // eax
	int numIntros; // edx
	int v5; // ecx
	struct Intro* introList; // edi
	int* i; // eax

	v2 = 0;
	LevelWithID = STREAM_GetLevelWithID(areaID);
	if (LevelWithID)
	{
		numIntros = LevelWithID->numIntros;
		v5 = 0;
		if (numIntros > 0)
		{
			introList = LevelWithID->introList;
			for (i = &introList->UniqueID; introUniqueID != *i; i += 19)
			{
				if (++v5 >= numIntros)
					return 0;
			}
			return &introList[v5];
		}
	}
	return v2;
#else
	UNIMPLEMENTED();
	return NULL;
#endif
}

struct _Instance* INSTANCE_Find(long introUniqueID)
{
#if defined(PSX_VERSION)
	struct _Instance* instance;

	instance = gameTrackerX.instanceList->first;

	while (instance != NULL)
	{
		if (instance->introUniqueID == introUniqueID)
		{
			break;
		}

		instance = instance->next;
	}

	return instance;

#elif defined(PC_VERSION)
	struct _Instance* result; // eax

	for (result = gameTrackerX.instanceList->first; result; result = result->next)
	{
		if (result->introUniqueID == introUniqueID)
			break;
	}
	return result;
#endif
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ INSTANCE_IntroduceSavedInstance(struct _SavedIntro *savedIntro /*$s2*/, struct _StreamUnit *streamUnit /*$a1*/, int *deleted /*$fp*/)
struct _Instance* INSTANCE_IntroduceSavedInstance(struct _SavedIntro* savedIntro, struct _StreamUnit* streamUnit, int* deleted)
{ // line 2102, offset 0x80034714
#if 0//defined(PC_VERSION)
	struct _Instance* first_free; // ebp
	int v5; // esi
	struct _Instance* first; // eax
	struct _Instance* next; // ecx
	int v8; // edx
	struct _ObjectTracker* ObjectTracker; // eax
	struct _ObjectTracker* v10; // esi
	struct Object* v11; // edx
	struct _Instance* i; // eax
	struct _InstanceList* instanceList; // eax
	struct _InstancePool* pool; // ecx
	int numFreeInstances; // edx
	struct _InstancePool* v16; // ecx
	struct _Instance* v17; // ecx
	struct Level* LevelWithID; // eax
	struct _Terrain* terrain; // eax
	int numIntros; // ecx
	struct Intro* introList; // eax
	__int16 z; // ax
	struct _InstanceList* v23; // esi
	int v24; // eax
	int flags; // eax
	int v26; // ecx
	struct Object* v27; // eax
	unsigned int v28; // edx
	unsigned int v29; // ecx
	int flags2; // eax
	int v31; // eax
	unsigned int v32; // eax
	__int16* introData; // esi
	__int16 j; // ax
	__int16 v35; // ax
	struct Object* v36; // edx
	int v37; // ecx
	int v38; // eax
	void(__stdcall * messageFunc)(); // esi
	int v40; // edi
	int v41; // ecx
	struct Object* v42; // eax
	unsigned int v43; // edx
	unsigned int v44; // ecx
	__int16 numberOfEffects; // ax
	int v46; // esi
	int v47; // eax
	struct _Instance* v49; // [esp+10h] [ebp-14h]
	_Position* p_globalOffset; // [esp+14h] [ebp-10h]
	int v51; // [esp+14h] [ebp-10h]
	char name[4]; // [esp+18h] [ebp-Ch] BYREF
	int v53; // [esp+1Ch] [ebp-8h]
	char v54; // [esp+20h] [ebp-4h]
	struct _SavedIntro* savedIntroa; // [esp+28h] [ebp+4h]
	struct Object* object; // [esp+2Ch] [ebp+8h]

	first_free = 0;
	v5 = 0;
	v49 = 0;
	p_globalOffset = &streamUnit->level->terrain->BSPTreeArray->globalOffset;
	first = gameTrackerX.instanceList->first;
	if (first)
	{
		while (1)
		{
			next = first->next;
			if (first->introUniqueID == savedIntro->introUniqueID)
				break;
			first = first->next;
			if (!next)
				goto LABEL_6;
		}
		v5 = 1;
	}
LABEL_6:
	if (!v5)
	{
		v8 = *(_DWORD*)&savedIntro->name[4];
		*(_DWORD*)name = *(_DWORD*)savedIntro->name;
		v53 = v8;
		v54 = 0;
		ObjectTracker = STREAM_GetObjectTracker(name);
		v10 = ObjectTracker;
		if (ObjectTracker)
		{
			v11 = ObjectTracker->object;
			object = v11;
			if (ObjectTracker->objectStatus == 2)
			{
				if (!savedIntro->attachedUniqueID)
					goto LABEL_73;
				for (i = gameTrackerX.instanceList->first; i; i = i->next)
				{
					if (i->introUniqueID == savedIntro->attachedUniqueID)
						break;
				}
				v49 = i;
				if (i)
				{
				LABEL_73:
					if ((v11->oflags2 & 0x10000000) == 0 || (OBTABLE_InitAnimPointers(v10), (object->oflags2 & 0x10000000) == 0))
					{
						instanceList = gameTrackerX.instanceList;
						pool = gameTrackerX.instanceList->pool;
						numFreeInstances = pool->numFreeInstances;
						if (numFreeInstances)
						{
							pool->numFreeInstances = numFreeInstances - 1;
							v16 = instanceList->pool;
							first_free = v16->first_free;
							v16->first_free = first_free->next;
							v17 = instanceList->first;
							instanceList->first = first_free;
							first_free->next = v17;
							if (v17)
								v17->prev = first_free;
							first_free->prev = 0;
							first_free->instanceID = instanceList->pool->nextInstanceID++;
							++instanceList->numInstances;
						}
						else
						{
							GXFilePrint("ran out of instances need more than %d - contact a programmer\n", 62);
							first_free = 0;
						}
						if (!first_free)
							goto LABEL_69;
						++v10->numInUse;
						INSTANCE_DefaultInit(first_free, object, 0);
						strcpy(first_free->introName, name);
						first_free->introUniqueID = savedIntro->introUniqueID;
						first_free->currentStreamUnitID = savedIntro->streamUnitID;
						first_free->birthStreamUnitID = savedIntro->birthUnitID;
						LIGHT_GetAmbient((struct _ColorType*)&first_free->light_color, first_free);
						LevelWithID = STREAM_GetLevelWithID(first_free->birthStreamUnitID);
						if (LevelWithID
							&& (terrain = LevelWithID->terrain,
								numIntros = terrain->numIntros,
								introList = terrain->introList,
								numIntros))
						{
							while (introList->UniqueID != first_free->introUniqueID)
							{
								++introList;
								if (!--numIntros)
									goto LABEL_26;
							}
						}
						else
						{
						LABEL_26:
							introList = 0;
						}
						if (introList)
						{
							first_free->intro = introList;
							first_free->introData = introList->data;
						}
						else
						{
							first_free->intro = 0;
							first_free->introData = 0;
						}
						first_free->position.x = p_globalOffset->x + savedIntro->position.x;
						first_free->position.y = p_globalOffset->y + savedIntro->position.y;
						first_free->position.z = p_globalOffset->z + savedIntro->position.z;
						*(_DWORD*)&first_free->initialPos.x = *(_DWORD*)&first_free->position.x;
						first_free->initialPos.z = first_free->position.z;
						z = first_free->position.z;
						*(_DWORD*)&first_free->oldPos.x = *(_DWORD*)&first_free->position.x;
						first_free->oldPos.z = z;
						*(_SmallRotation*)&first_free->rotation.x = savedIntro->smallRotation;
						first_free->scale.x = 4096;
						first_free->scale.y = 4096;
						first_free->scale.z = 4096;
						first_free->lightGroup = savedIntro->lightGroup;
						first_free->spectralLightGroup = savedIntro->specturalLightGroup;
						v23 = gameTrackerX.instanceList;
						v24 = INSTANCE_InstanceGroupNumber(first_free);
						LIST_InsertFunc(&v23->group[v24], &first_free->node);
						OBTABLE_GetInstanceCollideFunc(first_free);
						OBTABLE_GetInstanceProcessFunc(first_free);
						OBTABLE_GetInstanceQueryFunc(first_free);
						OBTABLE_GetInstanceMessageFunc(first_free);
						OBTABLE_GetInstanceAdditionalCollideFunc(first_free);
						OBTABLE_InstanceInit(first_free);
						v51 = first_free->flags2 & 0x20000;
						flags = first_free->flags;
						first_free->flags = savedIntro->flags;
						savedIntroa = (struct _SavedIntro*)(flags & 0x20);
						first_free->flags2 = savedIntro->flags2 & ~1u;
						if (v49)
						{
							if ((v49->flags2 & 1) != 0)
							{
								v26 = v49->flags;
								v27 = v49->object;
								v49->flags2 &= ~1u;
								if ((v26 & 0x40000) != 0)
								{
									v28 = v26 & ~0x40000u;
									v29 = v49->flags2 | 0x20000000;
									v49->flags = v28;
								}
								else
								{
									v29 = v49->flags2 & ~0x20000000u;
								}
								v49->flags2 = v29;
								if (v27->animList)
								{
									if ((v27->oflags2 & 0x40000000) == 0)
										G2Anim_Restore(&v49->anim);
								}
							}
							flags2 = v49->flags2;
							LOBYTE(flags2) = flags2 | 0x80;
							v49->flags2 = flags2;
						}
						v31 = first_free->flags2;
						if ((first_free->flags & 0x40000) != 0)
							v32 = v31 | 0x20000000;
						else
							v32 = v31 & ~0x20000000u;
						first_free->flags2 = v32;
						first_free->flags = first_free->flags & ~0x2140000u | 0x100000;
						MORPH_SetupInstanceFlags(first_free);
						if (first_free->intro)
						{
							introData = (__int16*)first_free->introData;
							if (introData)
							{
								if ((first_free->flags & 2) == 0)
								{
									for (j = *introData; j; introData += 2 * v37 + 2)
									{
										if (j == 18)
										{
											v35 = introData[2];
											v36 = first_free->object;
											first_free->currentModel = v35;
											if (v36->numModels <= v35)
												GXFilePrint(
													"Error: Specify model num %d on a instance(%s%d) with %d models.\n",
													first_free->currentModel,
													first_free->introName,
													first_free->introNum,
													v36->numModels);
										}
										v37 = introData[1];
										j = introData[2 * v37 + 2];
									}
								}
							}
						}
						if (savedIntro->shiftedSaveSize > 0xAu)
						{
							v38 = SetControlSaveDataData(4 * savedIntro->shiftedSaveSize - 40, &savedIntro[1]);
							messageFunc = first_free->messageFunc;
							v40 = v38;
							if (messageFunc)
							{
								if ((first_free->flags2 & 1) != 0)
								{
									v41 = first_free->flags;
									v42 = first_free->object;
									first_free->flags2 &= ~1u;
									if ((v41 & 0x40000) != 0)
									{
										v43 = v41 & 0xFFFBFFFF;
										v44 = first_free->flags2 | 0x20000000;
										first_free->flags = v43;
									}
									else
									{
										v44 = first_free->flags2 & 0xDFFFFFFF;
									}
									first_free->flags2 = v44;
									if (v42->animList)
									{
										if ((v42->oflags2 & 0x40000000) == 0)
											G2Anim_Restore(&first_free->anim);
									}
								}
								((void(__cdecl*)(struct _Instance*, int, int))messageFunc)(first_free, 1048583, v40);
							}
						}
						EVENT_AddInstanceToInstanceList(first_free);
						if ((object->oflags2 & 0x100) == 0)
						{
							numberOfEffects = object->numberOfEffects;
							if (numberOfEffects)
							{
								v46 = 0;
								if (numberOfEffects > 0)
								{
									do
										FX_StartInstanceEffect(first_free, (unsigned __int8*)&object->effectList[v46++], 1);
									while (v46 < object->numberOfEffects);
								}
							}
						}
						if (savedIntroa)
						{
							v47 = first_free->flags;
							LOBYTE(v47) = v47 | 0x20;
							first_free->flags = v47;
						}
						if (v51)
						{
							first_free->flags2 |= 0x20000u;
							SAVE_DeleteInstance(first_free);
							*deleted = 1;
						}
					}
				}
			}
		}
		if (!first_free)
			LABEL_69:
		SAVE_BufferIntro(savedIntro);
	}
	return first_free;
#else
UNIMPLEMENTED();
	return 0;
#endif
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ INSTANCE_IntroduceSavedInstanceWithIntro(struct _SavedIntroWithIntro *savedIntro /*$s4*/, struct _StreamUnit *streamUnit /*$s6*/, int *deleted /*stack 8*/)
struct _Instance* INSTANCE_IntroduceSavedInstanceWithIntro(struct _SavedIntroWithIntro* savedIntro, struct _StreamUnit* streamUnit, int* deleted)
{ // line 2327, offset 0x80034b8c
	/* begin block 1 */
		// Start line: 2328
		// Start offset: 0x80034B8C
		// Variables:
	struct _ObjectTracker* objectTracker; // $s1
	struct Object* object; // $s7
	struct _Instance* instance; // $s0
	_Position* levelOffset; // $fp
	struct Level* level; // $v1
	struct Intro* intro; // $s2
	struct _Instance* attachedInst; // $s5

/* begin block 1.1 */
	// Start line: 2372
	// Start offset: 0x80034CC4
	// Variables:
	int remove; // $s1
	int nosave; // $s2

/* begin block 1.1.1 */
	// Start line: 2376
	// Start offset: 0x80034CC4
	// Variables:
	short _x0; // $v0
	short _y0; // $a0
	short _z0; // $v1
	short _x1; // $a1
	short _y1; // $a2
	short _z1; // $a3
	_Position* _v; // $v0
	_Position* _v0; // $v1
/* end block 1.1.1 */
// End offset: 0x80034CC4
// End Line: 2376

/* begin block 1.1.2 */
	// Start line: 2513
	// Start offset: 0x80034F4C
/* end block 1.1.2 */
// End offset: 0x80034F68
// End Line: 2524
/* end block 1.1 */
// End offset: 0x80034F9C
// End Line: 2533
/* end block 1 */
// End offset: 0x80034FCC
// End Line: 2549

/* begin block 2 */
	// Start line: 5380
/* end block 2 */
// End Line: 5381
	UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_SpatialRelationships(struct _InstanceList *instanceList /*$s4*/)
void INSTANCE_SpatialRelationships(struct _InstanceList* instanceList)
{ // line 2596, offset 0x80035000
	/* begin block 1 */
		// Start line: 2597
		// Start offset: 0x80035000
		// Variables:
	struct _Instance* instance; // $s1
	struct _Instance* checkee; // $s0

/* begin block 1.1 */
	// Start line: 2606
	// Start offset: 0x8003504C
	// Variables:
	//MATRIX* lookMatrix; // $s0
	long checkMask; // $s3

/* begin block 1.1.1 */
	// Start line: 2615
	// Start offset: 0x80035074
	// Variables:
	//MATRIX invMatrix; // stack offset -80

/* begin block 1.1.1.1 */
	// Start line: 2624
	// Start offset: 0x800350D0
	// Variables:
	//struct evCollideInstanceStatsData data; // stack offset -48
	//MATRIX* mat; // $a2
/* end block 1.1.1.1 */
// End offset: 0x80035124
// End Line: 2634
/* end block 1.1.1 */
// End offset: 0x80035134
// End Line: 2636
/* end block 1.1 */
// End offset: 0x80035134
// End Line: 2637
/* end block 1 */
// End offset: 0x80035144
// End Line: 2639

/* begin block 2 */
	// Start line: 5192
/* end block 2 */
// End Line: 5193
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ INSTANCE_SetStatsData(struct _Instance *instance /*$s1*/, struct _Instance *checkee /*$s5*/, struct _Vector *checkPoint /*$s2*/, struct evCollideInstanceStatsData *data /*$s3*/, MATRIX *mat /*stack 16*/)
int INSTANCE_SetStatsData(struct _Instance* instance, struct _Instance* checkee, struct _Vector* checkPoint, struct evCollideInstanceStatsData* data, MATRIX* mat)
{ // line 2643, offset 0x80035164
#if defined(PC_VERSION)
	unsigned int v5; // ebp
	SVECTOR* ScratchAddr; // esi

	v5 = MATH3D_LengthXYZ(
		instance->position.x - checkPoint->x,
		instance->position.y - checkPoint->y,
		instance->position.z - checkPoint->z);
	if (v5 >= instance->maxCheckDistance)
		return 0;
	ScratchAddr = (SVECTOR*)getScratchAddr(0);
	ScratchAddr->vx = checkPoint->x - instance->position.x;
	ScratchAddr->vy = checkPoint->y - instance->position.y;
	ScratchAddr->vz = checkPoint->z - instance->position.z;
	ApplyMatrixSV(mat, ScratchAddr, (SVECTOR*)&data->relativePosition);
	data->distance = v5;
	data->instance = checkee;
	data->zDelta = ScratchAddr->vz;
	data->xyDistance = MATH3D_LengthXY(ScratchAddr->vx, ScratchAddr->vy);
	return 1;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_LinkToParent(struct _Instance *instance /*$s0*/, struct _Instance *parent /*$s1*/, int node /*$a2*/)
void INSTANCE_LinkToParent(struct _Instance* instance, struct _Instance* parent, int node)
{ // line 2672, offset 0x80035274
#if defined(PC_VERSION)
	int x; // eax
	struct _Instance* i; // edi
	void(* messageFunc)(); // edi
	int flags2; // eax
	int flags; // ecx
	struct Object* object; // edx
	int v9; // eax
	int v10; // eax

	instance->LinkSibling = parent->LinkChild;
	parent->LinkChild = instance;
	x = instance->scale.x;
	instance->LinkParent = parent;
	instance->ParentLinkNode = node;
	instance->scale.x = (x << 12) / parent->scale.x;
	instance->scale.y = (instance->scale.y << 12) / parent->scale.y;
	instance->scale.z = (instance->scale.z << 12) / parent->scale.z;
	for (i = parent->LinkChild; i; i = i->LinkSibling)
	{
		i->currentStreamUnitID = parent->currentStreamUnitID;
		INSTANCE_UpdateFamilyStreamUnitID(i);
	}
	messageFunc = parent->messageFunc;
	if (messageFunc)
	{
		flags2 = parent->flags2;
		if ((flags2 & 1) != 0)
		{
			flags = parent->flags;
			object = parent->object;
			flags2 = flags2 & ~1;
			parent->flags2 = flags2;
			if ((flags & 0x40000) != 0)
			{
				v9 = flags2 | 0x20000000;
				parent->flags = flags & ~0x40000u;
			}
			else
			{
				v9 = flags2 & 0xDFFFFFFF;
			}
			parent->flags2 = v9;
			if (object->animList && (object->oflags2 & 0x40000000) == 0)
				G2Anim_Restore(&parent->anim);
		}
		((void(__cdecl*)(struct _Instance*, int, struct _Instance*))messageFunc)(parent, 0x100012, instance);
	}
	v10 = instance->flags2;
	v10 = v10 | 8;
	instance->flags2 = v10;
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_UnlinkFromParent(struct _Instance *instance /*$s0*/)
void INSTANCE_UnlinkFromParent(struct _Instance* instance)
{ // line 2693, offset 0x80035330
	/* begin block 1 */
		// Start line: 2694
		// Start offset: 0x80035330
		// Variables:
	struct _Instance* parent; // $s1

/* begin block 1.1 */
	// Start line: 2698
	// Start offset: 0x80035354
	// Variables:
	//struct _G2EulerAngles_Type ea; // stack offset -24

/* begin block 1.1.1 */
	// Start line: 2706
	// Start offset: 0x80035370
	// Variables:
	struct _Instance* sibling; // $v1
/* end block 1.1.1 */
// End offset: 0x800353A4
// End Line: 2712
/* end block 1.1 */
// End offset: 0x80035480
// End Line: 2732
/* end block 1 */
// End offset: 0x80035480
// End Line: 2733

/* begin block 2 */
	// Start line: 6228
/* end block 2 */
// End Line: 6229
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_UnlinkChildren(struct _Instance *instance /*$s2*/)
void INSTANCE_UnlinkChildren(struct _Instance* instance)
{ // line 2735, offset 0x80035494
#if defined(PC_VERSION)
	struct _Instance* child; // edi
	void(*messageFunc)(); // ebx
	struct _Instance* sibling; // ebp
	int flags2; // eax
	int flags; // ecx
	struct Object* object; // edx
	int v7; // eax

	child = instance->LinkChild;
	if (child)
	{
		do
		{
			messageFunc = instance->messageFunc;
			sibling = child->LinkSibling;
			if (messageFunc)
			{
				flags2 = instance->flags2;
				if ((flags2 & 1) != 0)
				{
					flags = instance->flags;
					object = instance->object;
					flags2 = flags2 & ~1;
					instance->flags2 = flags2;
					if ((flags & 0x40000) != 0)
					{
						v7 = flags2 | 0x20000000;
						instance->flags = flags & ~0x40000u;
					}
					else
					{
						v7 = flags2 & ~0x20000000u;
					}
					instance->flags2 = v7;
					if (object->animList && (object->oflags2 & 0x40000000) == 0)
						G2Anim_Restore(&instance->anim);
				}
				((void(__cdecl*)(struct _Instance*, int, struct _Instance*))messageFunc)(instance, 0x100013, child);
			}
			child->LinkParent = 0;
			child->LinkSibling = 0;
			child = sibling;
		} while (sibling);
	}
	instance->LinkChild = 0;
#else
	UNIMPLEMENTED();
#endif
}

void INSTANCE_UpdateFamilyStreamUnitID(struct _Instance* instance)
{
#if defined(PSX_VERSION)
	struct _Instance* child;
	
	child = instance->LinkChild;

	while (child != NULL)
	{
		child->currentStreamUnitID = instance->currentStreamUnitID;
		INSTANCE_UpdateFamilyStreamUnitID(child);
		child = child->LinkSibling;
	}

#elif defined(PC_VERSION)
	struct _Instance* child; // esi

	for (child = instance->LinkChild; child; child = child->LinkSibling)
	{
		child->currentStreamUnitID = instance->currentStreamUnitID;
		INSTANCE_UpdateFamilyStreamUnitID(child);
	}
#endif
}

void INSTANCE_ReallyRemoveAllChildren(struct _Instance* instance)//Matching - 99.57%
{
#if defined(PSX_VERSION)
	struct _Instance* child;

	struct _Instance* sibling;

	child = instance->LinkChild;

	while (child)
	{
		sibling = child->LinkSibling;
		
		INSTANCE_ReallyRemoveAllChildren(child);
		
		INSTANCE_ReallyRemoveInstance(gameTrackerX.instanceList, child, 0);
		
		child = sibling;
	}

#elif defined(PC_VERSION)
	struct _Instance* LinkChild; // esi
	struct _Instance* LinkSibling; // edi

	LinkChild = instance->LinkChild;
	if (LinkChild)
	{
		do
		{
			LinkSibling = LinkChild->LinkSibling;
			INSTANCE_ReallyRemoveAllChildren(LinkChild);
			INSTANCE_ReallyRemoveInstance(gameTrackerX.instanceList, LinkChild, 0);
			LinkChild = LinkSibling;
		} while (LinkSibling);
	}
#else
	UNIMPLEMENTED();
#endif
}

struct _Instance* INSTANCE_GetChildLinkedToSegment(struct _Instance* instance, int segment)
{
#if defined(PSX_VERSION)
	struct _Instance* child;

	child = instance->LinkChild;

	while (child != NULL)
	{
		if (child->ParentLinkNode == segment)
		{
			break;
		}

		child = child->LinkSibling;
	}

	return child;

#elif defined(PC_VERSION)
	struct _Instance* child; // eax

	for (child = instance->LinkChild; child; child = child->LinkSibling)
	{
		if (child->ParentLinkNode == segment)
			break;
	}
	return child;
#endif
}

int INSTANCE_Linked(struct _Instance* instance1, struct _Instance* instance2)//Matching - 100%
{
#if defined(PSX_VERSION)
	while (instance1->LinkParent)
	{
		instance1 = instance1->LinkParent;
	}

	while (instance2->LinkParent)
	{
		instance2 = instance2->LinkParent;
	}

	return instance1 == instance2;
#elif defined(PC_VERSION)
	struct _Instance* root1; // edx
	struct _Instance* p0; // eax
	struct _Instance* root2; // ecx
	struct _Instance* p1; // eax

	root1 = instance1;
	for (p0 = instance1->LinkParent; p0; p0 = p0->LinkParent)
		root1 = p0;
	root2 = instance2;
	for (p1 = instance2->LinkParent; p1; p1 = p1->LinkParent)
		root2 = p1;
	return root1 == root2;
#endif
}

int INSTANCE_GetFadeValue(struct _Instance* instance)
{
#if defined(PSX_VERSION)
	int fadeValue;

	fadeValue = instance->fadeValue;

	if (gameTrackerX.gameData.asmData.MorphTime != 1000)
	{
		fadeValue = 4096 - fadeValue;

		if (MEMPACK_MemoryValidFunc((char*)instance->object) != 0)
		{
			if ((instance->object->oflags2 & 0x2000000) || (instance->LinkParent != NULL && instance->LinkParent->object->oflags2 & 0x2000000))
			{
				if((instance->flags2 & 0x8000000))
				{
					if (gameTrackerX.spectral_fadeValue * fadeValue < 0)
					{
						fadeValue = (gameTrackerX.spectral_fadeValue * fadeValue + 4095) >> 12;
					}
					else
					{
						fadeValue = (gameTrackerX.spectral_fadeValue * fadeValue) >> 12;
					}
				}
				else
				{
					if (gameTrackerX.material_fadeValue * fadeValue < 0)
					{
						fadeValue = (gameTrackerX.material_fadeValue * fadeValue + 4095) >> 12;
					}
					else
					{
						fadeValue = (gameTrackerX.material_fadeValue * fadeValue) >> 12;
					}
				}
			}
		}
		
		fadeValue -= 4096;
	}

	return fadeValue;

#elif defined(PC_VERSION)
	int result; // eax
	int v2; // esi
	struct _Instance* LinkParent; // eax
	int v4; // eax

	result = instance->fadeValue;
	if (gameTrackerX.gameData.asmData.MorphTime != 1000)
	{
		v2 = 4096 - result;
		if (MEMPACK_MemoryValidFunc((char*)instance->object))
		{
			if ((instance->object->oflags2 & 0x2000000) != 0
				|| (LinkParent = instance->LinkParent) != 0 && (LinkParent->object->oflags2 & 0x2000000) != 0)
			{
				if ((instance->flags2 & 0x8000000) != 0)
					v4 = gameTrackerX.spectral_fadeValue * v2;
				else
					v4 = gameTrackerX.material_fadeValue * v2;
				v2 = v4 / 4096;
			}
		}
		return 4096 - v2;
	}
	return result;
#endif
}

unsigned long INSTANCE_DefaultAnimCallback(struct _G2Anim_Type* anim, int sectionID, enum _G2AnimCallbackMsg_Enum message, long messageDataA, long messageDataB, struct _Instance* instance)
{
#if defined(PSX_VERSION)
	struct _AnimSoundData_Type* soundData;
	int id;
	int vol;

	if (message == G2ANIM_MSG_PLAYEFFECT)
	{
		if (messageDataA == 0)
		{
			soundData = (struct _AnimSoundData_Type*)messageDataB;

			if (sectionID != 0)
			{
				vol = soundData->volume;

				if (vol >= 1000)
				{
					vol %= 1000;

					if (vol / 1000 != HUMAN_TypeOfHuman(instance))
					{
						return 0;
					}
				}
			
				SOUND_Play3dSound(&instance->position, soundData->sfxToneID, soundData->pitch, vol, soundData->minVolDistance);

				return messageDataA;
			}
		}
		else if (messageDataA == 1)
		{
			FX_StartInstanceEffect(instance, (struct ObjectEffect*)messageDataB, 0);
		}
		else
		{
			return messageDataA;
		}
	}

	return messageDataA;

#elif defined(PC_VERSION)
	int v7; // esi
	int v8; // edi

	if (message == G2ANIM_MSG_PLAYEFFECT)
	{
		if (messageDataA)
		{
			if (messageDataA == 1)
			{
				FX_StartInstanceEffect(instance, (unsigned __int8*)messageDataB, 0);
				return 1;
			}
		}
		else if (messageDataB)
		{
			v7 = *(__int16*)(messageDataB + 2);
			if (v7 > 999)
			{
				v8 = v7 / 1000;
				v7 += 200 * (4 * (v7 / -1000) - v7 / 1000);
				if (v8 != HUMAN_TypeOfHuman(instance))
					return 0;
			}
			SOUND_Play3dSound(
				&instance->position,
				*(__int16*)messageDataB,
				*(__int16*)(messageDataB + 4),
				v7,
				*(__int16*)(messageDataB + 6));
		}
	}
	return messageDataA;
#else
UNIMPLEMENTED();
	return 0;
#endif
}




