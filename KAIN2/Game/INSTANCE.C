#include "CORE.H"
#include "STREAM.H"
#include "OBTABLE.H"
#include "GAMELOOP.H"
#include "SAVEINFO.H"
#include "LIGHT3D.H"
#include "SCRIPT.H"
#include "OBTABLE.H"
#include "SPLINE.H"
#include "EVENT.H"
#include "STATE.H"
#include "LIST.H"
#include "G2/ANIMG2.H"
#include "G2/INSTNCG2.H"
#include "G2/ANMG2ILF.H"
#include "MEMPACK.H"
#include "FX.H"
#include "SOUND.H"
#include "FONT.H"
#include "CAMERA.H"
#include "MATH3D.H"

void INSTANCE_Deactivate(struct _Instance* instance)  // Matching - 100%
{
	struct Object* object;

	object = instance->object;
	if (!(gameTrackerX.streamFlags & 0x2000000))
	{
		instance->flags2 |= 1;
		if ((instance->flags2 & 0x20000000))
		{
			instance->flags |= 0x40000;
		}
		else
		{
			instance->flags &= 0xFFFBFFFF;
			instance->flags2 |= 0x20000000;
		}
		if ((object->animList != NULL) && !(object->oflags2 & 0x40000000))
		{
			G2Anim_Free(&instance->anim);
		}
		instance->waterFace = NULL;
		instance->waterFaceTerrain = NULL;
	}
}

void INSTANCE_Reactivate(struct _Instance* instance)  // Matching - 100%
{
	struct Object* object;

	object = instance->object;

	instance->flags2 &= 0xFFFFFFFE;

	if ((instance->flags & 0x40000))
	{
		instance->flags &= 0xFFFBFFFF;
		instance->flags2 |= 0x20000000;
	}
	else
	{
		instance->flags2 &= 0xDFFFFFFF;
	}

	if (object->animList != NULL)
	{
		if (!(object->oflags2 & 0x40000000))
		{
			G2Anim_Restore(&instance->anim);
		}
	}
}

void INSTANCE_ForceActive(struct _Instance* instance)  // Matching - 100%
{
	if ((instance->flags2 & 0x1))
	{
		INSTANCE_Reactivate(instance);
	}
}

void INSTANCE_DeactivatedProcess(struct _Instance* instance, struct GameTracker* gameTracker)
{
}


void INSTANCE_DeactivateFarInstances(struct GameTracker* gameTracker)  // Matching - 99.62%
{
	struct _InstanceList* instanceList;
	struct _Instance* instance;
	SVECTOR* line;
	long distSq;
	int numInstances;
	int numToProcess;
	int cntInst;
	static int lastInst;

	line = (SVECTOR*)getScratchAddr(0);

	instanceList = gameTracker->instanceList;
	numInstances = instanceList->numInstances;
	instance = instanceList->first;
	numToProcess = (numInstances >> 3) + 1;

	if (numInstances <= lastInst)
	{
		lastInst = 0;
	}

	cntInst = lastInst;
	lastInst = lastInst + numToProcess;

	if (numInstances <= lastInst)
	{
		lastInst = 0;
	}

	while (cntInst != 0)
	{
		instance = instance->next;
		cntInst--;
	}

	for (; instance != NULL; instance = instance->next, numToProcess--)
	{
		if (numToProcess == 0)
		{
			return;
		}

		if (!(((((instance->flags2 & 0x80U) == 0) && ((instance->object->oflags & 0x10000U) == 0)) &&
			!INSTANCE_Query(instance, 0x23)) &&
			(((!INSTANCE_Query(instance, 0x2f) && (instance->LinkParent == NULL))
				&& (instance->matrix != NULL)))))
		{
			if ((instance->flags2 & 1) != 0)
			{
				INSTANCE_Reactivate(instance);
			}
		}
		else
		{
			line->vx = instance->position.x - theCamera.core.position.x;
			line->vy = instance->position.y - theCamera.core.position.y;
			line->vz = instance->position.z - theCamera.core.position.z;
			distSq = line->vx * line->vx;
			distSq += line->vy * line->vy;
			distSq += line->vz * line->vz;

			if ((instance->flags & 0x200U) != 0)
			{
				cntInst = instance->object->vvRemoveDist * instance->object->vvRemoveDist;
				if (distSq > cntInst)
				{
					if ((instance->flags2 & 1) == 0)
					{
						INSTANCE_Deactivate(instance);
					}
				}
				else if ((instance->flags2 & 1) != 0)
				{
					INSTANCE_Reactivate(instance);
				}
			}
			else if ((instance->flags2 & 0x80000U) == 0)
			{
				cntInst = instance->object->removeDist * instance->object->removeDist;
				if (distSq > cntInst)
				{
					if ((instance->flags2 & 1) == 0)
					{
						INSTANCE_Deactivate(instance);
					}
				}
				else if ((instance->flags2 & 1) != 0)
				{
					INSTANCE_Reactivate(instance);
				}
			}
			else
			{
				cntInst = gameTracker->defRemoveDist * gameTracker->defRemoveDist;
				if (distSq > cntInst)
				{
					if ((instance->flags2 & 1) == 0)
					{
						INSTANCE_Deactivate(instance);
					}
				}
				else if ((instance->flags2 & 1) != 0)
				{
					INSTANCE_Reactivate(instance);
				}
			}
		}
	}
}

void INSTANCE_InitInstanceList(struct _InstanceList* list, struct _InstancePool* pool)  // Matching - 100%
{
	long i;

	pool->numFreeInstances = 60;
	
	for (i = 1; i < 59; i++)
	{
		pool->instance[i].next = &pool->instance[i + 1];
		pool->instance[i].prev = &pool->instance[i - 1];
	}

	pool->instance[0].next = &pool->instance[1];
	pool->instance[0].prev = NULL;

	pool->instance[59].prev = &pool->instance[58];
	pool->instance[59].next = NULL;
	
	pool->first_free = &pool->instance[0];

	list->pool = pool;
	list->numInstances = 0;
	list->first = NULL;

	for (i = 0; i < 32; i++)
	{
		list->group[i].next = NULL;
		list->group[i].prev = NULL;
	}

	pool->nextInstanceID = 1;
}

struct _Instance* INSTANCE_NewInstance(struct _InstanceList* list)  // Matching - 100%
{
	struct _Instance* temp;
	struct _Instance* instance;

	if (list->pool->numFreeInstances != 0)
	{
		list->pool->numFreeInstances--;
		instance = list->pool->first_free;
		list->pool->first_free = instance->next;

		temp = list->first;
		list->first = instance;
		instance->next = temp;

		if (instance->next != NULL)
		{
			temp->prev = instance;
		}
	
		instance->prev = NULL;
		instance->instanceID = list->pool->nextInstanceID++;

		list->numInstances++;

		return instance;
	}
	
	return NULL;
}

long INSTANCE_InstanceGroupNumber(struct _Instance* instance)  // Matching - 100%
{
	long result;

	result = 0;

	if ((instance->object->oflags & 0x80) && !(instance->flags & 0x8000))
	{
		result = 0x1;
	}

	if ((instance->object->oflags & 0x20) && !(instance->flags & 0x2000))
	{
		result |= 0x2;
	}

	if ((instance->object->oflags & 0x40) && !(instance->flags & 0x4000))
	{
		result |= 0x4;
	}

	if ((instance->object->oflags & 0x10) && !(instance->flags & 0x1000))
	{
		result |= 0x10;
	}

	if ((instance->object->oflags & 0x1))
	{
		result |= 0x8;
	}
	else
	{
		if (strcmp(instance->object->name, "raziel__"))
		{
			result &= 0xFFFFFFFD;
			result &= 0xFFFFFFFE;
		}
	}

	return result;
}

void INSTANCE_InsertInstanceGroup(struct _InstanceList* list, struct _Instance* instance)  // Matching - 100%
{
	LIST_InsertFunc(&list->group[INSTANCE_InstanceGroupNumber(instance)], &instance->node);
}


void INSTANCE_ReallyRemoveInstance(struct _InstanceList* list, struct _Instance* instance, long reset)  // Matching - 100%
{
	struct _Instance* temp;
	int i;

	EVENT_RemoveInstanceFromInstanceList(instance);
	if (instance->flags & 0x800000)
	{
		SAVE_DoInstanceDeadDead(instance);
	}
	if (!(instance->flags & 2) && instance->intro != NULL)
	{
		instance->intro->flags &= ~reset;
		instance->intro->instance = NULL;
	}
	if (instance->prev != NULL)
	{
		instance->prev->next = instance->next;
	}
	else
	{
		list->first = instance->next;
	}
	if (instance->next != NULL)
	{
		instance->next->prev = instance->prev;
	}
	instance->instanceID = 0;
	list->numInstances--;
	list->pool->numFreeInstances++;
	temp = list->pool->first_free;
	list->pool->first_free = instance;
	instance->prev = NULL;
	instance->next = temp;
	if (temp != NULL)
	{
		temp->prev = instance;
	}
	LIST_DeleteFunc((struct NodeType*)instance);
	FX_EndInstanceEffects(instance);
	if (instance->flags & 0x10000)
	{
		instance->flags |= 0x20000;
		OBTABLE_InstanceInit(instance);
	}
	if (instance->object->animList != NULL && !(instance->object->oflags2 & 0x40000000))
	{
		G2Anim_Free(&instance->anim);
	}
	if (instance->shadow0 != NULL)
	{
		((struct LightInstance*)(instance->shadow0))->radius = 0;
	}
	if (instance->shadow1 != NULL)
	{
		((struct LightInstance*)(instance->shadow1))->radius = 0;
	}
	if (instance->object->oflags2 & 4)
	{
		SOUND_EndInstanceSounds(instance->object->soundData, instance->soundInstanceTbl);
	}
	if (instance->LinkParent != NULL)
	{
		INSTANCE_UnlinkFromParent(instance);
	}
	if (instance->LinkChild != NULL)
	{
		INSTANCE_UnlinkChildren(instance);
	}
	if (instance->hModelList != NULL)
	{
		MEMPACK_Free((char*)instance->hModelList);
	}
	if (instance->perVertexColor != NULL)
	{
		MEMPACK_Free((char*)instance->perVertexColor);
		instance->perVertexColor = NULL;
	}
	for (i = 0; i < 1; i++)
	{
		if (gameTrackerX.gameData.asmData.lightInstances[i].lightInstance == instance)
		{
			gameTrackerX.gameData.asmData.lightInstances[i].lightInstance = NULL;
			return;
		}
	}
}

void INSTANCE_CleanUpInstanceList(struct _InstanceList* list, long reset)  // Matching - 100%
{
	struct _Instance* instance;
	struct _Instance* next;

	instance = list->first;

	while (instance != NULL)
	{
		next = instance->next;
		if (!(instance->flags & 0x400))
		{
			if ((instance->flags & 0x20))
			{
				instance->flags |= 0x20;
			}
		}
		else if (instance->flags & 0x20)
		{
			instance->flags &= ~0x20;
		}
		instance = next;
	}
	instance = list->first;

	while (instance != NULL)
	{
		next = instance->next;

		if ((instance->flags & 0x20))
		{
			INSTANCE_ReallyRemoveInstance(list, instance, reset);
		}

		instance = next;
	}
}

long INSTANCE_Introduced(struct Intro* intro, short streamUnitID)  // Matching - 100%
{
	struct _Instance* instance;
	struct _Instance* next;
	long ret;

	instance = gameTrackerX.instanceList->first;

	ret = 0;

	while (instance != NULL)
	{
		next = instance->next;

		if (intro->UniqueID == instance->introUniqueID)
		{
			ret = 1;

			intro->flags |= 0x8;

			break;
		}

		instance = next;
	}

	if (ret == 0)
	{
		if (SAVE_HasSavedIntro(intro, streamUnitID) != 0)
		{
			intro->flags |= 0x8;
			ret = 1;
		}
		else if (SAVE_IsIntroDeadDead(intro) != 0)
		{
			intro->flags |= 0x8;
			ret = 1;
		}
	}

	return ret;
}

struct INICommand* INSTANCE_GetIntroCommand(struct INICommand* command, int cmd)
{
	if (command != NULL)
	{
		while (command->command != 0)
		{
			if (command->command != cmd)
			{
				command += command->numParameters + 1;
			}
			else
			{
				return command;
			}
		}
	}

	return 0;
}

struct INICommand* INSTANCE_FindIntroCommand(struct _Instance* instance, int cmd)//Matching - 99.44%
{
	return INSTANCE_GetIntroCommand((struct INICommand*)instance->introData, cmd);
}

void INSTANCE_ProcessIntro(struct _Instance* instance)//Matching - 100%
{
	struct INICommand* command;

	return;//inf loop
	UNIMPLEMENTED();

	if (instance->introData != NULL)
	{
		command = (struct INICommand*)instance->introData;

		if ((instance->flags & 2) == 0)
		{
			while (command->command)
			{
				if (command->command == 18)
				{
					instance->currentModel = command[1].command;
				}

				command += command->numParameters + 1;
			}
		}
	}
}

void INSTANCE_InitEffects(struct _Instance* instance, struct Object* object)
{
	int i;
	
	if (!(object->oflags2 & 0x100))
	{
		if (object->numberOfEffects != 0 && object->numberOfEffects > 0)
		{
			for (i = 0; i < object->numberOfEffects; i++)
			{
				FX_StartInstanceEffect(instance, &object->effectList[i], 1);
			}
		}
	}
}

struct _Instance* INSTANCE_IntroduceInstance(struct Intro* intro, short streamUnitID)
{
	struct Object* object;
	struct _Instance* instance;
	struct _Instance* attachInst;
	struct _ObjectTracker* objectTracker;
	struct INICommand* index;
	long attachedUniqueID;
	struct SavedIntroSpline* savedIntroSpline;
	struct MultiSpline* spline;
	struct SavedIntroSmall* savedIntroSmall;
	
	attachInst = NULL;
	index = NULL;

	if (!(INSTANCE_Introduced(intro, streamUnitID)))
	{
		attachedUniqueID = 0;
		index = INSTANCE_GetIntroCommand(index, 26);

		if (index != NULL)
		{
			attachedUniqueID = index->parameter[0];
		}

		objectTracker = STREAM_GetObjectTracker(intro->name);

		if (objectTracker != NULL)
		{
			object = objectTracker->object;

			if (objectTracker->objectStatus == 2)
			{
				savedIntroSmall = NULL;

				if (attachedUniqueID != 0)
				{
					attachInst = INSTANCE_Find(attachedUniqueID);
					if (attachInst == NULL)
					{
						return 0;
					}
				}


				if ((object->oflags2 & 0x10000000))
				{
					OBTABLE_InitAnimPointers(objectTracker);

					if ((object->oflags2 & 0x10000000))
					{
						return 0;
					}
				}

				instance = INSTANCE_NewInstance(gameTrackerX.instanceList);

				if (instance != NULL)
				{
					intro->flags |= 0x8;

					objectTracker->numInUse++;

					INSTANCE_DefaultInit(instance, object, 0);

					strcpy(instance->introName, intro->name);

					instance->introUniqueID = intro->UniqueID;
					instance->introNum = intro->intronum;
					instance->birthStreamUnitID = streamUnitID;
					instance->currentStreamUnitID = streamUnitID;

					intro->instance = instance;

					instance->intro = intro;
					instance->introData = intro->multiSpline;
					instance->position = intro->position;

					if (gameTrackerX.gameData.asmData.MorphType == 1)
					{
						if (intro->spectralPosition.x != 0 && intro->spectralPosition.y != 0 && intro->spectralPosition.z != 0)
						{
							instance->position.x = intro->position.x + intro->spectralPosition.x;
							instance->position.y = intro->position.y + intro->spectralPosition.y;
							instance->position.z = intro->position.z + intro->spectralPosition.z;
						}
					}

					instance->initialPos = instance->position;
					instance->oldPos = intro->position;

					LIGHT_GetAmbient((struct _ColorType*)&instance->light_color, instance);

					instance->rotation = intro->rotation;
					if ((instance->object->oflags & 0x100))
					{
						INSTANCE_BuildStaticShadow(instance);
					}

					instance->scale.x = 4096;
					instance->scale.y = 4096;
					instance->scale.z = 4096;

					if ((intro->flags & 0x2000))
					{
						instance->flags |= 0x400;
					}

					if ((intro->flags & 0x10000))
					{
						instance->flags2 |= 0x20000;
					}

					if (attachInst != NULL)
					{
						INSTANCE_ForceActive(attachInst);
						attachInst->flags2 |= 0x80;
					}

					if ((object->oflags2 & 0x80))
					{
						instance->flags |= 0x800;
					}

					if ((intro->flags & 0x800) && object->id == -1)
					{
						SCRIPTCountFramesInSpline(instance);
						SCRIPT_InstanceSplineSet(instance, -1, NULL, NULL, NULL);
						instance->flags = (instance->flags ^ 0x1000000) | 0x100000;
					}

					instance->lightGroup = (unsigned char)intro->rotation.pad;
					instance->spectralLightGroup = (unsigned char)intro->specturalLightGroup;

					INSTANCE_InsertInstanceGroup(gameTrackerX.instanceList, instance);
					OBTABLE_GetInstanceCollideFunc(instance);
					OBTABLE_GetInstanceProcessFunc(instance);
					OBTABLE_GetInstanceQueryFunc(instance);
					OBTABLE_GetInstanceMessageFunc(instance);
					OBTABLE_GetInstanceAdditionalCollideFunc(instance);

					if (!(intro->flags & 0x10))
					{
						OBTABLE_InstanceInit(instance);
					}

					MORPH_SetupInstanceFlags(instance);

					if ((intro->flags & 0x80))
					{
						instance->flags |= 0x800;
						instance->flags2 |= 0x20000000;

						if ((object->oflags2 & 0x80000))
						{
							instance->flags2 |= 0x10000000;
						}
					}

					if (SCRIPT_GetMultiSpline(instance, NULL, NULL) == NULL)
					{
						instance->flags = (instance->flags & 0xFDFFFFFF) | 0x100000;
					}
					else
					{
						spline = SCRIPT_GetMultiSpline(instance, NULL, NULL);
						savedIntroSpline = SAVE_GetIntroSpline(instance);

						if (savedIntroSpline != NULL)
						{
							SCRIPT_InstanceSplineSet(instance, savedIntroSpline->splineKeyFrame, NULL, NULL, NULL);

							instance->oldPos = instance->position;
							instance->splineFlags = savedIntroSpline->splineFlags;
							instance->clipBeg = savedIntroSpline->splineClipBeg;
							instance->clipEnd = savedIntroSpline->splineClipEnd;

							if ((instance->splineFlags & 0x80))
							{
								instance->flags |= 0x1000000;
							}

							if ((instance->splineFlags & 0x100))
							{
								instance->flags |= 0x2000000;
							}

							if ((savedIntroSpline->splineFlags & 0x10))
							{
								if (spline->positional != NULL)
								{
									spline->positional->flags |= 0x1;
								}

								if (spline->rotational != NULL)
								{
									spline->rotational->flags |= 0x1;
								}

								if (spline->scaling != NULL)
								{
									spline->scaling->flags |= 0x1;
								}

								if (spline->color != NULL)
								{
									spline->color->flags |= 0x1;
								}
							}
							else if ((instance->splineFlags & 0x20))
							{
								if (spline->positional != NULL)
								{
									spline->positional->flags |= 0x2;
								}

								if (spline->rotational != NULL)
								{
									spline->rotational->flags |= 0x2;
								}

								if (spline->scaling != NULL)
								{
									spline->scaling->flags |= 0x2;
								}

								if (spline->color != NULL)
								{
									spline->color->flags |= 0x2;
								}
							}
							else if ((instance->splineFlags & 0x40))
							{
								if (spline->positional != NULL)
								{
									spline->positional->flags |= 0x4;
								}

								if (spline->rotational != NULL)
								{
									spline->rotational->flags |= 0x4;
								}

								if (spline->scaling != NULL)
								{
									spline->scaling->flags |= 0x4;
								}

								if (spline->color != NULL)
								{
									spline->color->flags |= 0x4;
								}
							}
						}
					}

					EVENT_AddInstanceToInstanceList(instance);

					INSTANCE_ProcessIntro(instance);
					INSTANCE_InitEffects(instance, object);

					savedIntroSmall = SAVE_GetSavedSmallIntro(instance);

					if (savedIntroSmall != NULL)
					{
						INSTANCE_Post(instance, 0x100007, SetControlSaveDataData((savedIntroSmall->shiftedSaveSize << 2) - 4, savedIntroSmall + 1));
					}

					return instance;
				}
			}
		}
	}
	return NULL;
}

void INSTANCE_AdditionalCollideFunctions(struct _InstanceList* instanceList)//Matching - 97.97%
{
	struct _Instance* instance;

	instance = instanceList->first;

	while (instance != NULL)
	{
		if (gameTrackerX.gameMode != 6 || (instance->object->oflags & 0x20000))
		{
			if (!(gameTrackerX.streamFlags & 0x100000) || (instance->object->oflags & 0x40000))
			{
				if (instance->additionalCollideFunc != NULL)
				{
					if (!(instance->flags2 & 0x24000000))
					{
						if (instance->object != NULL)
						{
							if ((instance->object->oflags2 & 0x2000000))
							{
								if ((instance->flags2 & 0x8000000))
								{
									gameTrackerX.timeMult = gameTrackerX.spectralTimeMult;
								}
								else
								{
									gameTrackerX.timeMult = gameTrackerX.materialTimeMult;
								}
							}
							else
							{
								gameTrackerX.timeMult = gameTrackerX.globalTimeMult;
							}
						}
						else
						{
							gameTrackerX.timeMult = gameTrackerX.globalTimeMult;
						}

						instance->additionalCollideFunc(instance, &gameTrackerX);
					}
				}
			}
		}

		instance = instance->next;
	}
	gameTrackerX.timeMult = gameTrackerX.globalTimeMult;
}

long INSTANCE_GetSplineFrameNumber(struct _Instance* instance, struct MultiSpline* spline)
{
	return SCRIPT_GetSplineFrameNumber(instance, SCRIPT_GetPosSplineDef(instance, spline, 0, 0));
}

void INSTANCE_ProcessFunctions(struct _InstanceList* instanceList)
{
	struct _Instance* instance;
	int hidden;
	int burning;
	long prevFrame;
	struct MultiSpline* multi;
	long endOfSpline;
	short direction;
	long frame;
	long maxFrames;
	int killTest;

	if (!(gameTrackerX.debugFlags & 0x8000010))
	{
		if (gameTrackerX.gameMode != 6 && !(gameTrackerX.streamFlags & 0x100000))
		{
			gameTrackerX.streamFlags &= 0xFFFFFFFB;
		}

		instance = instanceList->first;

		while (instance != NULL)
		{
			if (instance->object != NULL && (instance->object->oflags2 & 0x2000000))
			{
				if ((instance->flags2 & 0x8000000))
				{
					gameTrackerX.timeMult = gameTrackerX.spectralTimeMult;
				}
				else
				{
					gameTrackerX.timeMult = gameTrackerX.materialTimeMult;
				}
			}
			else
			{
				gameTrackerX.timeMult = gameTrackerX.globalTimeMult;
			}

			burning = 0;

			if ((instance->object->oflags2 & 0x4))
			{
				hidden = instance->flags & 0x800;

				if ((INSTANCE_Query(instance, 0x2) & 0x80))
				{
					burning = burning < (int)(INSTANCE_Query(instance, 0x3) & 0x10000);
				}
				else
				{
					if ((instance->object->oflags2 & 0x80000) && ((unsigned int*)instance->extraData)[0] & 0x400000)
					{
						burning = 1;
					}
				}

				SOUND_ProcessInstanceSounds(instance->object->soundData, &instance->soundInstanceTbl[0], &instance->position, instance->object->oflags2 & 0x2000000, instance->flags2 & 0x8000000, hidden, burning, &instance->flags2);
			}

			if (instance->intro == NULL || (instance->intro->flags & 0x100))
			{
				if(gameTrackerX.gameMode != 6 || (instance->object->oflags & 0x20000))
				{
					if (!(gameTrackerX.streamFlags & 0x100000) || (instance->object->oflags & 0x40000))
					{
						if (!(instance->flags2 & 0x10000000))
						{
							instance->oldPos.x = instance->position.x;
							instance->oldPos.y = instance->position.y;
							instance->oldPos.z = instance->position.z;

							instance->oldRotation.x = instance->rotation.x;
							instance->oldRotation.y = instance->rotation.y;
							instance->oldRotation.z = instance->rotation.z;

							if (!(instance->flags & 0x10000000))
							{
								multi = SCRIPT_GetMultiSpline(instance, NULL, NULL);

								if (multi != NULL && (instance->flags & 0x2000000))
								{
									if ((instance->flags & 0x1000000))
									{
										direction = -1;
									}
									else
									{
										direction = 1;
									}

									if ((instance->object->oflags & 0x10000000))
									{
										instance->flags |= 0x400;
										
										if (SplineMultiIsWhere(multi) != 0)
										{
											if (direction > 0)
											{
												instance->intro->flags |= 0x800;
											}
											else
											{
												instance->intro->flags &= 0xFFFFF7FF;
											}
										}
									}

									prevFrame = INSTANCE_GetSplineFrameNumber(instance, multi);

									endOfSpline = SCRIPT_InstanceSplineProcess(instance, &multi->curPositional, &multi->curRotational, &multi->curScaling, direction);
								
									if (instance->splineFlags != 0)
									{
										frame = INSTANCE_GetSplineFrameNumber(instance, multi);

										maxFrames = SCRIPTCountFramesInSpline(instance);
									
										if ((instance->splineFlags & 0x1))
										{
											if ((gameTrackerX.debugFlags2 & 0x400000))
											{
												printf("Spline %s%ld playto %d preveFram=%ld frame=%ld endOfSpline=%ld, maxFrames=%ld\n", instance->introName, instance->introNum, instance->targetFrame, prevFrame, frame, endOfSpline, maxFrames);
											}

											if (direction > 0)
											{
												if (maxFrames < prevFrame)
												{
													prevFrame = maxFrames;
												}

												if (frame >= instance->targetFrame && instance->targetFrame < prevFrame)
												{
													if (frame >= prevFrame)
													{
														instance->flags &= 0xFDFFFFFF;
														SCRIPT_InstanceSplineSet(instance, instance->targetFrame, NULL, NULL, NULL);
													}
												}
												else
												{
													if (frame < prevFrame && frame >= instance->targetFrame)
													{
														if (instance->targetFrame + maxFrames >= prevFrame)
														{
															instance->flags &= 0xFDFFFFFF;
															SCRIPT_InstanceSplineSet(instance, instance->targetFrame, NULL, NULL, NULL);
														}
													}
												}
											}
											else
											{
												if (instance->targetFrame >= frame && prevFrame < instance->targetFrame)
												{
													instance->flags &= 0xFDFFFFFF;
													SCRIPT_InstanceSplineSet(instance, instance->targetFrame, NULL, NULL, NULL);
												}
												else
												{
													if (prevFrame < frame)
													{
														if (prevFrame + maxFrames >= instance->targetFrame)
														{
															instance->flags &= 0xFDFFFFFF;
															SCRIPT_InstanceSplineSet(instance, instance->targetFrame, NULL, NULL, NULL);
														}
													}
												}
											}
										}

										if ((instance->splineFlags & 0x2))
										{
											if ((gameTrackerX.debugFlags2 & 0x400000))
											{
												FONT_Print("Spline %s%d : clip(%d,%d) prevFrame=%d, frame=%d\n", instance->introName, instance->introNum, instance->clipBeg, instance->clipEnd, frame, prevFrame);
											}

											if (direction == 1)
											{
												if (instance->clipEnd < prevFrame || frame < instance->clipEnd && frame < instance->clipBeg)
												{
													if (*(unsigned int*)&multi->positional->numkeys & 0x6000000)
													{
														SCRIPT_InstanceSplineSet(instance, instance->clipBeg, NULL, NULL, NULL);
													}
													else
													{
														killTest = 1;

														SCRIPT_InstanceSplineSet(instance, instance->clipEnd, NULL, NULL, NULL);
													}
												}
											}
											else
											{
												if (prevFrame < instance->clipBeg || instance->clipBeg >= frame && instance->clipEnd < frame)
												{
													if (*(unsigned int*)&multi->positional->numkeys & 0x6000000)
													{
														SCRIPT_InstanceSplineSet(instance, instance->clipBeg, NULL, NULL, NULL);
													}
													else
													{
														killTest = 1;

														SCRIPT_InstanceSplineSet(instance, instance->clipEnd, NULL, NULL, NULL);
													}
												}
											}
										}
									}
									else
									{
										if ((gameTrackerX.debugFlags2 & 0x400000))
										{
											FONT_Print("Spline %s%d prevFrame=%d, frame=%d\n", instance->introName, instance->introNum, prevFrame, INSTANCE_GetSplineFrameNumber(instance, multi));
										}
									}
									
									if (endOfSpline > 0)
									{
										if ((instance->object->oflags & 0x10000000))
										{
											instance->flags &= 0xFFFFFBFF;
											instance->flags &= 0xFDFFFFFF;
											instance->flags |= 0x100000;
										}

										if ((instance->object->oflags & 0x20000000))
										{
											instance->flags |= 0x100000;

											INSTANCE_KillInstance(instance);
										}
										else
										{
											if ((instance->object->oflags & 0x1000))
											{
												instance->flags &= 0xFDFFFFFF;

												if ((instance->object->oflags & 0x800000))
												{
													SCRIPT_InstanceSplineInit(instance);
												}
											}
											else if ((instance->object->oflags & 0x1000000))
											{
												instance->flags &= 0xFDFFFFFF;
											}

											if (multi->positional != NULL)
											{
												if (!(multi->positional->flags & 0x4))
												{
													if (!(instance->object->oflags & 0x800000))
													{
														instance->flags ^= 0x1000000;
													}
												}
											}
											else if (multi->rotational != NULL)
											{
												if (!(multi->rotational->flags & 0x4))
												{
													if (!(instance->object->oflags & 0x800000))
													{
														instance->flags ^= 0x1000000;
													}
												}
											}

											if ((instance->object->oflags & 0x200000) && instance->introData != NULL && ((unsigned int*)instance->introData)[0] != NULL)
											{
												SIGNAL_HandleSignal(instance, (struct Signal*)(((unsigned int*)instance->introData)[0] + 8), 0);
											}
											else
											{
												if (instance->processFunc != NULL)
												{
													if ((instance->flags2 & 0x1))
													{
														INSTANCE_DeactivatedProcess(instance, &gameTrackerX);
													}
													else
													{
														instance->processFunc(instance, &gameTrackerX);
													}
												}

												if (32768 < instance->position.z - instance->oldPos.z)
												{
													INSTANCE_PlainDeath(instance);
												}

												if (instance->position.z - instance->oldPos.z < -32768)
												{
													INSTANCE_PlainDeath(instance);
												}

												if (INSTANCE_Query(instance, 0x2F) != 0)
												{
													gameTrackerX.streamFlags |= 0x4;
												}
											}
										}
									}
									else
									{
										if (instance->processFunc != NULL)
										{
											if ((instance->flags2 & 0x1))
											{
												INSTANCE_DeactivatedProcess(instance, &gameTrackerX);
											}
											else
											{
												instance->processFunc(instance, &gameTrackerX);
											}
										}

										if (32768 < instance->position.z - instance->oldPos.z)
										{
											INSTANCE_PlainDeath(instance);
										}

										if (instance->position.z - instance->oldPos.z < -32768)
										{
											INSTANCE_PlainDeath(instance);
										}

										if (INSTANCE_Query(instance, 0x2F) != 0)
										{
											gameTrackerX.streamFlags |= 0x4;
										}
									}
								}
								else
								{
									if (instance->processFunc != NULL)
									{
										if ((instance->flags2 & 0x1))
										{
											INSTANCE_DeactivatedProcess(instance, &gameTrackerX);
										}
										else
										{
											instance->processFunc(instance, &gameTrackerX);
										}
									}

									if (32768 < instance->position.z - instance->oldPos.z)
									{
										INSTANCE_PlainDeath(instance);
									}

									if (instance->position.z - instance->oldPos.z < -32768)
									{
										INSTANCE_PlainDeath(instance);
									}

									if (INSTANCE_Query(instance, 0x2F) != 0)
									{
										gameTrackerX.streamFlags |= 0x4;
									}
								}
							}
							else
							{
								if (instance->processFunc != NULL)
								{
									if ((instance->flags2 & 0x1))
									{
										INSTANCE_DeactivatedProcess(instance, &gameTrackerX);
									}
									else
									{
										instance->processFunc(instance, &gameTrackerX);
									}
								}

								if (32768 < instance->position.z - instance->oldPos.z)
								{
									INSTANCE_PlainDeath(instance);
								}

								if (instance->position.z - instance->oldPos.z < -32768)
								{
									INSTANCE_PlainDeath(instance);
								}

								if (INSTANCE_Query(instance, 0x2F) != 0)
								{
									gameTrackerX.streamFlags |= 0x4;
								}
							}
						}
					}
				}
			}

			instance = instance->next;
		}
	}
}

struct _Instance* INSTANCE_BirthObject(struct _Instance* parent, struct Object* object, int modelNum)
{
	struct _Instance* instance;
	int i;

	if (object != NULL)
	{
		instance = INSTANCE_NewInstance(gameTrackerX.instanceList);

		if (instance != NULL)
		{
			INSTANCE_DefaultInit(instance, object, modelNum);
			
			instance->position.x = parent->position.x;
			instance->position.y = parent->position.y;
			instance->position.z = parent->position.z;
			
			instance->initialPos.x = instance->position.x;
			instance->initialPos.y = instance->position.y;
			instance->initialPos.z = instance->position.z;
			
			instance->oldPos.x = parent->position.x;
			instance->oldPos.y = parent->position.y;
			instance->oldPos.z = parent->position.z;
			
			instance->rotation.x = parent->rotation.x;
			instance->rotation.y = parent->rotation.y;
			instance->rotation.z = parent->rotation.z;
			
			instance->scale.x = parent->scale.x;
			instance->scale.y = parent->scale.y;
			instance->scale.z = parent->scale.z;
			instance->scale.pad = parent->scale.pad;
			
			instance->lightGroup = parent->lightGroup;
			instance->spectralLightGroup = parent->spectralLightGroup;
			
			instance->currentStreamUnitID = parent->currentStreamUnitID;
			instance->birthStreamUnitID = parent->birthStreamUnitID;
			instance->introUniqueID = GlobalSave->CurrentBirthID;

			GlobalSave->CurrentBirthID++;
			
			strcpy(instance->introName, object->name);

			i = 0;

			do
			{
				if (i >= (int)strlen(instance->introName))
				{
					goto loc_80034008;//:(
				}

			} while (instance->introName[i++] != '\x5F');

			instance->introName[i] = 0;

loc_80034008://:(

			instance->parent = parent;
			instance->intro = parent->intro;
			instance->introData = parent->introData;

			LIGHT_GetAmbient((struct _ColorType*)&instance->light_color, instance);

			if ((instance->object->oflags & 0x100))
			{
				INSTANCE_BuildStaticShadow(instance);
			}

			if (SCRIPT_GetMultiSpline(instance, NULL, NULL) == NULL)
			{
				instance->flags |= 0x100000;
			}

			if ((parent->flags2 & 0x8000000))
			{
				instance->flags2 |= 0x8000000;
			}

			INSTANCE_InsertInstanceGroup(gameTrackerX.instanceList, instance);

			OBTABLE_GetInstanceCollideFunc(instance);
			OBTABLE_GetInstanceProcessFunc(instance);
			OBTABLE_GetInstanceQueryFunc(instance);
			OBTABLE_GetInstanceMessageFunc(instance);
			OBTABLE_GetInstanceAdditionalCollideFunc(instance);

			instance->flags |= 0x2;

			OBTABLE_InstanceInit(instance);

			EVENT_AddInstanceToInstanceList(instance);

			INSTANCE_InitEffects(instance, object);

			return instance;
		}
	}
	
	return NULL;
}

void INSTANCE_BuildStaticShadow(struct _Instance* instance)
{
}

void INSTANCE_DefaultInit(struct _Instance* instance, struct Object* object, int modelNum)//Matching - 97.34%
{
	int i;
	int j;
	int numHPrims;
	int numModels;
	struct _HPrim* hprim;
	struct _Model** pModel;
	struct _HModel* hmodel;
	struct _Model* model;
	struct _Segment* seg;
	struct _HInfo* hinfo;
	int k;
	struct _HFace* hface;
	struct _HSphere* hsphere;
	struct _HBox* hbox;

	memset(&instance->flags, 0, sizeof(struct _Instance) - 0x14);

	instance->object = object;
	instance->data = object->data;
	instance->currentModel = modelNum;
	instance->cachedTFace = -1;
	instance->cachedTFaceLevel = NULL;

	if (object->animList != NULL && !(object->oflags2 & 0x40000000))
	{
		G2Anim_Init(&instance->anim, object->modelList[modelNum]);
		G2Anim_SwitchToKeylist(&instance->anim, G2Instance_GetKeylist(instance, 0), 0);
		G2Anim_SetCallback(&instance->anim, INSTANCE_DefaultAnimCallback, instance);
	}

	if ((object->oflags & 0x4000000))
	{
		instance->flags2 |= 0x4;
	}

	if ((object->oflags & 0x200))
	{
		instance->flags2 |= 0x40;
	}

	if ((object->oflags & 0x8))
	{
		instance->flags2 |= 0x8000000;
	}

	if (!(object->oflags & 0x1000800))
	{
		instance->flags |= 0x2000000;
	}

	if ((object->oflags & 0x20000000))
	{
		instance->flags2 |= 0x20;
	}

	numModels = object->numModels;
	pModel = object->modelList;

	numHPrims = 0;

	for (i = numModels; i != 0; i--, pModel++)
	{
		for (j = pModel[0]->numSegments, seg = pModel[0]->segmentList; j != 0; seg++, j--)
		{
			hinfo = seg->hInfo;

			if (hinfo != NULL)
			{
				numHPrims += hinfo->numHFaces + hinfo->numHSpheres + hinfo->numHBoxes;
			}
		}
	}

	if (numHPrims != 0)
	{
		hmodel = (struct _HModel*)MEMPACK_Malloc((instance->object->numModels + numHPrims) * 8, 0xE);

		instance->hModelList = hmodel;
		pModel = object->modelList;
		hprim = (struct _HPrim*)hmodel + numModels;

		for (i = numModels; i != 0; i--, pModel++, hmodel++)
		{
			model = pModel[0];
			hmodel->numHPrims = 0;
			hmodel->hPrimList = hprim;
			seg = model->segmentList;

			for (j = 0; j < model->numSegments; j++, seg++)
			{
				hinfo = seg->hInfo;

				if (hinfo != NULL)
				{
					hface = hinfo->hfaceList;
					hsphere = hinfo->hsphereList;
					hbox = hinfo->hboxList;

					hmodel->numHPrims += hinfo->numHFaces + hinfo->numHSpheres + hinfo->numHBoxes;

					for (k = hinfo->numHFaces; k != 0; hprim++, hface++, k--)
					{
						hprim->hpFlags = 0x4D;
						hprim->withFlags = 0x24;
						hprim->type = 2;
						hprim->segment = j;
						hprim->data.hface = hface;
					}

					for (k = hinfo->numHSpheres; k != 0; hprim++, hsphere++, k--)
					{
						hprim->hpFlags = 0x2F;
						hprim->withFlags = 0x76;
						hprim->type = 1;
						hprim->segment = j;
						hprim->data.hsphere = hsphere;
					}

					for (k = hinfo->numHBoxes; k != 0; hprim++, hbox++, k--)
					{
						hprim->hpFlags = 0x1D;
						hprim->withFlags = 0x24;
						hprim->type = 5;
						hprim->segment = j;
						hprim->data.hbox = hbox;
					}
				}
			}
		}
	}
	else
	{
		instance->hModelList = NULL;
		instance->flags2 |= 0x40000;
	}

	if (instance->maxCheckDistance == 0)
	{
		instance->maxCheckDistance = 12000;
	}
}

void INSTANCE_PlainDeath(struct _Instance* instance) // Matching - 100%
{
	struct _Instance* oldOn;

	instance->flags &= 0xfffffbff;
	if (instance->object->oflags2 & 4)
	{
		instance->flags2 |= 0x1000;
		SOUND_ProcessInstanceSounds(instance->object->soundData, instance->soundInstanceTbl, &instance->position, instance->object->oflags2 & 0x2000000, instance->flags2 & 0x8000000, 0, 0, &instance->flags2);
		SOUND_ProcessInstanceSounds(instance->object->soundData, instance->soundInstanceTbl, &instance->position, instance->object->oflags2 & 0x2000000, instance->flags2 & 0x8000000, 0, 0, &instance->flags2);
	}
	oldOn = INSTANCE_Find(instance->attachedID);
	if (oldOn)
	{
		oldOn->flags2 &= 0xffffff7f;
	}
	SAVE_MarkDeadDead(instance);
	instance->flags |= 0x20;
}

void INSTANCE_KillInstance(struct _Instance* instance)
{
	if (!(instance->flags & 0x20))
	{
		INSTANCE_PlainDeath(instance);
	}
}

unsigned long INSTANCE_Query(struct _Instance* Inst, int Query)
{
	unsigned long (*Func)(struct _Instance*, unsigned long);

	Func = Inst->queryFunc;

	if (Func != NULL)
	{
		return Func(Inst, Query);
	}

	return 0;
}

void INSTANCE_Post(struct _Instance* Inst, int Message, int Data)
{
	void (*Func)(_Instance*, unsigned long, unsigned long);

	Func = Inst->messageFunc;

	if (Func != NULL)
	{
		INSTANCE_ForceActive(Inst);

		Func(Inst, Message, Data);
	}
}

void INSTANCE_Broadcast(struct _Instance* sender, long whatAmIMask, int Message, int Data)
{
	struct _Instance* instance;
	int plane;

	instance = gameTrackerX.instanceList->first;

	plane = gameTrackerX.gameData.asmData.MorphType;

	while (instance != NULL)
	{
		if (instance != sender)
		{
			if ((INSTANCE_Query(instance, 1) & whatAmIMask))
			{
				if (INSTANCE_InPlane(instance, plane))
				{
					INSTANCE_Post(instance, Message, Data);
				}
			}
		}

		instance = instance->next;
	}
}

int INSTANCE_InPlane(struct _Instance* instance, int plane)
{
	UNIMPLEMENTED();
	return 0;
}

long INSTANCE_FindWithID(long uniqueID)
{
	struct _Instance* instance;
	struct _Instance* next;
	long ret;

	instance = gameTrackerX.instanceList->first;
	ret = 0;

	while (instance != NULL)
	{
		next = instance->next;

		if (instance->introUniqueID == uniqueID)
		{
			ret = 1;
			break;
		}

		instance = next;
	}

	return ret;
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ INSTANCE_FindWithName(long areaID /*$s3*/, char *instanceName /*$s4*/, struct _Instance *startInstance /*$a2*/)
struct _Instance* INSTANCE_FindWithName(long areaID, char* instanceName, struct _Instance* startInstance)
{ // line 1995, offset 0x8003457c
	UNIMPLEMENTED();
	return NULL;
}

struct Intro* INSTANCE_FindIntro(long areaID, long introUniqueID) // Matching - 100%
{
	struct Intro* ret;
	long i;
	struct Level* level;

	ret = NULL;
	if (level = STREAM_GetLevelWithID(areaID))
	{
		i = 0;
		for (i = 0; i < level->numIntros; i++)
		{
			if (introUniqueID == level->introList[i].UniqueID)
			{
				ret = &level->introList[i];
				break;
			}
		}
	}
	return ret;
}

struct _Instance* INSTANCE_Find(long introUniqueID)
{
	struct _Instance* instance;

	instance = gameTrackerX.instanceList->first;

	while (instance != NULL)
	{
		if (instance->introUniqueID == introUniqueID)
		{
			break;
		}

		instance = instance->next;
	}

	return instance;
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ INSTANCE_IntroduceSavedInstance(struct _SavedIntro *savedIntro /*$s2*/, struct _StreamUnit *streamUnit /*$a1*/, int *deleted /*$fp*/)
struct _Instance* INSTANCE_IntroduceSavedInstance(struct _SavedIntro* savedIntro, struct _StreamUnit* streamUnit, int* deleted)
{ // line 2102, offset 0x80034714
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ INSTANCE_IntroduceSavedInstanceWithIntro(struct _SavedIntroWithIntro *savedIntro /*$s4*/, struct _StreamUnit *streamUnit /*$s6*/, int *deleted /*stack 8*/)
struct _Instance* INSTANCE_IntroduceSavedInstanceWithIntro(struct _SavedIntroWithIntro* savedIntro, struct _StreamUnit* streamUnit, int* deleted)
{ // line 2327, offset 0x80034b8c
	/* begin block 1 */
		// Start line: 2328
		// Start offset: 0x80034B8C
		// Variables:
	struct _ObjectTracker* objectTracker; // $s1
	struct Object* object; // $s7
	struct _Instance* instance; // $s0
	_Position* levelOffset; // $fp
	struct Level* level; // $v1
	struct Intro* intro; // $s2
	struct _Instance* attachedInst; // $s5

/* begin block 1.1 */
	// Start line: 2372
	// Start offset: 0x80034CC4
	// Variables:
	int remove; // $s1
	int nosave; // $s2

/* begin block 1.1.1 */
	// Start line: 2376
	// Start offset: 0x80034CC4
	// Variables:
	short _x0; // $v0
	short _y0; // $a0
	short _z0; // $v1
	short _x1; // $a1
	short _y1; // $a2
	short _z1; // $a3
	_Position* _v; // $v0
	_Position* _v0; // $v1
/* end block 1.1.1 */
// End offset: 0x80034CC4
// End Line: 2376

/* begin block 1.1.2 */
	// Start line: 2513
	// Start offset: 0x80034F4C
/* end block 1.1.2 */
// End offset: 0x80034F68
// End Line: 2524
/* end block 1.1 */
// End offset: 0x80034F9C
// End Line: 2533
/* end block 1 */
// End offset: 0x80034FCC
// End Line: 2549

/* begin block 2 */
	// Start line: 5380
/* end block 2 */
// End Line: 5381
	UNIMPLEMENTED();
	return null;
}

void INSTANCE_SpatialRelationships(struct _InstanceList* instanceList)//Matching - 98.56%
{
	struct _Instance* instance;
	int checkMask;
	MATRIX* lookMatrix;
	struct _Instance* checkee;
	MATRIX* mat;
	MATRIX invMatrix;
	struct evCollideInstanceStatsData data;

	for (instance = instanceList->first; instance; instance = instance->next)
	{
		if ((instance->flags2 & 0x10000401) == 1024)
		{
			checkMask = instance->checkMask;

			lookMatrix = (MATRIX*)INSTANCE_Query(instance, 13);

			INSTANCE_Post(instance, 0x200000, 0);

			if (lookMatrix)
			{
				TransposeMatrix(lookMatrix, &invMatrix);

				for (checkee = instanceList->first; checkee; checkee = checkee->next)
				{
					if (checkee != instance && !(checkee->flags2 & 0x10000000) && !(checkee->flags & 0x20) && (INSTANCE_Query(checkee, 1) & checkMask))
					{
						mat = (MATRIX*)INSTANCE_Query(checkee, 14);
						if (mat || (mat = checkee->matrix) != 0)
						{
							if (INSTANCE_SetStatsData(instance, checkee, (struct _Vector*)&mat->t[0], &data, &invMatrix))
								INSTANCE_Post(instance, 0x200001, (int)&data);
						}
					}
				}
			}
		}
	}
}

int INSTANCE_SetStatsData(struct _Instance* instance, struct _Instance* checkee, struct _Vector* checkPoint, struct evCollideInstanceStatsData* data, MATRIX* mat) {  // Matching - 100%
	long distance;
	SVECTOR* delta;
	distance = MATH3D_LengthXYZ(instance->position.x - checkPoint->x, instance->position.y - checkPoint->y, instance->position.z - checkPoint->z);
	if (((unsigned long)distance < instance->maxCheckDistance) != 0)
	{
		delta = (SVECTOR*)getScratchAddr(0);
		delta->vx = (short)checkPoint->x - instance->position.x;
		delta->vy = (short)checkPoint->y - instance->position.y;
		delta->vz = (short)checkPoint->z - instance->position.z;
		ApplyMatrixSV(mat, delta, (SVECTOR*)&data->relativePosition);
		data->instance = checkee;
		data->distance = distance;
		data->zDelta = delta->vz;
		data->xyDistance = MATH3D_LengthXY(delta->vx, delta->vy);
		return 1;
	}
	return 0;
}

void INSTANCE_LinkToParent(struct _Instance* instance, struct _Instance* parent, int node) // Matching - 42.55%
{
	instance->LinkSibling = parent->LinkChild;
	parent->LinkChild = instance;
	instance->LinkParent = parent;
	instance->ParentLinkNode = node;
	instance->scale.x = (instance->scale.x << 12) / parent->scale.x;
	instance->scale.y = (instance->scale.y << 12) / parent->scale.y;
	instance->scale.z = (instance->scale.z << 12) / parent->scale.z;
	INSTANCE_UpdateFamilyStreamUnitID(parent);
	INSTANCE_Post(parent, 0x100012, (int)instance);
	instance->flags2 |= 8;
}

void INSTANCE_UnlinkFromParent(struct _Instance* instance) // Matching - 100%
{
	struct _Instance* parent;
	struct _G2EulerAngles_Type ea;
	struct _Instance* sibling;

	parent = instance->LinkParent;
	if (parent != NULL)
	{
		if (parent->LinkChild == instance)
		{
			parent->LinkChild = instance->LinkSibling;
		}
		else
		{
			sibling = parent->LinkChild;
			while (sibling->LinkSibling != instance)
			{
				sibling = sibling->LinkSibling;
			}
			sibling->LinkSibling = instance->LinkSibling;
		}
		instance->LinkSibling = NULL;
		instance->LinkParent = NULL;
		instance->scale.x = (instance->scale.x * parent->scale.x) / 4096;
		instance->scale.y = (instance->scale.y * parent->scale.y) / 4096;
		instance->scale.z = (instance->scale.z * parent->scale.z) / 4096;
		if (parent->matrix != NULL)
		{
			G2EulerAngles_FromMatrix(&ea, (struct _G2Matrix_Type*)(parent->matrix + instance->ParentLinkNode), 21);
			instance->rotation.x = ea.x;
			instance->rotation.y = ea.y;
			instance->rotation.z = ea.z;
		}
		INSTANCE_Post(parent, 0x100013, (int)instance);
	}
}

void INSTANCE_UnlinkChildren(struct _Instance* instance)  // Matching - 100%
{
	struct _Instance* child;
	struct _Instance* sibling;

	child = instance->LinkChild;
	while (child != NULL)
	{
		sibling = child->LinkSibling;
		INSTANCE_Post(instance, 0x100013, (int)child);
		child->LinkParent = NULL;
		child->LinkSibling = NULL;
		child = sibling;
	}
	instance->LinkChild = NULL;
}

void INSTANCE_UpdateFamilyStreamUnitID(struct _Instance* instance)
{
	struct _Instance* child;
	
	child = instance->LinkChild;

	while (child != NULL)
	{
		child->currentStreamUnitID = instance->currentStreamUnitID;
		INSTANCE_UpdateFamilyStreamUnitID(child);
		child = child->LinkSibling;
	}
}

void INSTANCE_ReallyRemoveAllChildren(struct _Instance* instance)//Matching - 99.57%
{
	struct _Instance* child;

	struct _Instance* sibling;

	child = instance->LinkChild;

	while (child)
	{
		sibling = child->LinkSibling;
		
		INSTANCE_ReallyRemoveAllChildren(child);
		
		INSTANCE_ReallyRemoveInstance(gameTrackerX.instanceList, child, 0);
		
		child = sibling;
	}
}

struct _Instance* INSTANCE_GetChildLinkedToSegment(struct _Instance* instance, int segment)
{
	struct _Instance* child;

	child = instance->LinkChild;

	while (child != NULL)
	{
		if (child->ParentLinkNode == segment)
		{
			break;
		}

		child = child->LinkSibling;
	}

	return child;
}

int INSTANCE_Linked(struct _Instance* instance1, struct _Instance* instance2)//Matching - 100%
{
	while (instance1->LinkParent)
	{
		instance1 = instance1->LinkParent;
	}

	while (instance2->LinkParent)
	{
		instance2 = instance2->LinkParent;
	}

	return instance1 == instance2;
}

int INSTANCE_GetFadeValue(struct _Instance* instance)
{
	int fadeValue;

	fadeValue = instance->fadeValue;

	if (gameTrackerX.gameData.asmData.MorphTime != 1000)
	{
		fadeValue = 4096 - fadeValue;

		if (MEMPACK_MemoryValidFunc((char*)instance->object) != 0)
		{
			if ((instance->object->oflags2 & 0x2000000) || (instance->LinkParent != NULL && instance->LinkParent->object->oflags2 & 0x2000000))
			{
				if((instance->flags2 & 0x8000000))
				{
					if (gameTrackerX.spectral_fadeValue * fadeValue < 0)
					{
						fadeValue = (gameTrackerX.spectral_fadeValue * fadeValue + 4095) >> 12;
					}
					else
					{
						fadeValue = (gameTrackerX.spectral_fadeValue * fadeValue) >> 12;
					}
				}
				else
				{
					if (gameTrackerX.material_fadeValue * fadeValue < 0)
					{
						fadeValue = (gameTrackerX.material_fadeValue * fadeValue + 4095) >> 12;
					}
					else
					{
						fadeValue = (gameTrackerX.material_fadeValue * fadeValue) >> 12;
					}
				}
			}
		}
		
		fadeValue -= 4096;
	}

	return fadeValue;
}

unsigned long INSTANCE_DefaultAnimCallback(struct _G2Anim_Type* anim, int sectionID, enum _G2AnimCallbackMsg_Enum message, long messageDataA, long messageDataB, struct _Instance* instance)
{
	struct _AnimSoundData_Type* soundData;
	int id;
	int vol;

	if (message == G2ANIM_MSG_PLAYEFFECT)
	{
		if (messageDataA == 0)
		{
			soundData = (struct _AnimSoundData_Type*)messageDataB;

			if (sectionID != 0)
			{
				vol = soundData->volume;

				if (vol >= 1000)
				{
					vol %= 1000;

					if (vol / 1000 != HUMAN_TypeOfHuman(instance))
					{
						return 0;
					}
				}
			
				SOUND_Play3dSound(&instance->position, soundData->sfxToneID, soundData->pitch, vol, soundData->minVolDistance);

				return messageDataA;
			}
		}
		else if (messageDataA == 1)
		{
			FX_StartInstanceEffect(instance, (struct ObjectEffect*)messageDataB, 0);
		}
		else
		{
			return messageDataA;
		}
	}

	return messageDataA;
}