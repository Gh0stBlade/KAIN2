#include "CORE.H"
#include "STREAM.H"
#include "OBTABLE.H"
#include "GAMELOOP.H"
#include "SAVEINFO.H"
#include "LIGHT3D.H"
#include "SCRIPT.H"
#include "OBTABLE.H"
#include "SPLINE.H"
#include "EVENT.H"
#include "STATE.H"
#include "LIST.H"
#include "G2/ANIMG2.H"
#include "G2/INSTNCG2.H"
#include "G2/ANMG2ILF.H"
#include "MEMPACK.H"
#include "FX.H"
#include "SOUND.H"
#include "FONT.H"

// autogenerated function stub: 
// void /*$ra*/ INSTANCE_ClearTfaces(struct _Instance *instance /*$a0*/)
void INSTANCE_ClearTfaces(struct _Instance* instance)
{ // line 52, offset 0x80031ed8
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_Deactivate(struct _Instance *instance /*$s0*/)
void INSTANCE_Deactivate(struct _Instance* instance)
{ // line 66, offset 0x80031f04
	/* begin block 1 */
		// Start line: 67
		// Start offset: 0x80031F04
		// Variables:
	struct Object* object; // $a2
/* end block 1 */
// End offset: 0x80031FB0
// End Line: 91

/* begin block 2 */
	// Start line: 138
/* end block 2 */
// End Line: 139
	UNIMPLEMENTED();
}

void INSTANCE_Reactivate(struct _Instance* instance)
{
	struct Object* object;

	object = instance->object;

	instance->flags2 &= 0xFFFFFFFE;

	if ((instance->flags & 0x40000))
	{
		instance->flags &= 0xFFFBFFFF;
		instance->flags2 |= 0x20000000;
	}
	else
	{
		instance->flags2 &= 0xDFFFFFFF;
	}

	if (object->animList != NULL)
	{
		if (!(object->oflags2 & 0x40000000))
		{
			G2Anim_Restore(&instance->anim);
		}
	}
}

void INSTANCE_ForceActive(struct _Instance* instance)
{
	if ((instance->flags2 & 0x1))
	{
		INSTANCE_Reactivate(instance);
	}
}

void INSTANCE_DeactivatedProcess(struct _Instance* instance, struct GameTracker* gameTracker)
{
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_DeactivateFarInstances(struct GameTracker *gameTracker /*$s3*/)
void INSTANCE_DeactivateFarInstances(struct GameTracker* gameTracker)
{ // line 136, offset 0x80032094
	UNIMPLEMENTED();
}

void INSTANCE_InitInstanceList(struct _InstanceList* list, struct _InstancePool* pool)
{
	long i;

	pool->numFreeInstances = 60;
	
	for (i = 1; i < 59; i++)
	{
		pool->instance[i].next = &pool->instance[i + 1];
		pool->instance[i].prev = &pool->instance[i - 1];
	}

	pool->instance[0].next = &pool->instance[1];
	pool->instance[0].prev = NULL;

	pool->instance[59].prev = &pool->instance[58];
	pool->instance[59].next = NULL;
	
	pool->first_free = &pool->instance[0];

	list->pool = pool;
	list->numInstances = 0;
	list->first = NULL;

	for (i = 0; i < 32; i++)
	{
		list->group[i].next = NULL;
		list->group[i].prev = NULL;
	}

	pool->nextInstanceID = 1;
}

struct _Instance* INSTANCE_NewInstance(struct _InstanceList* list)
{
	struct _Instance* temp;
	struct _Instance* instance;

	if (list->pool->numFreeInstances != 0)
	{
		list->pool->numFreeInstances--;
		instance = list->pool->first_free;
		list->pool->first_free = instance->next;

		temp = list->first;
		list->first = instance;
		instance->next = temp;

		if (instance->next != NULL)
		{
			list->first->prev = instance;
		}
	
		instance->prev = NULL;
		instance->instanceID = list->pool->nextInstanceID++;

		list->numInstances++;

		return instance;
	}
	
	return NULL;
}

long INSTANCE_InstanceGroupNumber(struct _Instance* instance)
{
	long result;

	result = 0;

	if ((instance->object->oflags & 0x80))
	{
		result = (unsigned)(instance->flags & 0x8000) < 1;
	}
	
	if ((instance->object->oflags & 0x20) && !(instance->flags & 0x2000))
	{
		result |= 0x2;
	}
	
	if ((instance->object->oflags & 0x40) && !(instance->flags & 0x4000))
	{
		result |= 0x4;
	}

	if ((instance->object->oflags & 0x10) && !(instance->flags & 0x1000))
	{
		result |= 0x10;
	}

	if ((instance->object->oflags & 0x1))
	{
		result |= 0x8;
	}
	else
	{
		if (strcmp(instance->object->name, "raziel__"))
		{
			result &= 0xFFFFFFFD;
			result &= 0xFFFFFFFE;
		}
	}

	return result;
}

void INSTANCE_InsertInstanceGroup(struct _InstanceList* list, struct _Instance* instance)
{
	LIST_InsertFunc(&list->group[INSTANCE_InstanceGroupNumber(instance)], &instance->node);
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_ReallyRemoveInstance(struct _InstanceList *list /*$s1*/, struct _Instance *instance /*$s0*/, long reset /*$s2*/)
void INSTANCE_ReallyRemoveInstance(struct _InstanceList* list, struct _Instance* instance, long reset)
{ // line 499, offset 0x800325a0
	UNIMPLEMENTED();
}

void INSTANCE_CleanUpInstanceList(struct _InstanceList* list, long reset)
{
	struct _Instance* instance;
	struct _Instance* next;

	instance = list->first;
	
	while (instance != NULL)
	{
		next = instance->next;

		if ((instance->flags & 0x400))
		{
			if ((instance->flags & 0x20))
			{
				instance->flags &= 0xFFFFFFDF;
			}
		}
		else
		{
			instance->flags |= 0x20;
		}
		
		instance = next;
	}

	while (instance != NULL)
	{
		next = instance->next;

		if ((instance->flags & 0x20))
		{
			INSTANCE_ReallyRemoveInstance(instanceList, instance, reset);
		}

		instance = next;
	}
}

long INSTANCE_Introduced(struct Intro* intro, short streamUnitID)
{ 
	struct _Instance* instance;
	struct _Instance* next;
	long ret;

	instance = gameTrackerX.instanceList->first;
	
	ret = 0;

	while (instance != NULL)
	{
		next = instance->next;

		if (intro->UniqueID == instance->introUniqueID)
		{
			ret = 1;

			intro->flags |= 0x8;
			
			break;
		}

		instance = next;
	}

	if (SAVE_HasSavedIntro(intro, streamUnitID) == 0)
	{
		if (SAVE_IsIntroDeadDead(intro) == 0)
		{
			return ret;
		}
	}
	else
	{
		intro->flags |= 0x8;
		ret = 1;
	}

	return ret;
}

struct INICommand* INSTANCE_GetIntroCommand(struct INICommand* command, int cmd)
{
	if (command != NULL)
	{
		while (command->command != 0)
		{
			if (command->command != cmd)
			{
				command += command->numParameters + 1;
			}
			else
			{
				return command;
			}
		}
	}

	return 0;
}

struct INICommand* INSTANCE_FindIntroCommand(struct _Instance* instance, int cmd)//Matching - 99.44%
{
	return INSTANCE_GetIntroCommand((struct INICommand*)instance->introData, cmd);
}

void INSTANCE_ProcessIntro(struct _Instance* instance)//Matching - 100%
{
	struct INICommand* command;

	return;//inf loop
	UNIMPLEMENTED();

	if (instance->introData != NULL)
	{
		command = (struct INICommand*)instance->introData;

		if ((instance->flags & 2) == 0)
		{
			while (command->command)
			{
				if (command->command == 18)
				{
					instance->currentModel = command[1].command;
				}

				command += command->numParameters + 1;
			}
		}
	}
}

void INSTANCE_InitEffects(struct _Instance* instance, struct Object* object)
{
	int i;
	
	if (!(object->oflags2 & 0x100))
	{
		if (object->numberOfEffects != 0 && object->numberOfEffects > 0)
		{
			for (i = 0; i < object->numberOfEffects; i++)
			{
				FX_StartInstanceEffect(instance, &object->effectList[i], 1);
			}
		}
	}
}

struct _Instance* INSTANCE_IntroduceInstance(struct Intro* intro, short streamUnitID)
{
	struct Object* object;
	struct _Instance* instance;
	struct _Instance* attachInst;
	struct _ObjectTracker* objectTracker;
	struct INICommand* index;
	long attachedUniqueID;
	struct SavedIntroSpline* savedIntroSpline;
	struct MultiSpline* spline;
	struct SavedIntroSmall* savedIntroSmall;
	
	attachInst = NULL;
	index = NULL;

	if (!(INSTANCE_Introduced(intro, streamUnitID)))
	{
		attachedUniqueID = 0;
		index = INSTANCE_GetIntroCommand(index, 26);

		if (index != NULL)
		{
			attachedUniqueID = index->parameter[0];
		}

		objectTracker = STREAM_GetObjectTracker(intro->name);

		if (objectTracker != NULL)
		{
			object = objectTracker->object;

			if (objectTracker->objectStatus == 2)
			{
				savedIntroSmall = NULL;

				if (attachedUniqueID != 0)
				{
					attachInst = INSTANCE_Find(attachedUniqueID);
					if (attachInst == NULL)
					{
						return 0;
					}
				}


				if ((object->oflags2 & 0x10000000))
				{
					OBTABLE_InitAnimPointers(objectTracker);

					if ((object->oflags2 & 0x10000000))
					{
						return 0;
					}
				}

				instance = INSTANCE_NewInstance(gameTrackerX.instanceList);

				if (instance != NULL)
				{
					intro->flags |= 0x8;

					objectTracker->numInUse++;

					INSTANCE_DefaultInit(instance, object, 0);

					strcpy(instance->introName, intro->name);

					instance->introUniqueID = intro->UniqueID;
					instance->introNum = intro->intronum;
					instance->birthStreamUnitID = streamUnitID;
					instance->currentStreamUnitID = streamUnitID;

					intro->instance = instance;

					instance->intro = intro;
					instance->introData = intro->multiSpline;
					instance->position = intro->position;

					if (gameTrackerX.gameData.asmData.MorphType == 1)
					{
						if (intro->spectralPosition.x != 0 && intro->spectralPosition.y != 0 && intro->spectralPosition.z != 0)
						{
							instance->position.x = intro->position.x + intro->spectralPosition.x;
							instance->position.y = intro->position.y + intro->spectralPosition.y;
							instance->position.z = intro->position.z + intro->spectralPosition.z;
						}
					}

					instance->initialPos = instance->position;
					instance->oldPos = intro->position;

					LIGHT_GetAmbient((struct _ColorType*)&instance->light_color, instance);

					instance->rotation = intro->rotation;
					if ((instance->object->oflags & 0x100))
					{
						INSTANCE_BuildStaticShadow(instance);
					}

					instance->scale.x = 4096;
					instance->scale.y = 4096;
					instance->scale.z = 4096;

					if ((intro->flags & 0x2000))
					{
						instance->flags |= 0x400;
					}

					if ((intro->flags & 0x10000))
					{
						instance->flags2 |= 0x20000;
					}

					if (attachInst != NULL)
					{
						INSTANCE_ForceActive(attachInst);
						attachInst->flags2 |= 0x80;
					}

					if ((object->oflags2 & 0x80))
					{
						instance->flags |= 0x800;
					}

					if ((intro->flags & 0x800) && object->id == -1)
					{
						SCRIPTCountFramesInSpline(instance);
						SCRIPT_InstanceSplineSet(instance, -1, NULL, NULL, NULL);
						instance->flags = (instance->flags ^ 0x1000000) | 0x100000;
					}

					instance->lightGroup = (unsigned char)intro->rotation.pad;
					instance->spectralLightGroup = intro->specturalLightGroup;

					INSTANCE_InsertInstanceGroup(gameTrackerX.instanceList, instance);
					OBTABLE_GetInstanceCollideFunc(instance);
					OBTABLE_GetInstanceProcessFunc(instance);
					OBTABLE_GetInstanceQueryFunc(instance);
					OBTABLE_GetInstanceMessageFunc(instance);
					OBTABLE_GetInstanceAdditionalCollideFunc(instance);

					if (!(intro->flags & 0x10))
					{
						OBTABLE_InstanceInit(instance);
					}

					MORPH_SetupInstanceFlags(instance);

					if ((intro->flags & 0x80))
					{
						instance->flags |= 0x800;
						instance->flags2 |= 0x20000000;

						if ((object->oflags2 & 0x80000))
						{
							instance->flags2 |= 0x10000000;
						}
					}

					if (SCRIPT_GetMultiSpline(instance, NULL, NULL) == NULL)
					{
						instance->flags = (instance->flags & 0xFDFFFFFF) | 0x100000;
					}
					else
					{
						spline = SCRIPT_GetMultiSpline(instance, NULL, NULL);
						savedIntroSpline = SAVE_GetIntroSpline(instance);

						if (savedIntroSpline != NULL)
						{
							SCRIPT_InstanceSplineSet(instance, savedIntroSpline->splineKeyFrame, NULL, NULL, NULL);

							instance->oldPos = instance->position;
							instance->splineFlags = savedIntroSpline->splineFlags;
							instance->clipBeg = savedIntroSpline->splineClipBeg;
							instance->clipEnd = savedIntroSpline->splineClipEnd;

							if ((instance->splineFlags & 0x80))
							{
								instance->flags |= 0x1000000;
							}

							if ((instance->splineFlags & 0x100))
							{
								instance->flags |= 0x2000000;
							}

							if ((savedIntroSpline->splineFlags & 0x10))
							{
								if (spline->positional != NULL)
								{
									spline->positional->flags |= 0x1;
								}

								if (spline->rotational != NULL)
								{
									spline->rotational->flags |= 0x1;
								}

								if (spline->scaling != NULL)
								{
									spline->scaling->flags |= 0x1;
								}

								if (spline->color != NULL)
								{
									spline->color->flags |= 0x1;
								}
							}
							else if ((instance->splineFlags & 0x20))
							{
								if (spline->positional != NULL)
								{
									spline->positional->flags |= 0x2;
								}

								if (spline->rotational != NULL)
								{
									spline->rotational->flags |= 0x2;
								}

								if (spline->scaling != NULL)
								{
									spline->scaling->flags |= 0x2;
								}

								if (spline->color != NULL)
								{
									spline->color->flags |= 0x2;
								}
							}
							else if ((instance->splineFlags & 0x40))
							{
								if (spline->positional != NULL)
								{
									spline->positional->flags |= 0x4;
								}

								if (spline->rotational != NULL)
								{
									spline->rotational->flags |= 0x4;
								}

								if (spline->scaling != NULL)
								{
									spline->scaling->flags |= 0x4;
								}

								if (spline->color != NULL)
								{
									spline->color->flags |= 0x4;
								}
							}
						}
					}

					EVENT_AddInstanceToInstanceList(instance);

					INSTANCE_ProcessIntro(instance);
					INSTANCE_InitEffects(instance, object);

					savedIntroSmall = SAVE_GetSavedSmallIntro(instance);

					if (savedIntroSmall != NULL)
					{
						INSTANCE_Post(instance, 0x100007, SetControlSaveDataData((savedIntroSmall->shiftedSaveSize << 2) - 4, savedIntroSmall + 1));
					}

					return instance;
				}
			}
		}
	}
	return NULL;
}

void INSTANCE_AdditionalCollideFunctions(struct _InstanceList* instanceList)//Matching - 97.97%
{
	struct _Instance* instance;

	instance = instanceList->first;

	while (instance != NULL)
	{
		if (gameTrackerX.gameMode != 6 || (instance->object->oflags & 0x20000))
		{
			if (!(gameTrackerX.streamFlags & 0x100000) || (instance->object->oflags & 0x40000))
			{
				if (instance->additionalCollideFunc != NULL)
				{
					if (!(instance->flags2 & 0x24000000))
					{
						if (instance->object != NULL)
						{
							if ((instance->object->oflags2 & 0x2000000))
							{
								if ((instance->flags2 & 0x8000000))
								{
									gameTrackerX.timeMult = gameTrackerX.spectralTimeMult;
								}
								else
								{
									gameTrackerX.timeMult = gameTrackerX.materialTimeMult;
								}
							}
							else
							{
								gameTrackerX.timeMult = gameTrackerX.globalTimeMult;
							}
						}
						else
						{
							gameTrackerX.timeMult = gameTrackerX.globalTimeMult;
						}

						instance->additionalCollideFunc(instance, &gameTrackerX);
					}
				}
			}
		}

		instance = instance->next;
	}
	gameTrackerX.timeMult = gameTrackerX.globalTimeMult;
}

long INSTANCE_GetSplineFrameNumber(struct _Instance* instance, struct MultiSpline* spline)
{
	return SCRIPT_GetSplineFrameNumber(instance, SCRIPT_GetPosSplineDef(instance, spline, 0, 0));
}

void INSTANCE_ProcessFunctions(struct _InstanceList* instanceList)
{
	struct _Instance* instance;
	int hidden;
	int burning;
	long prevFrame;
	struct MultiSpline* multi;
	long endOfSpline;
	short direction;
	long frame;
	long maxFrames;
	int killTest;

	if (!(gameTrackerX.debugFlags & 0x8000010))
	{
		if (gameTrackerX.gameMode != 6 && !(gameTrackerX.streamFlags & 0x100000))
		{
			gameTrackerX.streamFlags &= 0xFFFFFFFB;
		}

		instance = instanceList->first;

		while (instance != NULL)
		{
			if (instance->object != NULL && (instance->object->oflags2 & 0x2000000))
			{
				if ((instance->flags2 & 0x8000000))
				{
					gameTrackerX.timeMult = gameTrackerX.spectralTimeMult;
				}
				else
				{
					gameTrackerX.timeMult = gameTrackerX.materialTimeMult;
				}
			}
			else
			{
				gameTrackerX.timeMult = gameTrackerX.globalTimeMult;
			}

			burning = 0;

			if ((instance->object->oflags2 & 0x4))
			{
				hidden = instance->flags & 0x800;

				if ((INSTANCE_Query(instance, 0x2) & 0x80))
				{
					burning = burning < INSTANCE_Query(instance, 0x3) & 0x10000;
				}
				else
				{
					if ((instance->object->oflags2 & 0x80000) && ((unsigned int*)instance->extraData)[0] & 0x400000)
					{
						burning = 1;
					}
				}

				SOUND_ProcessInstanceSounds(instance->object->soundData, &instance->soundInstanceTbl[0], &instance->position, instance->object->oflags2 & 0x2000000, instance->flags2 & 0x8000000, hidden, burning, &instance->flags2);
			}

			if (instance->intro == NULL || (instance->intro->flags & 0x100))
			{
				if(gameTrackerX.gameMode != 6 || (instance->object->oflags & 0x20000))
				{
					if (!(gameTrackerX.streamFlags & 0x100000) || (instance->object->oflags & 0x40000))
					{
						if (!(instance->flags2 & 0x10000000))
						{
							instance->oldPos.x = instance->position.x;
							instance->oldPos.y = instance->position.y;
							instance->oldPos.z = instance->position.z;

							instance->oldRotation.x = instance->rotation.x;
							instance->oldRotation.y = instance->rotation.y;
							instance->oldRotation.z = instance->rotation.z;

							if (!(instance->flags & 0x10000000))
							{
								multi = SCRIPT_GetMultiSpline(instance, NULL, NULL);

								if (multi != NULL && (instance->flags & 0x2000000))
								{
									if ((instance->flags & 0x1000000))
									{
										direction = -1;
									}
									else
									{
										direction = 1;
									}

									if ((instance->object->oflags & 0x10000000))
									{
										instance->flags |= 0x400;
										
										if (SplineMultiIsWhere(multi) != 0)
										{
											if (direction > 0)
											{
												instance->intro->flags |= 0x800;
											}
											else
											{
												instance->intro->flags &= 0xFFFFF7FF;
											}
										}
									}

									prevFrame = INSTANCE_GetSplineFrameNumber(instance, multi);

									endOfSpline = SCRIPT_InstanceSplineProcess(instance, &multi->curPositional, &multi->curRotational, &multi->curScaling, direction);
								
									if (instance->splineFlags != 0)
									{
										frame = INSTANCE_GetSplineFrameNumber(instance, multi);

										maxFrames = SCRIPTCountFramesInSpline(instance);
									
										if ((instance->splineFlags & 0x1))
										{
											if ((gameTrackerX.debugFlags2 & 0x400000))
											{
												printf("Spline %s%ld playto %d preveFram=%ld frame=%ld endOfSpline=%ld, maxFrames=%ld\n", instance->introName, instance->introNum, instance->targetFrame, prevFrame, frame, endOfSpline, maxFrames);
											}

											if (direction > 0)
											{
												if (maxFrames < prevFrame)
												{
													prevFrame = maxFrames;
												}

												if (frame >= instance->targetFrame && instance->targetFrame < prevFrame)
												{
													if (frame >= prevFrame)
													{
														instance->flags &= 0xFDFFFFFF;
														SCRIPT_InstanceSplineSet(instance, instance->targetFrame, NULL, NULL, NULL);
													}
												}
												else
												{
													if (frame < prevFrame && frame >= instance->targetFrame)
													{
														if (instance->targetFrame + maxFrames >= prevFrame)
														{
															instance->flags &= 0xFDFFFFFF;
															SCRIPT_InstanceSplineSet(instance, instance->targetFrame, NULL, NULL, NULL);
														}
													}
												}
											}
											else
											{
												if (instance->targetFrame >= frame && prevFrame < instance->targetFrame)
												{
													instance->flags &= 0xFDFFFFFF;
													SCRIPT_InstanceSplineSet(instance, instance->targetFrame, NULL, NULL, NULL);
												}
												else
												{
													if (prevFrame < frame)
													{
														if (prevFrame + maxFrames >= instance->targetFrame)
														{
															instance->flags &= 0xFDFFFFFF;
															SCRIPT_InstanceSplineSet(instance, instance->targetFrame, NULL, NULL, NULL);
														}
													}
												}
											}
										}

										if ((instance->splineFlags & 0x2))
										{
											if ((gameTrackerX.debugFlags2 & 0x400000))
											{
												FONT_Print("Spline %s%d : clip(%d,%d) prevFrame=%d, frame=%d\n", instance->introName, instance->introNum, instance->clipBeg, instance->clipEnd, frame, prevFrame);
											}

											if (direction == 1)
											{
												if (instance->clipEnd < prevFrame || frame < instance->clipEnd && frame < instance->clipBeg)
												{
													if (*(unsigned int*)&multi->positional->numkeys & 0x6000000)
													{
														SCRIPT_InstanceSplineSet(instance, instance->clipBeg, NULL, NULL, NULL);
													}
													else
													{
														killTest = 1;

														SCRIPT_InstanceSplineSet(instance, instance->clipEnd, NULL, NULL, NULL);
													}
												}
											}
											else
											{
												if (prevFrame < instance->clipBeg || instance->clipBeg >= frame && instance->clipEnd < frame)
												{
													if (*(unsigned int*)&multi->positional->numkeys & 0x6000000)
													{
														SCRIPT_InstanceSplineSet(instance, instance->clipBeg, NULL, NULL, NULL);
													}
													else
													{
														killTest = 1;

														SCRIPT_InstanceSplineSet(instance, instance->clipEnd, NULL, NULL, NULL);
													}
												}
											}
										}
									}
									else
									{
										if ((gameTrackerX.debugFlags2 & 0x400000))
										{
											FONT_Print("Spline %s%d prevFrame=%d, frame=%d\n", instance->introName, instance->introNum, prevFrame, INSTANCE_GetSplineFrameNumber(instance, multi));
										}
									}
									
									if (endOfSpline > 0)
									{
										if ((instance->object->oflags & 0x10000000))
										{
											instance->flags &= 0xFFFFFBFF;
											instance->flags &= 0xFDFFFFFF;
											instance->flags |= 0x100000;
										}

										if ((instance->object->oflags & 0x20000000))
										{
											instance->flags |= 0x100000;

											INSTANCE_KillInstance(instance);
										}
										else
										{
											if ((instance->object->oflags & 0x1000))
											{
												instance->flags &= 0xFDFFFFFF;

												if ((instance->object->oflags & 0x800000))
												{
													SCRIPT_InstanceSplineInit(instance);
												}
											}
											else if ((instance->object->oflags & 0x1000000))
											{
												instance->flags &= 0xFDFFFFFF;
											}

											if (multi->positional != NULL)
											{
												if (!(multi->positional->flags & 0x4))
												{
													if (!(instance->object->oflags & 0x800000))
													{
														instance->flags ^= 0x1000000;
													}
												}
											}
											else if (multi->rotational != NULL)
											{
												if (!(multi->rotational->flags & 0x4))
												{
													if (!(instance->object->oflags & 0x800000))
													{
														instance->flags ^= 0x1000000;
													}
												}
											}

											if ((instance->object->oflags & 0x200000) && instance->introData != NULL && ((unsigned int*)instance->introData)[0] != NULL)
											{
												SIGNAL_HandleSignal(instance, (struct Signal*)(((unsigned int*)instance->introData)[0] + 8), 0);
											}
											else
											{
												if (instance->processFunc != NULL)
												{
													if ((instance->flags2 & 0x1))
													{
														INSTANCE_DeactivatedProcess(instance, &gameTrackerX);
													}
													else
													{
														instance->processFunc(instance, &gameTrackerX);
													}
												}

												if (32768 < instance->position.z - instance->oldPos.z)
												{
													INSTANCE_PlainDeath(instance);
												}

												if (instance->position.z - instance->oldPos.z < -32768)
												{
													INSTANCE_PlainDeath(instance);
												}

												if (INSTANCE_Query(instance, 0x2F) != 0)
												{
													gameTrackerX.streamFlags |= 0x4;
												}
											}
										}
									}
									else
									{
										if (instance->processFunc != NULL)
										{
											if ((instance->flags2 & 0x1))
											{
												INSTANCE_DeactivatedProcess(instance, &gameTrackerX);
											}
											else
											{
												instance->processFunc(instance, &gameTrackerX);
											}
										}

										if (32768 < instance->position.z - instance->oldPos.z)
										{
											INSTANCE_PlainDeath(instance);
										}

										if (instance->position.z - instance->oldPos.z < -32768)
										{
											INSTANCE_PlainDeath(instance);
										}

										if (INSTANCE_Query(instance, 0x2F) != 0)
										{
											gameTrackerX.streamFlags |= 0x4;
										}
									}
								}
								else
								{
									if (instance->processFunc != NULL)
									{
										if ((instance->flags2 & 0x1))
										{
											INSTANCE_DeactivatedProcess(instance, &gameTrackerX);
										}
										else
										{
											instance->processFunc(instance, &gameTrackerX);
										}
									}

									if (32768 < instance->position.z - instance->oldPos.z)
									{
										INSTANCE_PlainDeath(instance);
									}

									if (instance->position.z - instance->oldPos.z < -32768)
									{
										INSTANCE_PlainDeath(instance);
									}

									if (INSTANCE_Query(instance, 0x2F) != 0)
									{
										gameTrackerX.streamFlags |= 0x4;
									}
								}
							}
							else
							{
								if (instance->processFunc != NULL)
								{
									if ((instance->flags2 & 0x1))
									{
										INSTANCE_DeactivatedProcess(instance, &gameTrackerX);
									}
									else
									{
										instance->processFunc(instance, &gameTrackerX);
									}
								}

								if (32768 < instance->position.z - instance->oldPos.z)
								{
									INSTANCE_PlainDeath(instance);
								}

								if (instance->position.z - instance->oldPos.z < -32768)
								{
									INSTANCE_PlainDeath(instance);
								}

								if (INSTANCE_Query(instance, 0x2F) != 0)
								{
									gameTrackerX.streamFlags |= 0x4;
								}
							}
						}
					}
				}
			}

			instance = instance->next;
		}
	}
}

struct _Instance* INSTANCE_BirthObject(struct _Instance* parent, struct Object* object, int modelNum)
{
	struct _Instance* instance;
	int i;

	if (object != NULL)
	{
		instance = INSTANCE_NewInstance(gameTrackerX.instanceList);

		if (instance != NULL)
		{
			INSTANCE_DefaultInit(instance, object, modelNum);
			
			instance->position.x = parent->position.x;
			instance->position.y = parent->position.y;
			instance->position.z = parent->position.z;
			
			instance->initialPos.x = instance->position.x;
			instance->initialPos.y = instance->position.y;
			instance->initialPos.z = instance->position.z;
			
			instance->oldPos.x = parent->position.x;
			instance->oldPos.y = parent->position.y;
			instance->oldPos.z = parent->position.z;
			
			instance->rotation.x = parent->rotation.x;
			instance->rotation.y = parent->rotation.y;
			instance->rotation.z = parent->rotation.z;
			
			instance->scale.x = parent->scale.x;
			instance->scale.y = parent->scale.y;
			instance->scale.z = parent->scale.z;
			instance->scale.pad = parent->scale.pad;
			
			instance->lightGroup = parent->lightGroup;
			instance->spectralLightGroup = parent->spectralLightGroup;
			
			instance->currentStreamUnitID = parent->currentStreamUnitID;
			instance->birthStreamUnitID = parent->birthStreamUnitID;
			instance->introUniqueID = GlobalSave->CurrentBirthID;

			GlobalSave->CurrentBirthID++;
			
			strcpy(instance->introName, object->name);

			i = 0;

			do
			{
				if (i >= strlen(instance->introName))
				{
					goto loc_80034008;//:(
				}

			} while (instance->introName[i++] != '\x5F');

			instance->introName[i] = 0;

loc_80034008://:(

			instance->parent = parent;
			instance->intro = parent->intro;
			instance->introData = parent->introData;

			LIGHT_GetAmbient((struct _ColorType*)&instance->light_color, instance);

			if ((instance->object->oflags & 0x100))
			{
				INSTANCE_BuildStaticShadow(instance);
			}

			if (SCRIPT_GetMultiSpline(instance, NULL, NULL) == NULL)
			{
				instance->flags |= 0x100000;
			}

			if ((parent->flags2 & 0x8000000))
			{
				instance->flags2 |= 0x8000000;
			}

			INSTANCE_InsertInstanceGroup(gameTrackerX.instanceList, instance);

			OBTABLE_GetInstanceCollideFunc(instance);
			OBTABLE_GetInstanceProcessFunc(instance);
			OBTABLE_GetInstanceQueryFunc(instance);
			OBTABLE_GetInstanceMessageFunc(instance);
			OBTABLE_GetInstanceAdditionalCollideFunc(instance);

			instance->flags |= 0x2;

			OBTABLE_InstanceInit(instance);

			EVENT_AddInstanceToInstanceList(instance);

			INSTANCE_InitEffects(instance, object);

			return instance;
		}
	}
	
	return NULL;
}

void INSTANCE_BuildStaticShadow(struct _Instance* instance)
{
}

void INSTANCE_DefaultInit(struct _Instance* instance, struct Object* object, int modelNum)//Matching - 97.34%
{
	int i;
	int j;
	int numHPrims;
	int numModels;
	struct _HPrim* hprim;
	struct _Model** pModel;
	struct _HModel* hmodel;
	struct _Model* model;
	struct _Segment* seg;
	struct _HInfo* hinfo;
	int k;
	struct _HFace* hface;
	struct _HSphere* hsphere;
	struct _HBox* hbox;

	memset(&instance->flags, 0, sizeof(struct _Instance) - 0x14);

	instance->object = object;
	instance->data = object->data;
	instance->currentModel = modelNum;
	instance->cachedTFace = -1;
	instance->cachedTFaceLevel = NULL;

	if (object->animList != NULL && !(object->oflags2 & 0x40000000))
	{
		G2Anim_Init(&instance->anim, object->modelList[modelNum]);
		G2Anim_SwitchToKeylist(&instance->anim, G2Instance_GetKeylist(instance, 0), 0);
		G2Anim_SetCallback(&instance->anim, INSTANCE_DefaultAnimCallback, instance);
	}

	if ((object->oflags & 0x4000000))
	{
		instance->flags2 |= 0x4;
	}

	if ((object->oflags & 0x200))
	{
		instance->flags2 |= 0x40;
	}

	if ((object->oflags & 0x8))
	{
		instance->flags2 |= 0x8000000;
	}

	if (!(object->oflags & 0x1000800))
	{
		instance->flags |= 0x2000000;
	}

	if ((object->oflags & 0x20000000))
	{
		instance->flags2 |= 0x20;
	}

	numModels = object->numModels;
	pModel = object->modelList;

	numHPrims = 0;

	for (i = numModels; i != 0; i--, pModel++)
	{
		for (j = pModel[0]->numSegments, seg = pModel[0]->segmentList; j != 0; seg++, j--)
		{
			hinfo = seg->hInfo;

			if (hinfo != NULL)
			{
				numHPrims += hinfo->numHFaces + hinfo->numHSpheres + hinfo->numHBoxes;
			}
		}
	}

	if (numHPrims != 0)
	{
		hmodel = (struct _HModel*)MEMPACK_Malloc((instance->object->numModels + numHPrims) * 8, 0xE);

		instance->hModelList = hmodel;
		pModel = object->modelList;
		hprim = (struct _HPrim*)hmodel + numModels;

		for (i = numModels; i != 0; i--, pModel++, hmodel++)
		{
			model = pModel[0];
			hmodel->numHPrims = 0;
			hmodel->hPrimList = hprim;
			seg = model->segmentList;

			for (j = 0; j < model->numSegments; j++, seg++)
			{
				hinfo = seg->hInfo;

				if (hinfo != NULL)
				{
					hface = hinfo->hfaceList;
					hsphere = hinfo->hsphereList;
					hbox = hinfo->hboxList;

					hmodel->numHPrims += hinfo->numHFaces + hinfo->numHSpheres + hinfo->numHBoxes;

					for (k = hinfo->numHFaces; k != 0; hprim++, hface++, k--)
					{
						hprim->hpFlags = 0x4D;
						hprim->withFlags = 0x24;
						hprim->type = 2;
						hprim->segment = j;
						hprim->data.hface = hface;
					}

					for (k = hinfo->numHSpheres; k != 0; hprim++, hsphere++, k--)
					{
						hprim->hpFlags = 0x2F;
						hprim->withFlags = 0x76;
						hprim->type = 1;
						hprim->segment = j;
						hprim->data.hsphere = hsphere;
					}

					for (k = hinfo->numHBoxes; k != 0; hprim++, hbox++, k--)
					{
						hprim->hpFlags = 0x1D;
						hprim->withFlags = 0x24;
						hprim->type = 5;
						hprim->segment = j;
						hprim->data.hbox = hbox;
					}
				}
			}
		}
	}
	else
	{
		instance->hModelList = NULL;
		instance->flags2 |= 0x40000;
	}

	if (instance->maxCheckDistance == 0)
	{
		instance->maxCheckDistance = 12000;
	}
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_PlainDeath(struct _Instance *instance /*$s5*/)
void INSTANCE_PlainDeath(struct _Instance* instance)
{ // line 1793, offset 0x80034230
	UNIMPLEMENTED();
}

void INSTANCE_KillInstance(struct _Instance* instance)
{
	if (!(instance->flags & 0x20))
	{
		INSTANCE_PlainDeath(instance);
	}
}

unsigned long INSTANCE_Query(struct _Instance* Inst, int Query)
{
	unsigned long (*Func)(struct _Instance*, unsigned long);

	Func = Inst->queryFunc;

	if (Func != NULL)
	{
		return Func(Inst, Query);
	}

	return 0;
}

void INSTANCE_Post(struct _Instance* Inst, int Message, int Data)
{
	void (*Func)(_Instance*, unsigned long, unsigned long);

	Func = Inst->messageFunc;

	if (Func != NULL)
	{
		INSTANCE_ForceActive(Inst);

		Func(Inst, Message, Data);
	}
}

void INSTANCE_Broadcast(struct _Instance* sender, long whatAmIMask, int Message, int Data)
{
	struct _Instance* instance;
	int plane;

	instance = gameTrackerX.instanceList->first;

	plane = gameTrackerX.gameData.asmData.MorphType;

	while (instance != NULL)
	{
		if (instance != sender)
		{
			if ((INSTANCE_Query(instance, 1) & whatAmIMask))
			{
				if (INSTANCE_InPlane(instance, plane))
				{
					INSTANCE_Post(instance, Message, Data);
				}
			}
		}

		instance = instance->next;
	}
}

int INSTANCE_InPlane(struct _Instance* instance, int plane)
{
	UNIMPLEMENTED();
	return 0;
}

long INSTANCE_FindWithID(long uniqueID)
{
	struct _Instance* instance;
	struct _Instance* next;
	long ret;

	instance = gameTrackerX.instanceList->first;
	ret = 0;

	while (instance != NULL)
	{
		next = instance->next;

		if (instance->introUniqueID == uniqueID)
		{
			ret = 1;
			break;
		}

		instance = next;
	}

	return ret;
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ INSTANCE_FindWithName(long areaID /*$s3*/, char *instanceName /*$s4*/, struct _Instance *startInstance /*$a2*/)
struct _Instance* INSTANCE_FindWithName(long areaID, char* instanceName, struct _Instance* startInstance)
{ // line 1995, offset 0x8003457c
	UNIMPLEMENTED();
	return NULL;
}


// autogenerated function stub: 
// struct Intro * /*$ra*/ INSTANCE_FindIntro(long areaID /*$a0*/, long introUniqueID /*$s1*/)
struct Intro* INSTANCE_FindIntro(long areaID, long introUniqueID)
{ // line 2065, offset 0x80034650
	UNIMPLEMENTED();
	return NULL;
}

struct _Instance* INSTANCE_Find(long introUniqueID)
{
	struct _Instance* instance;

	instance = gameTrackerX.instanceList->first;

	while (instance != NULL)
	{
		if (instance->introUniqueID == introUniqueID)
		{
			break;
		}

		instance = instance->next;
	}

	return instance;
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ INSTANCE_IntroduceSavedInstance(struct _SavedIntro *savedIntro /*$s2*/, struct _StreamUnit *streamUnit /*$a1*/, int *deleted /*$fp*/)
struct _Instance* INSTANCE_IntroduceSavedInstance(struct _SavedIntro* savedIntro, struct _StreamUnit* streamUnit, int* deleted)
{ // line 2102, offset 0x80034714
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ INSTANCE_IntroduceSavedInstanceWithIntro(struct _SavedIntroWithIntro *savedIntro /*$s4*/, struct _StreamUnit *streamUnit /*$s6*/, int *deleted /*stack 8*/)
struct _Instance* INSTANCE_IntroduceSavedInstanceWithIntro(struct _SavedIntroWithIntro* savedIntro, struct _StreamUnit* streamUnit, int* deleted)
{ // line 2327, offset 0x80034b8c
	/* begin block 1 */
		// Start line: 2328
		// Start offset: 0x80034B8C
		// Variables:
	struct _ObjectTracker* objectTracker; // $s1
	struct Object* object; // $s7
	struct _Instance* instance; // $s0
	_Position* levelOffset; // $fp
	struct Level* level; // $v1
	struct Intro* intro; // $s2
	struct _Instance* attachedInst; // $s5

/* begin block 1.1 */
	// Start line: 2372
	// Start offset: 0x80034CC4
	// Variables:
	int remove; // $s1
	int nosave; // $s2

/* begin block 1.1.1 */
	// Start line: 2376
	// Start offset: 0x80034CC4
	// Variables:
	short _x0; // $v0
	short _y0; // $a0
	short _z0; // $v1
	short _x1; // $a1
	short _y1; // $a2
	short _z1; // $a3
	_Position* _v; // $v0
	_Position* _v0; // $v1
/* end block 1.1.1 */
// End offset: 0x80034CC4
// End Line: 2376

/* begin block 1.1.2 */
	// Start line: 2513
	// Start offset: 0x80034F4C
/* end block 1.1.2 */
// End offset: 0x80034F68
// End Line: 2524
/* end block 1.1 */
// End offset: 0x80034F9C
// End Line: 2533
/* end block 1 */
// End offset: 0x80034FCC
// End Line: 2549

/* begin block 2 */
	// Start line: 5380
/* end block 2 */
// End Line: 5381
	UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_SpatialRelationships(struct _InstanceList *instanceList /*$s4*/)
void INSTANCE_SpatialRelationships(struct _InstanceList* instanceList)
{ // line 2596, offset 0x80035000
	/* begin block 1 */
		// Start line: 2597
		// Start offset: 0x80035000
		// Variables:
	struct _Instance* instance; // $s1
	struct _Instance* checkee; // $s0

/* begin block 1.1 */
	// Start line: 2606
	// Start offset: 0x8003504C
	// Variables:
	//MATRIX* lookMatrix; // $s0
	long checkMask; // $s3

/* begin block 1.1.1 */
	// Start line: 2615
	// Start offset: 0x80035074
	// Variables:
	//MATRIX invMatrix; // stack offset -80

/* begin block 1.1.1.1 */
	// Start line: 2624
	// Start offset: 0x800350D0
	// Variables:
	//struct evCollideInstanceStatsData data; // stack offset -48
	//MATRIX* mat; // $a2
/* end block 1.1.1.1 */
// End offset: 0x80035124
// End Line: 2634
/* end block 1.1.1 */
// End offset: 0x80035134
// End Line: 2636
/* end block 1.1 */
// End offset: 0x80035134
// End Line: 2637
/* end block 1 */
// End offset: 0x80035144
// End Line: 2639

/* begin block 2 */
	// Start line: 5192
/* end block 2 */
// End Line: 5193
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ INSTANCE_SetStatsData(struct _Instance *instance /*$s1*/, struct _Instance *checkee /*$s5*/, struct _Vector *checkPoint /*$s2*/, struct evCollideInstanceStatsData *data /*$s3*/, MATRIX *mat /*stack 16*/)
int INSTANCE_SetStatsData(struct _Instance* instance, struct _Instance* checkee, struct _Vector* checkPoint, struct evCollideInstanceStatsData* data, MATRIX* mat)
{ // line 2643, offset 0x80035164
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_LinkToParent(struct _Instance *instance /*$s0*/, struct _Instance *parent /*$s1*/, int node /*$a2*/)
void INSTANCE_LinkToParent(struct _Instance* instance, struct _Instance* parent, int node)
{ // line 2672, offset 0x80035274
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_UnlinkFromParent(struct _Instance *instance /*$s0*/)
void INSTANCE_UnlinkFromParent(struct _Instance* instance)
{ // line 2693, offset 0x80035330
	/* begin block 1 */
		// Start line: 2694
		// Start offset: 0x80035330
		// Variables:
	struct _Instance* parent; // $s1

/* begin block 1.1 */
	// Start line: 2698
	// Start offset: 0x80035354
	// Variables:
	//struct _G2EulerAngles_Type ea; // stack offset -24

/* begin block 1.1.1 */
	// Start line: 2706
	// Start offset: 0x80035370
	// Variables:
	struct _Instance* sibling; // $v1
/* end block 1.1.1 */
// End offset: 0x800353A4
// End Line: 2712
/* end block 1.1 */
// End offset: 0x80035480
// End Line: 2732
/* end block 1 */
// End offset: 0x80035480
// End Line: 2733

/* begin block 2 */
	// Start line: 6228
/* end block 2 */
// End Line: 6229
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_UnlinkChildren(struct _Instance *instance /*$s2*/)
void INSTANCE_UnlinkChildren(struct _Instance* instance)
{ // line 2735, offset 0x80035494
	UNIMPLEMENTED();
}

void INSTANCE_UpdateFamilyStreamUnitID(struct _Instance* instance)
{
	struct _Instance* child;
	
	child = instance->LinkChild;

	while (child != NULL)
	{
		child->currentStreamUnitID = instance->currentStreamUnitID;
		INSTANCE_UpdateFamilyStreamUnitID(child);
		child = child->LinkSibling;
	}
}

void INSTANCE_ReallyRemoveAllChildren(struct _Instance* instance)//Matching - 99.57%
{
	struct _Instance* child;

	struct _Instance* sibling;

	child = instance->LinkChild;

	while (child)
	{
		sibling = child->LinkSibling;
		
		INSTANCE_ReallyRemoveAllChildren(child);
		
		INSTANCE_ReallyRemoveInstance(gameTrackerX.instanceList, child, 0);
		
		child = sibling;
	}
}

struct _Instance* INSTANCE_GetChildLinkedToSegment(struct _Instance* instance, int segment)
{
	struct _Instance* child;

	child = instance->LinkChild;

	while (child != NULL)
	{
		if (child->ParentLinkNode == segment)
		{
			break;
		}

		child = child->LinkSibling;
	}

	return child;
}

int INSTANCE_Linked(struct _Instance* instance1, struct _Instance* instance2)//Matching - 100%
{
	while (instance1->LinkParent)
	{
		instance1 = instance1->LinkParent;
	}

	while (instance2->LinkParent)
	{
		instance2 = instance2->LinkParent;
	}

	return instance1 == instance2;
}

int INSTANCE_GetFadeValue(struct _Instance* instance)
{
	int fadeValue;

	fadeValue = instance->fadeValue;

	if (gameTrackerX.gameData.asmData.MorphTime != 1000)
	{
		fadeValue = 4096 - fadeValue;

		if (MEMPACK_MemoryValidFunc((char*)instance->object) != 0)
		{
			if ((instance->object->oflags2 & 0x2000000) || (instance->LinkParent != NULL && instance->LinkParent->object->oflags2 & 0x2000000))
			{
				if((instance->flags2 & 0x8000000))
				{
					if (gameTrackerX.spectral_fadeValue * fadeValue < 0)
					{
						fadeValue = (gameTrackerX.spectral_fadeValue * fadeValue + 4095) >> 12;
					}
					else
					{
						fadeValue = (gameTrackerX.spectral_fadeValue * fadeValue) >> 12;
					}
				}
				else
				{
					if (gameTrackerX.material_fadeValue * fadeValue < 0)
					{
						fadeValue = (gameTrackerX.material_fadeValue * fadeValue + 4095) >> 12;
					}
					else
					{
						fadeValue = (gameTrackerX.material_fadeValue * fadeValue) >> 12;
					}
				}
			}
		}
		
		fadeValue -= 4096;
	}

	return fadeValue;
}

unsigned long INSTANCE_DefaultAnimCallback(struct _G2Anim_Type* anim, int sectionID, enum _G2AnimCallbackMsg_Enum message, long messageDataA, long messageDataB, struct _Instance* instance)
{
	struct _AnimSoundData_Type* soundData;
	int id;
	int vol;

	if (message == G2ANIM_MSG_PLAYEFFECT)
	{
		if (messageDataA == 0)
		{
			soundData = (struct _AnimSoundData_Type*)messageDataB;

			if (sectionID != 0)
			{
				vol = soundData->volume;

				if (vol >= 1000)
				{
					vol %= 1000;

					if (vol / 1000 != HUMAN_TypeOfHuman(instance))
					{
						return 0;
					}
				}
			
				SOUND_Play3dSound(&instance->position, soundData->sfxToneID, soundData->pitch, vol, soundData->minVolDistance);

				return messageDataA;
			}
		}
		else if (messageDataA == 1)
		{
			FX_StartInstanceEffect(instance, (struct ObjectEffect*)messageDataB, 0);
		}
		else
		{
			return messageDataA;
		}
	}

	return messageDataA;
}