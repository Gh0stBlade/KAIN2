#define _CRT_SECURE_NO_WARNINGS

#include "CORE.H"
#include "STREAM.H"
#include "Game/INSTANCE.H"
#include "GAMELOOP.H"
#include "DEBUG.H"
#include "STRMLOAD.H"
#include "RELMOD.H"
#include "OBTABLE.H"
#include "PSX/AADLIB.H"
#include "MEMPACK.H"
#include "VRAM.H"
#include "GAMELOOP.H"
#include "LIGHT3D.H"
#include "EVENT.H"
#include "PLAN/PLANAPI.H"
#include "SAVEINFO.H"
#include "STRMLOAD.H"
#include "SOUND.H"
#include "CAMERA.H"
#include "MATH3D.H"
#include "Game/FX.H"
#include "Game/COLLIDE.H"
#include "GLYPH.H"
#include "Game/DRAW.H"
#include "Game/GAMEPAD.H"
#include "Game/VM.H"

#include <stddef.h>

long CurrentWarpNumber;

struct WarpGateLoadInfo wgloadInfo;

struct WarpRoom WarpRoomArray[14];

struct STracker StreamTracker; // offset 0x800D1920

struct _TFace* MORPH_SavedFace;

struct Level* MORPH_SavedLevel;

short MORPH_Component[3];

short MORPH_Track[2];

int s_zval;

void STREAM_FillOutFileNames(char *baseAreaName, char *dramName, char *vramName, char *sfxName)
{ 
	char text[16];
	char *number;

	strcpy(text, baseAreaName);
	number = strpbrk(text, "0123456789");

	if (number != 0)
	{
		number[0] = 0;
	}

	if (dramName != NULL)
	{
		sprintf(dramName, "\\kain2\\area\\%s\\bin\\%s.drm", text, baseAreaName);
	}

	if (vramName != NULL)
	{
		sprintf(vramName, "\\kain2\\area\\%s\\bin\\%s.crm", text, baseAreaName);
	}

	if (sfxName != NULL)
	{
		sprintf(sfxName, "\\kain2\\area\\%s\\bin\\%s.snf", text, baseAreaName);
	}
}

void STREAM_AbortAreaLoad(char *baseAreaName)
{
	char vramName[80];
	STREAM_FillOutFileNames(baseAreaName, NULL, vramName, NULL);
	LOAD_AbortDirectoryChange(baseAreaName);
	LOAD_AbortFileLoad(vramName, (void*)VRAM_LoadReturn);
}

void STREAM_Init()
{
	int i;

	for (i = 0; i < 16; i++)
	{
		StreamTracker.StreamList[i].used = 0;
		StreamTracker.StreamList[i].flags = 0;
		StreamTracker.StreamList[i].StreamUnitID = 0;
	}
}

int FindObjectName(char *name)
{
	int i;
	struct _ObjectTracker *otr;

	otr = gameTrackerX.GlobalObjects;
	
	for(i = 0; i < 48; i++, otr++)
	{
		if (otr->objectStatus != 0)
		{
#if defined(UWP)
			if (_strcmpi(otr->name, name) == 0)
#else
			if (strcmpi(otr->name, name) == 0)
#endif
			{
				return i;
			}
		}
	}
	
	return -1;
}

struct _ObjectTracker* FindObjectInTracker(struct Object* object)
{
	int i;
	struct _ObjectTracker* otr;

	otr = gameTrackerX.GlobalObjects;
	
	for (i = 0; i < 48; i++, otr++)
	{
		if (otr->objectStatus != 0)
		{
			if (otr->object == object)
			{
				return otr;
			}
		}
	}

	return NULL;
}

struct _StreamUnit* FindStreamUnitFromLevel(struct Level* level)
{
	struct _StreamUnit* ret;
	long i;

	ret = NULL;

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 2 && StreamTracker.StreamList[i].level == level)
		{
			ret = &StreamTracker.StreamList[i];
			break;
		}
	}

	return ret;
}

void STREAM_LoadObjectReturn(void* loadData, void* data, void* data2)
{
	struct Object* object;
	struct _ObjectTracker* objectTracker;
	char objDsfxFileName[64];

	object = (struct Object*)loadData;
	objectTracker = (struct _ObjectTracker*)data;
	GetRCnt(0xF2000000);

	if ((object->oflags & 0x8000000) && object->relocList != NULL && object->relocModule != NULL)
	{
		RELMOD_InitModulePointers((intptr_t)object->relocModule, (int*)object->relocList);
	}

	STREAM_PackVRAMObject(objectTracker);
	OBTABLE_InitAnimPointers(objectTracker);
	OBTABLE_InitObjectWithID(object);

	if ((object->oflags2 & 0x800000))
	{
		sprintf(objDsfxFileName, "\\kain2\\sfx\\object\\%s\\%s.snf", objectTracker->name, objectTracker->name);

		object->sfxFileHandle = 0;

		if (LOAD_DoesFileExist(objDsfxFileName) != 0)
		{
			object->sfxFileHandle = aadLoadDynamicSfx(objectTracker->name, 0, 0);
		}
	}

	if (objectTracker->vramBlock == NULL)
	{
		objectTracker->objectStatus = 2;
	}
	else
	{
		objectTracker->objectStatus = 4;
	}
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_DumpMonster(struct _ObjectTracker *dumpee /*$s2*/)
void STREAM_DumpMonster(struct _ObjectTracker *dumpee)
{ // line 399, offset 0x8005882c
	/* begin block 1 */
		// Start line: 400
		// Start offset: 0x8005882C
		// Variables:
			struct Object *object; // $s1
			struct _Instance *instance; // $a1

		/* begin block 1.1 */
			// Start line: 407
			// Start offset: 0x80058858
			// Variables:
				struct _Instance *next; // $s0
		/* end block 1.1 */
		// End offset: 0x80058874
		// End Line: 414
	/* end block 1 */
	// End offset: 0x80058880
	// End Line: 417

	/* begin block 2 */
		// Start line: 806
	/* end block 2 */
	// End Line: 807

	/* begin block 3 */
		// Start line: 811
	/* end block 3 */
	// End Line: 812
				UNIMPLEMENTED();
}

int STREAM_InList(char *name, char **nameList)
{
	char** mon = nameList;

	while (*mon != NULL)
	{
#if defined(PSXPC_VERSION)
		if (_strcmpi(name, *mon) == 0)
#else
		if (strcmpi(name, *mon) == 0)
#endif
		{
			return 1;
		}

		mon++;
	}

	return 0;
}

int STREAM_IsSpecialMonster(char *name)
{
	static char* mon[6] = {
		"wallcr",
		"aluka",
		"ronin",
		"slaugh"
		"vwraith",
		NULL
	};

	return STREAM_InList(name, mon);
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_DumpSomeMonsters()
void STREAM_DumpSomeMonsters()
{ // line 475, offset 0x8005892c
	/* begin block 1 */
		// Start line: 476
		// Start offset: 0x8005892C
		// Variables:
			struct _ObjectTracker *otr; // $s1
			int i; // $s2
	/* end block 1 */
	// End offset: 0x800589A0
	// End Line: 491

	/* begin block 2 */
		// Start line: 984
	/* end block 2 */
	// End Line: 985
			UNIMPLEMENTED();
}

void STREAM_NoMonsters()
{
	gameTrackerX.gameFlags |= 0x4000000;

	STREAM_DumpSomeMonsters();
}

void STREAM_YesMonsters()
{
	gameTrackerX.gameFlags &= ~0x4000000;
}


int STREAM_IsMonster(char *name)
{ 
	static char* monnames[19] = {
		"skinner",
		"morlock",
		"vlgra",
		"vlgrb",
		"vlgrc",
		"hunter",
		"wrshp",
		"roninbss",
		"skinbos",
		"priests",
		"alukabss",
		"morboss",
		"soul",
		"wallcr",
		"aluka",
		"ronin",
		"sluagh",
		"vwraith",
		NULL,
	};
	
	return STREAM_InList(name, monnames);
}

int STREAM_TryAndDumpANonResidentObject()
{ 
	struct _ObjectTracker* otr;
	int i;

	otr = gameTrackerX.GlobalObjects;

	for (i = 0; i < 48; i++, otr++)
	{
		if (STREAM_TryAndDumpNonResident(otr) != 0)
		{
			return i;
		}
	}

	return -1;
}

int InsertGlobalObject(char *name, struct GameTracker *gameTracker)
{ 
	char string[64];
	char vramname[64];
	int i;
	struct _ObjectTracker *otr;
	
	if ((gameTrackerX.gameFlags & 0x4000000))
	{
		if (STREAM_IsSpecialMonster(name) != 0)
		{
			return -1;
		}
	}
	
	if ((gameTracker->debugFlags2 & 0x8000))
	{
		if (STREAM_IsMonster(name) != 0)
		{
			return -1;
		}
	}

	otr = gameTracker->GlobalObjects;

	for (i = 0; i < 48; i++, otr++)
	{
		if (otr->objectStatus != 0)
		{
#if defined(PSXPC_VERSION)
			if (_strcmpi(otr->name, name) == 0)
#else
			if (strcmpi(otr->name, name) == 0)
#endif
			{
				break;
			}
		}
	}

	if (i == 48)
	{
		otr = gameTracker->GlobalObjects;
		i = 0;

		do
		{
			if (otr->objectStatus == 0)
			{
				break;
			}
			i++;
			otr++;
		} while (i < 48);

		if (i == 48)
		{
			i = STREAM_TryAndDumpANonResidentObject();

			if (i == -1)
			{
				DEBUG_FatalError("The Object tracker is full MAX_OBJECTS=%d\n", 48);
			}
		}

		sprintf(string, "\\kain2\\object\\%s\\%s.drm", name, name);
		sprintf(vramname, "\\kain2\\object\\%s\\%s.crm", name, name);
		
		strcpy(otr->name, name);

		otr->objectStatus = 1;
		LOAD_NonBlockingBinaryLoad(string, (void*)STREAM_LoadObjectReturn, (void*)otr, NULL, (void**)&otr->object, 1);
		otr->numInUse = 0;
		otr->numObjectsUsing = 0;
	}

	return i;
}

struct _ObjectTracker * STREAM_GetObjectTracker(char *name)
{ 
	int i;

	i = InsertGlobalObject(name, &gameTrackerX);
	
	if (i != -1)
	{
		return &gameTrackerX.GlobalObjects[i];
	}

	return NULL;
}

void LoadLevelObjects(struct _StreamUnit *stream)
{
	int objlist_pos;
	char name[20];
	struct Level *level;
	int i;
	
	STREAM_NextLoadAsNormal();
	objlist_pos = 0;
	
	while (((unsigned char*)stream->level->objectNameList)[objlist_pos] != 255)
	{
		strcpy(name, (char*)stream->level->objectNameList + objlist_pos);
		InsertGlobalObject(name, &gameTrackerX);

		objlist_pos += 16;
	}

	level = stream->level;

	if (level->numIntros > 0)
	{
		for (i = 0; i < level->numIntros; i++)
		{
			if (FindObjectName(level->introList[i].name) != -1)
			{
				level->introList[i].flags &= 0xFFFFBFFF;
			}
			else
			{
				level->introList[i].flags |= 0x4000;
			}
		}
	}
}

long STREAM_IsAnInstanceUsingObject(struct Object* object)
{
	struct _Instance* instance;
	struct _Instance* next;
	long ret;
	
	instance = gameTrackerX.instanceList->first;
	ret = 0;

	while (instance != NULL)
	{
		next = instance->next;

		if (instance->object == object)
		{
			ret = 1;
			break;
		}

		instance = next;
	}

	return ret;
}

void STREAM_StreamLoadObjectAbort(void* loadData, void* data, void* data2)
{
	struct _ObjectTracker* objectTracker;

	objectTracker = (struct _ObjectTracker*)data;

	if (loadData != NULL)
	{
		MEMPACK_Free((char*)loadData);
	}

	objectTracker->objectStatus = 0;
}

void STREAM_DumpLoadingObjects()
{
	int i;
	struct _ObjectTracker* tracker;

	tracker = gameTrackerX.GlobalObjects;

	for (i = 0; i < 48; i++, tracker++)
	{
		if (tracker->objectStatus == 2)
		{
			STREAM_DumpObject(tracker);
		}
	}
}

void STREAM_DumpObject(struct _ObjectTracker *objectTracker)
{ 
	struct Object *object;
	char dramName[64];

	object = objectTracker->object;
	
	if (objectTracker->objectStatus == 1)
	{
		sprintf(dramName, "\\kain2\\object\\%s\\%s.drm", objectTracker->name, objectTracker->name);
		LOAD_AbortFileLoad(dramName, (void*)STREAM_StreamLoadObjectAbort);
	}
	else
	{
		if (object != NULL)
		{
			if (!(object->oflags & 0x2000000))
			{
				if (objectTracker->vramBlock != NULL)
				{
					VRAM_ClearVramBlock((struct _BlockVramEntry*)objectTracker->vramBlock);
				}

				if ((object->oflags2 & 0x800000) && object->sfxFileHandle != 0)
				{
					aadFreeDynamicSfx(object->sfxFileHandle);
				}
			
				OBTABLE_RemoveObjectEntry(object);
				MEMPACK_Free((char*)object);

				objectTracker->objectStatus = 0;
			}

			if (object == NULL)
			{
				objectTracker->objectStatus = 0;
			}
		}

		objectTracker->objectStatus = 0;
	}
}

int STREAM_IsObjectInAnyUnit(struct _ObjectTracker *tracker)
{
	int d;
	unsigned char *objlist;

	for (d = 0; d < 16; d++)
	{
		if (StreamTracker.StreamList[d].used == 2 && StreamTracker.StreamList[d].level == NULL)
		{
			objlist = (unsigned char*)StreamTracker.StreamList[d].level->objectNameList;

			while (objlist[0] != 255)
			{
#if defined(PSXPC_VERSION)
				if (_strcmpi(&tracker->name[0], (char*)objlist) == 0)
#else
				if (strcmpi(&tracker->name[0], (char*)objlist) == 0)
#endif
				{
					return 1;
				}

				objlist += 16;
			}
		}
	}

	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_RemoveAllObjectsNotInUse()
void STREAM_RemoveAllObjectsNotInUse()
{ // line 829, offset 0x80059000
	/* begin block 1 */
		// Start line: 830
		// Start offset: 0x80059000
		// Variables:
			int i; // $s3
			int abort; // $a3
			struct _ObjectTracker *tracker; // $s1
			struct _ObjectTracker *trackerList; // $s4

		/* begin block 1.1 */
			// Start line: 839
			// Start offset: 0x8005904C
			// Variables:
				struct Object *object; // $s2
		/* end block 1.1 */
		// End offset: 0x8005908C
		// End Line: 854

		/* begin block 1.2 */
			// Start line: 862
			// Start offset: 0x800590C8
			// Variables:
				int j; // $a0
		/* end block 1.2 */
		// End offset: 0x80059124
		// End Line: 875

		/* begin block 1.3 */
			// Start line: 883
			// Start offset: 0x8005915C
			// Variables:
				//int j; // $t0
				struct _ObjectTracker *otr; // $a3

			/* begin block 1.3.1 */
				// Start line: 887
				// Start offset: 0x80059188
				// Variables:
					int k; // $a0

				/* begin block 1.3.1.1 */
					// Start line: 896
					// Start offset: 0x800591AC
					// Variables:
						int l; // $a1
				/* end block 1.3.1.1 */
				// End offset: 0x800591F8
				// End Line: 903
			/* end block 1.3.1 */
			// End offset: 0x80059210
			// End Line: 905
		/* end block 1.3 */
		// End offset: 0x8005922C
		// End Line: 908
	/* end block 1 */
	// End offset: 0x80059298
	// End Line: 926

	/* begin block 2 */
		// Start line: 1753
	/* end block 2 */
	// End Line: 1754
						UNIMPLEMENTED();
}

void RemoveAllObjects(struct GameTracker* gameTracker)
{
	int i;
	struct _ObjectTracker* tracker;
	
	for (i = 0; i < 48; i++)
	{
		tracker = &gameTracker->GlobalObjects[i];

		if (tracker->objectStatus != 0)
		{
			STREAM_DumpObject(tracker);
		}
	}
}

struct Level* STREAM_GetLevelWithID(long id)
{ 
	struct Level* retLevel;
	long i;

	retLevel = NULL;

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 2)
		{
			if (StreamTracker.StreamList[i].StreamUnitID == id)
			{
				retLevel = StreamTracker.StreamList[i].level;
				return retLevel;
			}
		}
	}

	return retLevel;
}

struct _StreamUnit* STREAM_GetStreamUnitWithID(long id)//Matching - 94.50%
{
	struct _StreamUnit* retUnit;
	long i;

	retUnit = NULL;
	
	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 2)
		{
			if (StreamTracker.StreamList[i].StreamUnitID == id)
			{
				retUnit = &StreamTracker.StreamList[i];
				break;
			}
		}
	}

	return retUnit;
}


// autogenerated function stub: 
// struct _StreamUnit * /*$ra*/ STREAM_GetStreamUnitWithName(char *name /*$s4*/)
struct _StreamUnit * STREAM_GetStreamUnitWithName(char *name)
{ // line 981, offset 0x800593c0
	/* begin block 1 */
		// Start line: 982
		// Start offset: 0x800593C0
		// Variables:
			struct _StreamUnit *retUnit; // $s3
			long i; // $s2
	/* end block 1 */
	// End offset: 0x8005942C
	// End Line: 995

	/* begin block 2 */
		// Start line: 2208
	/* end block 2 */
	// End Line: 2209
			UNIMPLEMENTED();
	return null;
}

void STREAM_CalculateWaterLevel(struct Level* level)//Matching - 100%
{
	struct _Terrain* terrain;
	int i;
	struct _TFace* tface;
	long waterZLevel;

	waterZLevel = -32767;

	if (level->waterZLevel == 0)
	{
		if ((level->unitFlags & 0x1))
		{
			level->waterZLevel = 32767;
		}
		else
		{
			terrain = level->terrain;

			tface = (struct _TFace*)terrain->faceList;

			for (i = terrain->numFaces; i > 0; i--, tface++)
			{
				if ((tface->attr & 8) != 0)
				{
					if (terrain->vertexList[tface->face.v0].vertex.z == terrain->vertexList[tface->face.v1].vertex.z &&
						terrain->vertexList[tface->face.v0].vertex.z == terrain->vertexList[tface->face.v2].vertex.z)
					{
						if (waterZLevel == -32767)
						{
							waterZLevel = terrain->vertexList[tface->face.v0].vertex.z;
						}
						else if (waterZLevel != terrain->vertexList[tface->face.v0].vertex.z)
						{
							break;
						}
					}

				}
			}
			if (waterZLevel == -32767)
			{
				level->waterZLevel = -32767;
			}
			else
			{
				level->waterZLevel = waterZLevel + level->terrain->BSPTreeArray[0].globalOffset.z;
			}
		}
	}
}

int STREAM_IsMorphInProgress()
{
	return 0 < (gameTrackerX.gameData.asmData.MorphTime ^ 1000);
}


long STREAM_GetWaterZLevel(struct Level* level, struct _Instance* instance)//Matching - 99.69%
{
	int waterZLevel;

	if ((instance->flags2 & 0x8000000) != 0)
	{
		if (!(instance->object->oflags2 & 0x2000000) && gameTrackerX.gameData.asmData.MorphTime != 1000)
		{
			waterZLevel = level->waterZLevel;
		}
		else
		{
			waterZLevel = -32767;
		}
	}
	else
	{
		if (!(instance->object->oflags2 & 0x2000000) && gameTrackerX.gameData.asmData.MorphTime != 1000)
		{
			waterZLevel = -32767;
		}
		else
		{
			waterZLevel = level->waterZLevel;
		}
	}
	return waterZLevel;
}

void STREAM_SetMainFog(struct _StreamUnit *streamUnit)
{ 
	struct Level *level;

	level = streamUnit->level;

	if (gameTrackerX.gameData.asmData.MorphType != 0)
	{
		streamUnit->UnitFogNear = level->spectralFogNear;
		streamUnit->UnitFogFar = level->spectralFogFar;
	}
	else
	{
		streamUnit->UnitFogNear = level->holdFogNear;
		streamUnit->UnitFogFar = level->holdFogFar;
	}
}

void STREAM_SetStreamFog(struct _StreamUnit* streamUnit, short fogNear, short fogFar)//Matching - 99.72%
{
	short unitFogFar; 
	int unitFogHold;

	unitFogFar = FindStreamUnitFromLevel(gameTrackerX.level)->UnitFogFar;

	if (fogFar < unitFogFar)
	{
		unitFogFar = fogFar;
	}

	unitFogHold = unitFogFar - 2000;

	streamUnit->TargetFogFar = unitFogFar;
	streamUnit->UnitFogFar = unitFogFar;

	if (fogNear < unitFogHold)
	{
		unitFogHold = fogNear;
	}
	
	streamUnit->TargetFogNear = unitFogHold;
	streamUnit->UnitFogNear = unitFogHold;
}

void STREAM_ConnectStream(struct _StreamUnit* streamUnit)
{
	struct _StreamUnit* mainUnit;
	struct StreamUnitPortal* streamPortal;
	int numportals;
	struct StreamUnitPortal* streamPortal2;
	int numportals2;
	int i;
	int j;
	char text[16];
	char* commapos;
	int signalID;
	struct _StreamUnit* connectStream;
	struct _SVector offset;
	long d;
	long hookedUp;

	WARPGATE_UpdateAddToArray(streamUnit);

	if (gameTrackerX.StreamUnitID != streamUnit->StreamUnitID)
	{
		numportals2 = ((long*)streamUnit->level->terrain->StreamUnits)[0];
		streamPortal2 = (struct StreamUnitPortal*)((long*)streamUnit->level->terrain->StreamUnits + 1);

		mainUnit = STREAM_GetStreamUnitWithID(gameTrackerX.StreamUnitID);

		for (j = 0; j < numportals2; j++)
		{
			strcpy(text, streamPortal2[j].tolevelname);
			commapos = strchr(text, ',');
			signalID = 0;

			if (commapos != 0)
			{
				commapos[0] = 0;
				signalID = atoi(&commapos[1]);
			}

			connectStream = STREAM_GetStreamUnitWithID(streamPortal2[j].streamID);

			if (strcmpi(text, "warpgate") == 0 && WARPGATE_IsUnitWarpRoom(mainUnit))
			{
				connectStream = mainUnit;
			}

			streamPortal2[j].toStreamUnit = connectStream;

			if (connectStream != NULL && connectStream == mainUnit)
			{
				numportals = ((long*)mainUnit->level->terrain->StreamUnits)[0];
				streamPortal = (struct StreamUnitPortal*)((long*)mainUnit->level->terrain->StreamUnits + 1);

				for (i = 0; i < numportals; i++, streamPortal++)
				{
					if (signalID == streamPortal[i].MSignalID)
					{
						offset.x = streamPortal[i].minx - streamPortal2[j].minx;
						offset.y = streamPortal[i].miny - streamPortal2[j].miny;
						offset.z = streamPortal[i].minz - streamPortal2[j].minz;

						RelocateLevel(streamUnit->level, &offset);
					}
				}
			}
		}

		connectStream = &StreamTracker.StreamList[0];
		
		for (d = 0; d < 16; d++, connectStream++)
		{
			if (StreamTracker.StreamList[d].used == 2 && connectStream != streamUnit)
			{
				numportals2 = ((long*)StreamTracker.StreamList[d].level->terrain->StreamUnits)[0];
				streamPortal2 = (struct StreamUnitPortal*)((long*)StreamTracker.StreamList[d].level->terrain->StreamUnits + 1);

				for (j = 0; j < numportals2; j++)
				{
					strcpy(text, streamPortal2->tolevelname);
					
					commapos = strchr(text, ',');

					hookedUp = 0;

					if (commapos != NULL)
					{
						commapos[0] = 0;

						signalID = atoi(&commapos[1]);
					}

					if (streamPortal2[j].streamID == streamUnit->StreamUnitID)
					{
						streamPortal2[j].toStreamUnit = streamUnit;
						hookedUp = 1;
					}
					else
					{
						if (strcmpi(text, "warpgate") == 0 && WARPGATE_IsUnitWarpRoom(streamUnit))
						{
							streamPortal2[j].toStreamUnit = streamUnit;
							hookedUp = 1;
						}
					}

					if (hookedUp == 1 && connectStream == mainUnit)
					{
						numportals = ((long*)streamUnit->level->terrain->StreamUnits)[0];

						streamPortal = (struct StreamUnitPortal*)((long*)streamUnit->level->terrain->StreamUnits + 1);

						for (i = 0; i < numportals; i++)
						{
							if (signalID == streamPortal[i].MSignalID)
							{
								offset.x = streamPortal2[j].minx - streamPortal[i].minx;
								offset.y = streamPortal2[j].miny - streamPortal[i].miny;
								offset.z = streamPortal2[j].minz - streamPortal[i].minz;

								RelocateLevel(streamUnit->level, &offset);
								break;
							}
						}
					}
				}
			}
		}

		for(i = 0; i < streamUnit->level->numIntros; i++)
		{
			if (strcmpi(streamUnit->level->introList[i].name, "raziel") == 0)
			{
				streamUnit->level->introList[i].flags |= 0x8;
				break;
			}
		}
	}
}

void STREAM_StreamLoadLevelAbort(void* loadData, void* data, void* data2)
{
	struct _StreamUnit* streamUnit;

	streamUnit = (struct _StreamUnit*)data2;

	if (loadData != NULL)
	{
		MEMPACK_Free((char*)loadData);
	}

	streamUnit->level = NULL;
	streamUnit->used = 0;
	streamUnit->flags = 0;
}

void STREAM_DoObjectLoadAndDump(struct _StreamUnit* streamUnit)
{
	int i;

	i = 0;
	do
	{
		if (StreamTracker.StreamList[i].used == 1)
		{
			break;
		}

	} while (i++ < 16);

	STREAM_RemoveAllObjectsNotInUse();
}

void STREAM_FinishLoad(struct _StreamUnit *streamUnit)
{
	struct Level *level;
	char sfxName[80];

	STREAM_FillOutFileNames(streamUnit->baseAreaName, NULL, NULL, sfxName);

	level = streamUnit->level;
	level->morphLastStep = -1;
	
	streamUnit->sfxFileHandle = 0;
	
	if (LOAD_DoesFileExist(sfxName) != 0)
	{
		streamUnit->sfxFileHandle = aadLoadDynamicSfx(streamUnit->baseAreaName, streamUnit->StreamUnitID, 1);
	}
	
	LoadLevelObjects(streamUnit);
	
	streamUnit->FogColor = (level->cpad1 << 24) | (level->backColorB << 16) | (level->backColorG << 8) | (level->backColorR);
	streamUnit->TargetFogFar = level->fogFar;
	streamUnit->TargetFogNear = level->fogNear;

	LIGHT_CalcDQPTable(level);
	
	STREAM_CalculateWaterLevel(level);

	if (gameTrackerX.gameData.asmData.MorphType == 1)
	{
		MORPH_UpdateNormals(level);
	}

	STREAM_ConnectStream(streamUnit);

	streamUnit->used = 2;

	STREAM_DoObjectLoadAndDump(streamUnit);

	EVENT_LoadEventsForLevel(streamUnit->StreamUnitID, level);
	
	PLANAPI_InitPlanMkrList(streamUnit);

	if (level->startUnitLoadedSignal != NULL)
	{
		level->startUnitLoadedSignal->flags |= 0x1;
		
		SIGNAL_HandleSignal(gameTrackerX.playerInstance, &level->startUnitLoadedSignal->signalList[0], 0);
		
		EVENT_AddSignalToReset(level->startUnitLoadedSignal);
	}

	SAVE_IntroForStreamID(streamUnit);
	SAVE_UpdateLevelWithSave(streamUnit);
	
	EVENT_AddStreamToInstanceList(streamUnit);
	
	WARPGATE_FixUnit(streamUnit);
}

void STREAM_LoadLevelReturn(void *loadData, void *data, void *data2)
{
	GetRCnt(0xF2000000);

	((struct _StreamUnit*)data2)->StreamUnitID = ((struct Level*)loadData)->streamUnitID;

	gameTrackerX.level = (struct Level*)loadData;
	gameTrackerX.StreamUnitID = ((struct Level*)loadData)->streamUnitID;
	
	STREAM_SetMainFog(((struct _StreamUnit*)data2));
	STREAM_FinishLoad(((struct _StreamUnit*)data2));
}

void STREAM_StreamLoadLevelReturn(void* loadData, void* data, void* data2)
{
	struct Level* level;
	struct _StreamUnit* streamUnit;

	level = (struct Level*)loadData;
	streamUnit = (struct _StreamUnit*)data2;

	GetRCnt(0xF2000000);

	streamUnit->StreamUnitID = level->streamUnitID;
	
	if (streamUnit->used == 3)
	{
		streamUnit->used = 0;
		streamUnit->flags = 0;

		MEMPACK_Free((char*)streamUnit->level);
	}
	else
	{
		if (gameTrackerX.gameData.asmData.MorphType != 0)
		{
			STREAM_SetStreamFog(streamUnit, level->spectralFogNear, level->spectralFogFar);
		}
		else
		{
			STREAM_SetStreamFog(streamUnit, level->holdFogNear, level->holdFogFar);
		}

		STREAM_FinishLoad(streamUnit);

		if (gameTrackerX.playerInstance != NULL && level->streamUnitID == gameTrackerX.playerInstance->currentStreamUnitID)
		{
			strcpy(gameTrackerX.baseAreaName, level->worldName);

			STREAM_SetMainFog(streamUnit);

			gameTrackerX.level = level;
			gameTrackerX.StreamUnitID = level->streamUnitID;
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_UpdateLevelPointer(struct Level *oldLevel /*$a0*/, struct Level *newLevel /*$a1*/, long sizeOfLevel /*$a2*/)
void STREAM_UpdateLevelPointer(struct Level *oldLevel, struct Level *newLevel, long sizeOfLevel)
{ // line 1623, offset 0x80059e18
	/* begin block 1 */
		// Start line: 1624
		// Start offset: 0x80059E18
		// Variables:
			long i; // $t0
			long offset; // $t1
			struct GameTracker *gameTracker; // $v0

		/* begin block 1.1 */
			// Start line: 1652
			// Start offset: 0x80059E7C
			// Variables:
				struct _Instance *instance; // $a3
		/* end block 1.1 */
		// End offset: 0x8005A00C
		// End Line: 1692
	/* end block 1 */
	// End offset: 0x8005A0F0
	// End Line: 1714

	/* begin block 2 */
		// Start line: 3246
	/* end block 2 */
	// End Line: 3247
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _StreamUnit * /*$ra*/ STREAM_WhichUnitPointerIsIn(void *pointer /*$s3*/)
struct _StreamUnit * STREAM_WhichUnitPointerIsIn(void *pointer)
{ // line 1719, offset 0x8005a108
	/* begin block 1 */
		// Start line: 1720
		// Start offset: 0x8005A108
		// Variables:
			int i; // $s2
			int size; // $v1
			struct Level *level; // $s0
	/* end block 1 */
	// End offset: 0x8005A194
	// End Line: 1740

	/* begin block 2 */
		// Start line: 3981
	/* end block 2 */
	// End Line: 3982
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_UpdateObjectPointer(struct Object *oldObject /*$s2*/, struct Object *newObject /*$s3*/, long sizeOfObject /*$s4*/)
void STREAM_UpdateObjectPointer(struct Object *oldObject, struct Object *newObject, long sizeOfObject)
{ // line 1742, offset 0x8005a1b4
	/* begin block 1 */
		// Start line: 1743
		// Start offset: 0x8005A1B4
		// Variables:
			long i; // $a3
			long d; // $a1
			struct GameTracker *gameTracker; // $s0
			long offset; // $s1
			struct _ObjectTracker *otr; // $t0

		/* begin block 1.1 */
			// Start line: 1763
			// Start offset: 0x8005A208
			// Variables:
				int j; // $a1
				struct Object *object; // $a2
		/* end block 1.1 */
		// End offset: 0x8005A294
		// End Line: 1773

		/* begin block 1.2 */
			// Start line: 1791
			// Start offset: 0x8005A2F0
			// Variables:
				struct _Instance *instance; // $s0
		/* end block 1.2 */
		// End offset: 0x8005A408
		// End Line: 1820
	/* end block 1 */
	// End offset: 0x8005A434
	// End Line: 1828

	/* begin block 2 */
		// Start line: 4049
	/* end block 2 */
	// End Line: 4050
				UNIMPLEMENTED();
}

void STREAM_UpdateInstanceCollisionInfo(struct _HModel* oldHModel, struct _HModel* newHModel)
{
	struct _Instance* instance;

	instance = gameTrackerX.instanceList->first;
	
	while (instance != NULL)
	{
		if (instance->hModelList == oldHModel)
		{
			instance->hModelList = newHModel;
		}

		instance = instance->next;
	}
}

void STREAM_LoadMainVram(struct GameTracker *gameTracker, char *baseAreaName, struct _StreamUnit *streamUnit)
{
	char dramName[80];
	char vramName[80];
	struct VramBuffer *vramBuffer;
	struct Level* level;

	level = streamUnit->level;

	STREAM_FillOutFileNames(gameTrackerX.baseAreaName, dramName, vramName, NULL);

	vramBuffer = (struct VramBuffer*)MEMPACK_Malloc((level->vramSize.w << 1) + 20, 0x23);

	vramBuffer->lineOverFlow = (short*)(vramBuffer + 1);
	vramBuffer->flags = 0;
	vramBuffer->x = (level->vramSize.x) + SCREEN_WIDTH;
	vramBuffer->y = level->vramSize.y;
	vramBuffer->w = level->vramSize.w;
	vramBuffer->h = level->vramSize.h;

	M_TrackClutUpdate = 0;

	vramBuffer->yOffset = 0;
	vramBuffer->lengthOfLeftOverData = 0;
	
	LOAD_NonBlockingBufferedLoad(vramName, (void*)VRAM_TransferBufferToVram, vramBuffer, NULL);
}

void STREAM_MoveIntoNewStreamUnit()
{
	gameTrackerX.playerInstance->cachedTFace = -1;
	gameTrackerX.playerInstance->cachedTFaceLevel = NULL;
	gameTrackerX.playerInstance->currentStreamUnitID = gameTrackerX.moveRazielToStreamID;

	INSTANCE_UpdateFamilyStreamUnitID(gameTrackerX.playerInstance);

	GAMELOOP_StreamLevelLoadAndInit(gameTrackerX.baseAreaName, &gameTrackerX, gameTrackerX.toSignal, gameTrackerX.fromSignal);

	gameTrackerX.SwitchToNewStreamUnit = 0;

	if (gameTrackerX.SwitchToNewWarpIndex != -1)
	{
		SndPlayVolPan(388, 127, 64, 0);
		CurrentWarpNumber = gameTrackerX.SwitchToNewWarpIndex;
	}
}

struct _StreamUnit * STREAM_LoadLevel(char *baseAreaName, struct StreamUnitPortal *streamPortal, int loadnext)
{
	int i;
	long streamID;
	struct _StreamUnit *streamUnit;
	struct Level *level;
	char dramName[80];

	streamID = -1;

	if (streamPortal != NULL)
	{
		streamID = streamPortal->streamID;
	}

	for (i = 0; i < 16; i++)
	{
		streamUnit = &StreamTracker.StreamList[i];
		
		if (streamUnit->used != 0)
		{
#if defined(PSXPC_VERSION)
			if (_strcmpi(streamUnit->baseAreaName, baseAreaName) == 0)
#else
			if (strcmpi(streamUnit->baseAreaName, baseAreaName) == 0)
#endif
			{
				if (streamUnit->used != 3)
				{
					if (streamUnit->used != 1)
					{
						streamUnit->FrameCount = 0;
						
						if (streamPortal == NULL)
						{
							strcpy(gameTrackerX.baseAreaName, baseAreaName);
							
							STREAM_SetMainFog(streamUnit);
							
							gameTrackerX.StreamUnitID = streamUnit->StreamUnitID;
							gameTrackerX.level = streamUnit->level;
						}
						else
						{
							level = streamUnit->level;
				
							STREAM_ConnectStream(streamUnit);

							if (gameTrackerX.gameData.asmData.MorphType != 0)
							{
								STREAM_SetStreamFog(streamUnit, level->spectralFogNear, level->spectralFogFar);
							}
							else
							{
								STREAM_SetStreamFog(streamUnit, level->holdFogNear, level->holdFogFar);
							}
						}
					}
					break;
				}
				else
				{
					streamUnit->used = 1;
				}
			}
		}
	}

	if (i == 16)
	{
		for (i = 0; i < 16; i++)
		{
			streamUnit = &StreamTracker.StreamList[i];

			if (streamUnit->used == 0)
			{
				STREAM_FillOutFileNames(baseAreaName, dramName, NULL, NULL);
				
				streamUnit->used = 1;
				
				strcpy(streamUnit->baseAreaName, baseAreaName);

				streamUnit->StreamUnitID = streamID;
				streamUnit->FrameCount = 0;
				streamUnit->flags = 0;

				if (streamPortal == NULL)
				{
					strcpy(gameTrackerX.baseAreaName, baseAreaName);

					gameTrackerX.StreamUnitID = streamUnit->StreamUnitID;

					LOAD_NonBlockingBinaryLoad(dramName, (void*)STREAM_LoadLevelReturn, NULL, streamUnit, (void**)&streamUnit->level, 2);

					break;
				}
				else
				{
					streamPortal->toStreamUnit = NULL;

					LOAD_NonBlockingBinaryLoad(dramName, (void*)STREAM_StreamLoadLevelReturn, NULL, streamUnit, (void**)&streamUnit->level, 2);

					break;
				}
			}
		}
	}
	
	return streamUnit;
}


// autogenerated function stub: 
// void /*$ra*/ RemoveIntroducedLights(struct Level *level /*$s2*/)
void RemoveIntroducedLights(struct Level *level)
{ // line 2144, offset 0x8005a7f8
	/* begin block 1 */
		// Start line: 2145
		// Start offset: 0x8005A7F8
		// Variables:
			int i; // $s0
	/* end block 1 */
	// End offset: 0x8005A8C4
	// End Line: 2166

	/* begin block 2 */
		// Start line: 5067
	/* end block 2 */
	// End Line: 5068
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_RemoveInstancesWithIDInInstanceList(struct _InstanceList *list /*$s4*/, long id /*$s2*/, struct Level *level /*$s3*/)
void STREAM_RemoveInstancesWithIDInInstanceList(struct _InstanceList *list, long id, struct Level *level)
{ // line 2168, offset 0x8005a8dc
	/* begin block 1 */
		// Start line: 2169
		// Start offset: 0x8005A8DC
		// Variables:
			struct _Instance *instance; // $s0
			struct _Instance *next; // $s1
	/* end block 1 */
	// End offset: 0x8005A968
	// End Line: 2197

	/* begin block 2 */
		// Start line: 5126
	/* end block 2 */
	// End Line: 5127
			UNIMPLEMENTED();
}

void STREAM_MarkUnitNeeded(long streamID)
{
	int i;
	
	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used != 0)
		{
			if (StreamTracker.StreamList[i].StreamUnitID == streamID)
			{
				StreamTracker.StreamList[i].FrameCount = gameTrackerX.displayFrameCount;
				return;
			}
		}
	}
}

void STREAM_DumpUnit(struct _StreamUnit* streamUnit, long doSave)
{
	int i;
	int j;
	int numportals;
	char dramName[80];
	struct _SFXMkr* sfxMkr;

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 2)
		{
			numportals = ((int*)StreamTracker.StreamList[i].level->terrain->StreamUnits)[0];

			for (j = 0; j < numportals; j++)
			{
				if (((struct StreamUnitPortal*)((int*)StreamTracker.StreamList[i].level->terrain->StreamUnits + 1))[j].toStreamUnit == streamUnit)
				{
					((struct StreamUnitPortal*)((int*)StreamTracker.StreamList[i].level->terrain->StreamUnits + 1))[j].toStreamUnit = NULL;
				}
			}
		}
	}
	
	if (streamUnit->used == 1 || streamUnit->used == 3)
	{
		STREAM_FillOutFileNames(streamUnit->baseAreaName, dramName, NULL, NULL);

		LOAD_AbortFileLoad(dramName, (void*)&STREAM_StreamLoadLevelAbort);

		streamUnit->used = 0;
	}

	if (WARPGATE_IsUnitWarpRoom(streamUnit))
	{
		WARPGATE_RemoveFromArray(streamUnit);
	}
	
	EVENT_RemoveStreamToInstanceList(streamUnit);

	for (i = 0; i < streamUnit->level->NumberOfSFXMarkers; i++)
	{
		sfxMkr = &streamUnit->level->SFXMarkerList[i];

		SOUND_EndInstanceSounds(sfxMkr->soundData, sfxMkr->sfxTbl);
	}
	
	if (streamUnit->sfxFileHandle != 0)
	{
		aadFreeDynamicSfx(streamUnit->sfxFileHandle);
	}

	PLANAPI_DeleteNodeFromPoolByUnit(streamUnit->StreamUnitID);

	STREAM_RemoveInstancesWithIDInInstanceList(gameTrackerX.instanceList, streamUnit->StreamUnitID, streamUnit->level);

	if (doSave != 0)
	{
		EVENT_SaveEventsFromLevel(streamUnit->StreamUnitID, streamUnit->level);
		SAVE_CreatedSavedLevel(streamUnit->StreamUnitID, streamUnit->level);
	}

	MEMPACK_Free((char*)streamUnit->level);

	streamUnit->level = NULL;
	streamUnit->used = 0;
	streamUnit->flags = 0;
}

void STREAM_DumpAllUnitsNotNeeded()
{
	int i;

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used != 0 && StreamTracker.StreamList[i].FrameCount != gameTrackerX.displayFrameCount)
		{
			STREAM_DumpUnit(&StreamTracker.StreamList[i], 1);
		}
	}
}

void STREAM_DumpAllLevels(long IDNoRemove, int DoSave)
{
	int i;

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used != 0 && StreamTracker.StreamList[i].StreamUnitID != IDNoRemove)
		{
			STREAM_DumpUnit(&StreamTracker.StreamList[i], DoSave);
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_LoadCurrentWarpRoom(struct StreamUnitPortal *streamPortal /*$s1*/, struct _StreamUnit *mainStreamUnit /*$a1*/)
void STREAM_LoadCurrentWarpRoom(struct StreamUnitPortal *streamPortal, struct _StreamUnit *mainStreamUnit)
{ // line 2343, offset 0x8005ac9c
	/* begin block 1 */
		// Start line: 5533
	/* end block 1 */
	// End Line: 5534

	/* begin block 2 */
		// Start line: 5534
	/* end block 2 */
	// End Line: 5535
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_RelocateLoadedWarpRooms(struct _StreamUnit *mainUnit /*$s4*/, struct StreamUnitPortal *streamPortal /*$s5*/)
void WARPGATE_RelocateLoadedWarpRooms(struct _StreamUnit *mainUnit, struct StreamUnitPortal *streamPortal)
{ // line 2360, offset 0x8005ad58
	/* begin block 1 */
		// Start line: 2361
		// Start offset: 0x8005AD58
		// Variables:
			int i; // $s2
	/* end block 1 */
	// End offset: 0x8005ADDC
	// End Line: 2374

	/* begin block 2 */
		// Start line: 5570
	/* end block 2 */
	// End Line: 5571
			UNIMPLEMENTED();
}

long WARPGATE_GetWarpRoomIndex(char* name)
{
	int i;
	
	for (i = 0; i < 14; i++)
	{
		if (strcmpi(WarpRoomArray[i].name, name) == 0)
		{
			return i;
		}
	}

	return -1;
}

void WARPGATE_UpdateAddToArray(struct _StreamUnit* streamUnit)
{
	int i;

	i = WARPGATE_GetWarpRoomIndex(streamUnit->baseAreaName);

	if (i != -1)
	{
		WarpRoomArray[i].streamUnit = streamUnit;
	}
}

void WARPGATE_RemoveFromArray(struct _StreamUnit* streamUnit)
{
	if (WARPGATE_GetWarpRoomIndex(streamUnit->baseAreaName) == -1)
	{
		CurrentWarpNumber = 0;
	}
}

void WARPGATE_Init()
{ 
	int n;
	
	wgloadInfo.fadeValue = 4096;
	wgloadInfo.warpgate_in_use = 0;
	wgloadInfo.loading = 0;
	wgloadInfo.blocked = 0;
	wgloadInfo.curTime = 0;
	wgloadInfo.maxTime = 61440;
	wgloadInfo.warpFaceInstance = NULL;

	CurrentWarpNumber = 0;

	for (n = 13; n >= 0; n--)
	{
		WarpRoomArray[n].streamUnit = NULL;
	}
}

void WARPGATE_StartUsingWarpgate()
{
	if (wgloadInfo.warpgate_in_use == 0)
	{
		SndPlayVolPan(367, 127, 64, 0);
	}

	wgloadInfo.warpgate_in_use = 1;
}

void WARPGATE_EndUsingWarpgate()
{
	if (wgloadInfo.warpgate_in_use == 1)
	{
		SndPlayVolPan(386, 127, 64, 0);
	}

	wgloadInfo.warpgate_in_use = 0;
}

int WARPGATE_IsWarpgateInUse()
{
	return wgloadInfo.warpgate_in_use;
}

int WARPGATE_IsWarpgateActive()
{ 
	return 0 < wgloadInfo.loading;
}

int WARPGATE_IsWarpgateUsable()
{
	return ((short)wgloadInfo.loading ^ 4) < 1;
}

int WARPGATE_IsWarpgateReady()
{
	return (wgloadInfo.loading ^ 4) < 1;
}

int WARPGATE_IsWarpgateSpectral()
{
	return strcmpi(WarpRoomArray[CurrentWarpNumber].name, "under3") < 1;
}


// autogenerated function stub: 
// int /*$ra*/ WARPGATE_IsObjectOnWarpSide(struct _Instance *instance /*$a0*/)
int WARPGATE_IsObjectOnWarpSide(struct _Instance *instance)
{ // line 2481, offset 0x8005b010
	/* begin block 1 */
		// Start line: 2483
		// Start offset: 0x8005B010
		// Variables:
			int side; // $a0
	/* end block 1 */
	// End offset: 0x8005B06C
	// End Line: 2502

	/* begin block 2 */
		// Start line: 5854
	/* end block 2 */
	// End Line: 5855

	/* begin block 3 */
		// Start line: 5855
	/* end block 3 */
	// End Line: 5856

	/* begin block 4 */
		// Start line: 5856
	/* end block 4 */
	// End Line: 5857
			UNIMPLEMENTED();
	return 0;
}

void WARPGATE_IsItActive(struct _StreamUnit *streamUnit)
{
	struct Level *level;
	int d;

	level = streamUnit->level;
	streamUnit->flags |= 0x1;

	if (level->PuzzleInstances != NULL && level->PuzzleInstances->numPuzzles > 0)
	{
		for (d = 0; d < level->PuzzleInstances->numPuzzles; d++)
		{
			if (level->PuzzleInstances->eventInstances[d]->eventNumber == 1)
			{
				if ((gameTrackerX.streamFlags & 0x400000))
				{
					level->PuzzleInstances->eventInstances[d]->eventVariables[0] = level->PuzzleInstances->eventInstances[d]->eventNumber;
				}

				if (level->PuzzleInstances->eventInstances[d]->eventVariables[0] != level->PuzzleInstances->eventInstances[d]->eventNumber)
				{
					return;
				}

				streamUnit->flags |= 0x8;
				return;
			}
		}
	}

	return;
}

long WARPGATE_IsUnitWarpRoom(struct _StreamUnit *streamUnit)
{
	struct Level *level;
	long isWarpRoom;
	struct StreamUnitPortal *streamPortal;
	long numPortals;
	long d;

	level = streamUnit->level;
	
	isWarpRoom = 0;
	
	numPortals = ((long*)level->terrain->StreamUnits)[0];
	
	streamPortal = (struct StreamUnitPortal*)((long*)level->terrain->StreamUnits + 1);

	if (numPortals > 0)
	{
		for (d = 0; d < numPortals; d++)
		{
			if ((streamPortal[d].flags & 0x1))
			{
				isWarpRoom = 1;
			}
		}
	}

	return isWarpRoom;
}

void WARPGATE_FixUnit(struct _StreamUnit *streamUnit)
{ 
	if (WARPGATE_IsUnitWarpRoom(streamUnit) != 0)
	{
		WARPGATE_IsItActive(streamUnit);
	}
}

void STREAM_MarkWarpUnitsNeeded()
{
	int i;

	for(i = 0; i < 16; i++)
	{
		if ((StreamTracker.StreamList[i].flags & 0x1))
		{
			StreamTracker.StreamList[i].FrameCount = gameTrackerX.displayFrameCount;
		}
	}
}

long WARPGATE_IncrementIndex()
{
	long result;
	
	result = 1;

	if (wgloadInfo.loading == 4)
	{
		SndPlayVolPan(387, 127, 64, 0);

		wgloadInfo.loading = 1;
		wgloadInfo.curTime = 0;
		wgloadInfo.warpFaceInstance->fadeValue = 4096;
		wgloadInfo.warpFaceInstance = NULL;

		WarpRoomArray[CurrentWarpNumber].streamUnit->StreamUnitID = 0;

		CurrentWarpNumber = (CurrentWarpNumber + 1) % 14;

		if (strcmpi(gameTrackerX.baseAreaName, WarpRoomArray->name) == 0)
		{
			CurrentWarpNumber = (CurrentWarpNumber + 1) % 14;
		}

		hud_warp_arrow_flash = -8192;
	}
	
	return result;
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_CalcWarpFade(int timeInc /*$a0*/)
void WARPGATE_CalcWarpFade(int timeInc)
{ // line 2615, offset 0x8005b320
	/* begin block 1 */
		// Start line: 6175
	/* end block 1 */
	// End Line: 6176

	/* begin block 2 */
		// Start line: 6176
	/* end block 2 */
	// End Line: 6177
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// long /*$ra*/ WARPGATE_DecrementIndex()
long WARPGATE_DecrementIndex()
{ // line 2624, offset 0x8005b390
	/* begin block 1 */
		// Start line: 2625
		// Start offset: 0x8005B390
		// Variables:
			long result; // $s0
	/* end block 1 */
	// End offset: 0x8005B454
	// End Line: 2652

	/* begin block 2 */
		// Start line: 6194
	/* end block 2 */
	// End Line: 6195
			UNIMPLEMENTED();
	return 0;
}

void PreloadAllConnectedUnits(struct _StreamUnit* streamUnit, struct _SVector* offset)
{
	int i;
	char text[16];
	int numportals;
	char* commapos;
	struct StreamUnitPortal* stream;

	gameTrackerX.displayFrameCount += 1;

	numportals = ((long*)streamUnit->level->terrain->StreamUnits)[0];

	for (i = 0; i < numportals; i++)
	{
		stream = (struct StreamUnitPortal*)((long*)streamUnit->level->terrain->StreamUnits + 1) + i;

		strcpy(text, stream->tolevelname);

		commapos = strchr(text, ',');

		if (commapos != NULL)
		{
			commapos[0] = 0;
		}
		
		if (strcmpi(text, "warpgate") == 0)
		{
			STREAM_MarkWarpUnitsNeeded();
		}
		else
		{
			STREAM_MarkUnitNeeded(stream->streamID);
		}
	}

	STREAM_MarkUnitNeeded(streamUnit->StreamUnitID);

	STREAM_DumpAllUnitsNotNeeded();

	RelocateLevelWithInstances(streamUnit->level, offset);

	MEMPACK_DoGarbageCollection();

	numportals = ((long*)streamUnit->level->terrain->StreamUnits)[0];

	for (i = 0; i < numportals; i++)
	{
		stream = (struct StreamUnitPortal*)((long*)streamUnit->level->terrain->StreamUnits + 1) + i;

		strcpy(text, stream->tolevelname);

		commapos = strchr(text, ',');

		if (commapos != NULL)
		{
			commapos[0] = 0;

			if (strcmpi(text, "warpgate") == 0)
			{
				stream->toStreamUnit = NULL;

				streamUnit->fromSignal |= 0x1;

				WARPGATE_RelocateLoadedWarpRooms(streamUnit, stream);
			}
			else
			{
				STREAM_LoadLevel(text, stream, 1);
			}
		}
	}
}

void RelocateLevel(struct Level* level, struct _SVector* offset)//Matching - 98.19%
{
	int curTree;
	short _x0;
	short _y0;
	short _z0;
	short _x1;
	short _y1;
	short _z1;
	struct _Position* _v;

	RelocateTerrain(level->terrain, offset);

	RelocateVMObjects(level->vmobjectList, level->numVMObjects, offset);

	RelocateBGObjects(level->bgObjectList, level->numBGObjects, offset);

	RelocateCameras((struct _CameraKey*)level->cameraList, level->numCameras, offset);

	RelocateSavedCameras(&theCamera, level, offset);

	level->deathZ += offset->z;

	RelocatePlanMarkers(level->PlanMarkerList, level->NumberOfPlanMarkers, offset);

	RelocateSFXMarkers(level->SFXMarkerList, level->NumberOfSFXMarkers, offset);

	if (level->waterZLevel != -32767 && level->waterZLevel != 32767)
	{
		level->waterZLevel += offset->z;
	}

	for (curTree = 0; curTree < level->terrain->numBSPTrees; curTree++)
	{
		_v = &level->terrain->BSPTreeArray[curTree].globalOffset;

		_x0 = _v->x;
		_y0 = _v->y;
		_z0 = _v->z;

		_x1 = offset->x;
		_y1 = offset->y;
		_z1 = offset->z;

		_x0 += _x1;
		_y0 += _y1;
		_z0 += _z1;

		_v->x = _x0;
		_v->y = _y0;
		_v->z = _z0;
	}
}

void RelocateCameras(struct _CameraKey* cameraList, long numCameras, struct _SVector* offset)
{
	int i;
	
	for (i = 0; i < numCameras; i++)
	{
		cameraList[i].x += offset->x;
		cameraList[i].y += offset->y;
		cameraList[i].z += offset->z;

		cameraList[i].tx += offset->x;
		cameraList[i].ty += offset->y;
		cameraList[i].tz += offset->z;
	}
}

void RelocateSavedCameras(struct Camera* camera, struct Level* level, struct _SVector* offset)
{
	int i;
	short _x0;
	short _y0;
	short _z0;
	short _x1;
	short _y1;
	short _z1;
	struct _Position* _v;

	if (camera->stack >= 0)
	{
		for (i = 0; camera->stack >= i; i++)
		{
			if (camera->savedMode[i] == 5 && camera->savedCinematic[i].level == level)
			{
				_v = &camera->savedCinematic[i].position;

				_x1 = offset->x;
				_y1 = offset->y;
				_z1 = offset->z;

				_x0 = _v->x;
				_y0 = _v->y;
				_z0 = _v->z;

				_v->x = _x0 + _x1;
				_v->y = _y0 + _y1;
				_v->z = _z0 + _z1;

				_v = &camera->savedCinematic[i].focusPoint;

				_x0 = _v->x;
				_y0 = _v->y;
				_z0 = _v->z;

				_x1 = offset->x;
				_y1 = offset->y;
				_z1 = offset->z;

				_v->x = _x0 + _x1;
				_v->y = _y0 + _y1;
				_v->z = _z0 + _z1;

				_v = &camera->savedCinematic[i].targetPos;

				_x0 = _v->x;
				_y0 = _v->y;
				_z0 = _v->z;

				_x1 = offset->x;
				_y1 = offset->y;
				_z1 = offset->z;

				_v->x = _x0 + _x1;
				_v->y = _y0 + _y1;
				_v->z = _z0 + _z1;

				_v = &camera->savedCinematic[i].targetFocusPoint;

				_x0 = _v->x;
				_y0 = _v->y;
				_z0 = _v->z;

				_x1 = offset->x;
				_y1 = offset->y;
				_z1 = offset->z;

				_v->x = _x0 + _x1;
				_v->y = _y0 + _y1;
				_v->z = _z0 + _z1;
			}
		}
	}
}

void RelocateLevelWithInstances(struct Level *level, struct _SVector *offset)
{
	RelocateLevel(level, offset);

	RelocateInstances(offset);

	RelocatePlanPool((struct PlanningNode*)gameTrackerX.planningPool, offset);
}

void RelocateTerrain(struct _Terrain *terrain, struct _SVector *offset)
{
	int i;

	for (i = 0; i < terrain->numIntros; i++)
	{
		terrain->introList[i].position.x += offset->x;
		terrain->introList[i].position.y += offset->y;
		terrain->introList[i].position.z += offset->z;

		if (terrain->introList[i].multiSpline != NULL)
		{
			STREAM_AdjustMultiSpline(terrain->introList[i].multiSpline, offset);
		}
	}

	RelocateStreamPortals((struct StreamUnitPortal*)((long*)terrain->StreamUnits + 1), ((long*)terrain->StreamUnits)[0], offset);
}

void RelocateVMObjects(struct _VMObject* vobjectlist, long numvmobjs, struct _SVector* offset)
{
	int i;

	for (i = 0; i < numvmobjs; i++)
	{
		vobjectlist[i].position.x += offset->x;
		vobjectlist[i].position.y += offset->y;
		vobjectlist[i].position.z += offset->z;
	}
}

void RelocateBGObjects(struct _BGObject* BGObjList, long numBGObjs, struct _SVector* offset)
{
	int i;
	int d;

	for (i = 0; i < numBGObjs; i++)
	{
		for (d = 0; d < BGObjList->numVertices; d++)
		{
			BGObjList[i].vertexList[d].x += offset->x;
			BGObjList[i].vertexList[d].y += offset->y;
			BGObjList[i].vertexList[d].z += offset->z;
		}
	}
}

void RelocatePlanPool(struct PlanningNode* planPool, struct _SVector* offset)//Matching - 99.78%
{
	int i;
	short ox;
	short oy;
	short oz;

	ox = offset->x;
	oy = offset->y;
	oz = offset->z;

	for (i = PLANAPI_NumNodesInPool(planPool); i != 0; i--, planPool++)
	{
		planPool->pos.x += ox;
		planPool->pos.y += oy;
		planPool->pos.z += oz;
	}

	poolManagementData->playerPosAtLastPlanMkrUpdate.x += ox;
	poolManagementData->playerPosAtLastPlanMkrUpdate.y += oy;
	poolManagementData->playerPosAtLastPlanMkrUpdate.z += oz;
}

void RelocatePlanMarkers(struct _PlanMkr* planMkrList, int numPlanMkrs, struct _SVector* offset)
{ 
	int i;
	short ox;
	short oy;
	short oz;

	ox = offset->x;
	oy = offset->y;
	oz = offset->z;

	for (i = 0; i < numPlanMkrs; i++)
	{
		planMkrList[i].pos.x += ox;
		planMkrList[i].pos.y += oy;
		planMkrList[i].pos.z += oz;
	}
}

void RelocateSFXMarkers(struct _SFXMkr* sfxMkrList, int numSFXMkrs, struct _SVector* offset)
{
	int i;
	short ox;
	short oy;
	short oz;

	ox = offset->x;
	oy = offset->y;
	oz = offset->z;

	for (i = 0; i != numSFXMkrs; i++)
	{
		sfxMkrList[i].pos.x += ox;
		sfxMkrList[i].pos.y += oy;
		sfxMkrList[i].pos.z += oz;
	}
}

void STREAM_AdjustMultiSpline(struct MultiSpline* multi, struct _SVector* offset)
{
	int i;

	if (multi->positional != NULL && multi->positional->numkeys > 0)
	{
		for (i = 0; i < multi->positional->numkeys; i++)
		{
			multi->positional->key[i].point.x += offset->x;
			multi->positional->key[i].point.y += offset->y;
			multi->positional->key[i].point.z += offset->z;
		}
	}
}

void STREAM_RelocateInstance(struct _Instance* instance, struct _SVector* offset)
{ 
	STREAM_OffsetInstancePosition(instance, offset, 1);

	INSTANCE_Post(instance, 0x100008, (intptr_t)offset);
}

void STREAM_OffsetInstancePosition(struct _Instance* instance, struct _SVector* offset, int streamSignalFlag)
{
	instance->position.x += offset->x;
	instance->position.y += offset->y;
	instance->position.z += offset->z;

	instance->oldPos.x += offset->x;
	instance->oldPos.y += offset->y;
	instance->oldPos.z += offset->z;

	instance->shadowPosition.x += offset->x;
	instance->shadowPosition.y += offset->y;
	instance->shadowPosition.z += offset->z;

	COLLIDE_UpdateAllTransforms(instance, (SVECTOR*)offset);
	COLLIDE_MoveAllTransforms(instance, (struct _Position*)offset);

	if (instance == theCamera.focusInstance)
	{
		CAMERA_Relocate(&theCamera, offset, streamSignalFlag);
	}
}

void STREAM_SetInstancePosition(struct _Instance* instance, struct evPositionData* data)//Matching - 99.77%
{
	struct _SVector offset;

	offset.x = data->x - instance->position.x;
	offset.y = data->y - instance->position.y;
	offset.z = data->z - instance->position.z;

	STREAM_OffsetInstancePosition(instance, &offset, 0);
}

void RelocateInstances(struct _SVector* offset)
{
	struct _Instance* instance;

	instance = gameTrackerX.instanceList->first;

	while (instance != NULL)
	{
		STREAM_RelocateInstance(instance, offset);

		instance = instance->next;
	}

	FX_Relocate(offset);
}

void RelocateStreamPortals(struct StreamUnitPortal* StreamUnitList, int NumStreamUnits, struct _SVector* offset)
{
	int i;
	int d;

	for (i = 0; i < NumStreamUnits; i++)
	{
		StreamUnitList[i].maxx += offset->x;
		StreamUnitList[i].maxy += offset->y;
		StreamUnitList[i].maxz += offset->z;

		StreamUnitList[i].minx += offset->x;
		StreamUnitList[i].miny += offset->y;
		StreamUnitList[i].minz += offset->z;

		for (d = 0; d < 3; d++)
		{
			StreamUnitList[i].t1[d].x += offset->x;
			StreamUnitList[i].t1[d].y += offset->y;
			StreamUnitList[i].t1[d].z += offset->z;
		}

		for (d = 0; d < 3; d++)
		{
			StreamUnitList[i].t2[d].x += offset->x;
			StreamUnitList[i].t2[d].y += offset->y;
			StreamUnitList[i].t2[d].z += offset->z;
		}
	}
}

void STREAM_PackVRAMObject(struct _ObjectTracker* objectTracker)
{ 
	struct VramSize* vramSize;
	struct VramBuffer* vramBuffer;
	char fileName[64];
	struct _BlockVramEntry* vramBlock;
	
	vramSize = &objectTracker->object->vramSize;

	if (vramSize->x != -1 && VRAM_GetObjectVramSpace(vramSize, objectTracker) != 0)
	{
		vramBlock = (struct _BlockVramEntry*)objectTracker->vramBlock;

		if (vramBlock != NULL)
		{
			AdjustVramCoordsObject(SCREEN_WIDTH, 0, vramBlock->x, vramBlock->y, objectTracker->object);
		}
			
		sprintf(fileName, "\\kain2\\object\\%s\\%s.crm", objectTracker->name, objectTracker->name);
			
		vramBuffer = (struct VramBuffer*)MEMPACK_Malloc((vramBlock->w << 1) + sizeof(struct VramBuffer), 0x23);
			
		vramBuffer->lineOverFlow = (short*)(vramBuffer + 1);
		vramBuffer->flags = 0;
		vramBuffer->x = vramBlock->x;
		vramBuffer->y = vramBlock->y;
		vramBuffer->w = vramBlock->w;
		vramBuffer->yOffset = 0;
		vramBuffer->lengthOfLeftOverData = 0;
		vramBuffer->h = vramBlock->h;
			
		LOAD_NonBlockingBufferedLoad(fileName, (void*)VRAM_TransferBufferToVram, vramBuffer, objectTracker);
	}
	else
	{
		objectTracker->vramBlock = NULL;
	}
}

void MORPH_SetupInstanceFlags(struct _Instance *instance)
{ 
	if (!(instance->object->oflags & 0x80000))
	{
		if (gameTrackerX.gameData.asmData.MorphType == 0)
		{
			if (!(instance->flags2 & 0x8000000))
			{
				instance->flags2 &= 0xEFFFFFFF;
				instance->flags2 &= 0xFBFFFFFF;
				return;
			}
		}
		else
		{
			instance->flags2 &= 0xEFFFFFFF;
			instance->flags2 &= 0xFBFFFFFF;
			return;
		}

		instance->flags2 &= 0x10000000;

		if (MEMPACK_MemoryValidFunc((char*)instance->data) != 0)
		{
			if (!(instance->object->oflags2 & 0x2000000) && instance->LinkParent != NULL && !(instance->LinkParent->object->oflags2 & 0x2000000))
			{
				return;
			}

			INSTANCE_Post(instance, 0x40026, 0);

			instance->flags2 |= 0x4000000;
		}
	}
}

void MORPH_SetupInstanceListFlags()
{
	struct _Instance* instance;

	instance = gameTrackerX.instanceList->first;

	while (instance != NULL)
	{
		MORPH_SetupInstanceFlags(instance);

		instance = instance->next;
	}
}


// autogenerated function stub: 
// void /*$ra*/ MORPH_InMorphInstanceListFlags()
void MORPH_InMorphInstanceListFlags()
{ // line 3489, offset 0x8005c320
	/* begin block 1 */
		// Start line: 3491
		// Start offset: 0x8005C320
		// Variables:
			struct _Instance *instance; // $v1
	/* end block 1 */
	// End offset: 0x8005C380
	// End Line: 3514

	/* begin block 2 */
		// Start line: 8117
	/* end block 2 */
	// End Line: 8118

	/* begin block 3 */
		// Start line: 8118
	/* end block 3 */
	// End Line: 8119

	/* begin block 4 */
		// Start line: 8122
	/* end block 4 */
	// End Line: 8123
			UNIMPLEMENTED();
}

void MORPH_InMorphDoFadeValues()//Matching - 94.35%
{
	int fade1;
	int fade2;

	fade1 = ((gameTrackerX.gameData.asmData.MorphTime) << 12) / 1000;
	fade2 = 4096 - fade1;

	if (gameTrackerX.gameData.asmData.MorphType == 0)
	{
		gameTrackerX.spectral_fadeValue = fade1;
		gameTrackerX.material_fadeValue = fade2;
	}
	else
	{

		gameTrackerX.spectral_fadeValue = fade2;
		gameTrackerX.material_fadeValue = fade1;
	}
}

void MORPH_UpdateTimeMult()
{
	short ratio;

	if (gameTrackerX.gameData.asmData.MorphTime != 1000)
	{
		ratio = gameTrackerX.gameData.asmData.MorphTime - 750;

		if (gameTrackerX.gameData.asmData.MorphType != 0)
		{
			if (ratio < 0)
			{
				ratio = 0;
			}
		}
		else 
		{
			if (ratio >= 251)
			{
				ratio = 250;
			}

			ratio = 250 - ratio;
		}

		gameTrackerX.materialTimeMult = (gameTrackerX.globalTimeMult * (((ratio * 65536) / 4000) - (((ratio * 65536) >> 4) >> 0x1F)) * 16) >> 16;
	
		if (gameTrackerX.materialTimeMult == 0)
		{
			gameTrackerX.materialTimeMult = 1;
		}

		if (gameTrackerX.gameData.asmData.MorphType == 0)
		{
			ratio = gameTrackerX.gameData.asmData.MorphTime - 750;

			if (ratio < 0)
			{
				ratio = 0;
			}
		}
		else
		{
			if (ratio >= 251)
			{
				ratio = 250;
			}

			ratio = 250 - ratio;
		}

		gameTrackerX.spectralTimeMult = (gameTrackerX.globalTimeMult * (((ratio * 65536) / 4000) - (((ratio * 65536) >> 4) >> 0x1F)) * 16) >> 16;
		
		if (gameTrackerX.spectralTimeMult == 0)
		{
			gameTrackerX.spectralTimeMult = 1;
		}
	}
	else
	{
		if (gameTrackerX.gameData.asmData.MorphType == 0)
		{
			gameTrackerX.spectralTimeMult = 0;
			gameTrackerX.materialTimeMult = gameTrackerX.globalTimeMult;
		}
		else
		{
			gameTrackerX.materialTimeMult = 0;
			gameTrackerX.spectralTimeMult = gameTrackerX.globalTimeMult;
		}
	}
}

void MORPH_UpdateNormals(struct Level* BaseLevel)//Matching - 93.33%
{
	SVECTOR realDiff; // stack offset -32
	struct _Position oldPos; // stack offset -24
	struct _TFace* face; // $v1
	long faceCount; // $a2
	struct _TVertex* v; // $a1
	struct _MorphVertex* mv; // $a3
	struct _MorphColor* mc; // $a0
	short h1; // $v1
	short* morphNormals; // $a1
	struct _TVertex* endv; // $a2
	struct _BSPNode* node; // $v1
	struct _BSPLeaf* leaf; // $a1
	struct _Sphere_noSq hsphere; // stack offset -32
	struct _BoundingBox hbox; // stack offset -24
	struct _Terrain* terrain; // $a0
	long curTree; // $t0
	struct _Instance* instance; // $s0
	struct Intro* intro;

	morphNormals = BaseLevel->terrain->morphNormalIdx;
	faceCount = BaseLevel->terrain->numFaces;
	face = BaseLevel->terrain->faceList;
	while (faceCount > 0)
	{
		h1 = face->normal;
		face->normal = *morphNormals;
		*morphNormals++ = h1;
		face++;
		faceCount--;
	}

	terrain = BaseLevel->terrain;
	mv = terrain->MorphDiffList;

	if (BaseLevel->terrain->MorphDiffList != NULL)
	{
		for (; mv->vindex >= 0; mv++)
		{
			v = &BaseLevel->terrain->vertexList[mv->vindex];

			v->vertex.x = mv->hx + mv->x;
			v->vertex.y = mv->hy + mv->y;
			v->vertex.z = mv->hz + mv->z;
		}
	}
	mc = BaseLevel->terrain->MorphColorList;

	if (mc)
	{
		endv = &BaseLevel->terrain->vertexList[BaseLevel->terrain->numVertices];

		v = BaseLevel->terrain->vertexList;

		while (v < endv)
		{
			v->r0 = ((unsigned short)mc->morphColor15 & 0x1F) << 3;
			v->g0 = ((unsigned short)mc->morphColor15 >> 2) & 0xF8;
			v->b0 = ((unsigned short)mc->morphColor15 >> 7) & 0xF8;

			v++;
			mc++;
		}
	}

	for (curTree = 0; curTree < BaseLevel->terrain->numBSPTrees; curTree++)
	{
		node = BaseLevel->terrain->BSPTreeArray[curTree].bspRoot;

		while (node < (struct _BSPNode*)BaseLevel->terrain->BSPTreeArray[curTree].startLeaves)
		{
			hsphere = node->sphere;
			node->sphere = node->spectralSphere;
			node->spectralSphere = hsphere;
			node++;
		}

		leaf = BaseLevel->terrain->BSPTreeArray[curTree].startLeaves;
		while (leaf < BaseLevel->terrain->BSPTreeArray[curTree].endLeaves)
		{
			hsphere = leaf->sphere;
			leaf->sphere = leaf->spectralSphere;
			leaf->spectralSphere = hsphere;

			hbox = leaf->spectralBox;
			leaf->box = leaf->spectralBox;
			leaf->spectralBox = hbox;
			leaf++;
		}
	}

	instance = gameTrackerX.instanceList->first;

	for (; instance; instance = instance->next)
	{
		intro = instance->intro;

		if (intro && (*(unsigned int*)&intro->spectralPosition.x || intro->spectralPosition.z) && (!(instance->flags2 & 0x8)))
		{
			oldPos = instance->position;

			instance->position.x = intro->position.x + intro->spectralPosition.x;
			instance->position.y = intro->position.y + intro->spectralPosition.y;
			instance->position.z = intro->position.z + intro->spectralPosition.z;

			realDiff.vx = instance->position.x - oldPos.x;
			realDiff.vy = instance->position.y - oldPos.y;
			realDiff.vz = instance->position.z - oldPos.z;

			if (realDiff.vx + realDiff.vy + realDiff.vz)
			{
				COLLIDE_UpdateAllTransforms(instance, &realDiff);
			}
		}
	}
}

// autogenerated function stub: 
// void /*$ra*/ MORPH_BringBackNormals(struct Level *BaseLevel /*$a3*/)
void MORPH_BringBackNormals(struct Level *BaseLevel)
{ // line 3762, offset 0x8005ca08
	/* begin block 1 */
		// Start line: 3763
		// Start offset: 0x8005CA08
		// Variables:
			struct _TFace *face; // $v1
			long faceCount; // $a2
			struct _TVertex *v; // $a1
			struct _MorphVertex *mv; // $a0
			struct _MorphColor *mc; // $v0
			short h1; // $v1
			short *morphNormals; // $a1

		/* begin block 1.1 */
			// Start line: 3818
			// Start offset: 0x8005CAE4
			// Variables:
				struct _TVertex *endv; // $a2
		/* end block 1.1 */
		// End offset: 0x8005CB4C
		// End Line: 3829

		/* begin block 1.2 */
			// Start line: 3844
			// Start offset: 0x8005CB4C
			// Variables:
				struct _BSPNode *node; // $v1
				struct _BSPLeaf *leaf; // $a1
				//struct _Sphere_noSq hsphere; // stack offset -32
				//sstruct _BoundingBox hbox; // stack offset -24
				struct _Terrain *terrain; // $a0
				long curTree; // $t0
		/* end block 1.2 */
		// End offset: 0x8005CD60
		// End Line: 3894

		/* begin block 1.3 */
			// Start line: 3897
			// Start offset: 0x8005CD60
			// Variables:
				struct _Instance *instance; // $s0

			/* begin block 1.3.1 */
				// Start line: 3903
				// Start offset: 0x8005CD88
				// Variables:
					SVECTOR realDiff; // stack offset -32
					_Position oldPos; // stack offset -24
			/* end block 1.3.1 */
			// End offset: 0x8005CE58
			// End Line: 3927
		/* end block 1.3 */
		// End offset: 0x8005CE68
		// End Line: 3930
	/* end block 1 */
	// End offset: 0x8005CE68
	// End Line: 3931

	/* begin block 2 */
		// Start line: 8739
	/* end block 2 */
	// End Line: 8740
					UNIMPLEMENTED();
}

void MORPH_AddOffsets(struct Level* BaseLevel, int time)//Matching - 98.67%
{
	struct _TVertex* v;
	struct _MorphVertex* mv;
	struct _MorphColor* mc;
	long m;
	long fixed_time;
	struct _Instance* instance;
	SVECTOR diff;
	SVECTOR realDiff;
	struct _Position oldPos;
	long r0;
	long g0;
	long b0;
	long r1;
	long g1;
	long b1;
	struct _TVertex* endv;
	struct Intro* intro;

	instance = gameTrackerX.instanceList->first;

	if (time < 501)
	{
		time = time * 2 * time * 2 * time / 2000000;
	}
	else
	{
		time = 1000 - (1000 - time) * 2 * (1000 - time) * 2 * (1000 - time) / 2000000;
	}

	mv = BaseLevel->terrain->MorphDiffList;
	fixed_time = (time << 12) / 1000;

	if (BaseLevel->terrain->MorphDiffList != NULL)
	{
		for (; mv->vindex >= 0; mv++)
		{
			v = &BaseLevel->terrain->vertexList[mv->vindex];

			v->vertex.x = mv->hx + ((mv->x * fixed_time) >> 12);
			v->vertex.y = mv->hy + ((mv->y * fixed_time) >> 12);
			v->vertex.z = mv->hz + ((mv->z * fixed_time) >> 12);
		}
	}
	for (; instance; instance = instance->next)
	{
		intro = instance->intro;

		if (intro && (*(unsigned int*)&intro->spectralPosition.x || intro->spectralPosition.z) && ((instance->flags2 & 0x8)) == 0)
		{
			diff.vx = (intro->spectralPosition.x * fixed_time) >> 12;
			diff.vy = (intro->spectralPosition.y * fixed_time) >> 12;
			diff.vz = (intro->spectralPosition.z * fixed_time) >> 12;

			oldPos = instance->position;

			instance->position.x = intro->position.x + oldPos.x;
			instance->position.y = intro->position.y + oldPos.y;
			instance->position.z = intro->position.z + oldPos.z;

			realDiff.vx = instance->position.x - oldPos.x;
			realDiff.vy = instance->position.y - oldPos.y;
			realDiff.vz = instance->position.z - oldPos.z;

			if (realDiff.vx + realDiff.vy + realDiff.vz)
			{
				COLLIDE_UpdateAllTransforms(instance, &realDiff);
			}
		}
	}

	mc = BaseLevel->terrain->MorphColorList;

	if (mc)
	{
		v = BaseLevel->terrain->vertexList;
		endv = &BaseLevel->terrain->vertexList[BaseLevel->terrain->numVertices];

		while (v < endv)
		{
			r0 = (v->rgb15 & 0x1F) << 3;
			r1 = (mc->morphColor15 & 0x1F) << 3;

			g0 = (v->rgb15 >> 2) & 0xF8;
			g1 = (mc->morphColor15 >> 2) & 0xF8;

			b0 = (v->rgb15 >> 7) & 0xF8;
			b1 = (mc->morphColor15 >> 7) & 0xF8;

			v->r0 = r0 + (((r1 - r0) * fixed_time) >> 12);
			v->g0 = g0 + (((g1 - g0) * fixed_time) >> 12);
			v->b0 = b0 + (((b1 - b0) * fixed_time) >> 12);

			v++;
			mc++;
		}
	}
}

void MORPH_SubtractOffsets(struct Level* BaseLevel, int time)//Matching - 98.68%
{
	struct _TVertex* v;
	struct _MorphVertex* mv;
	struct _MorphColor* mc;
	long m;
	long fixed_time;
	struct _Instance* instance;
	SVECTOR diff;
	SVECTOR realDiff;
	struct _Position oldPos;
	long r0;
	long g0;
	long b0;
	long r1;
	long g1;
	long b1;
	struct _TVertex* endv;
	struct Intro* intro;

	instance = gameTrackerX.instanceList->first;

	if (time < 501)
	{
		time = time * 2 * time * 2 * time / 2000000;
	}
	else
	{
		time = 1000 - (1000 - time) * 2 * (1000 - time) * 2 * (1000 - time) / 2000000;
	}

	mv = BaseLevel->terrain->MorphDiffList;
	fixed_time = ((1000 - time) << 12) / 1000;

	if (BaseLevel->terrain->MorphDiffList != NULL)
	{
		for (; mv->vindex >= 0; mv++)
		{
			v = &BaseLevel->terrain->vertexList[mv->vindex];

			v->vertex.x = mv->hx + ((mv->x * fixed_time) >> 12);
			v->vertex.y = mv->hy + ((mv->y * fixed_time) >> 12);
			v->vertex.z = mv->hz + ((mv->z * fixed_time) >> 12);
		}
	}

	for (; instance; instance = instance->next)
	{
		intro = instance->intro;

		if (intro && (*(unsigned int*)&intro->spectralPosition.x || intro->spectralPosition.z) && ((instance->flags2 & 0x8)) == 0)
		{
			diff.vx = (intro->spectralPosition.x * fixed_time) >> 12;
			diff.vy = (intro->spectralPosition.y * fixed_time) >> 12;
			diff.vz = (intro->spectralPosition.z * fixed_time) >> 12;

			oldPos = instance->position;

			instance->position.x = intro->position.x + oldPos.x;
			instance->position.y = intro->position.y + oldPos.y;
			instance->position.z = intro->position.z + oldPos.z;

			realDiff.vx = instance->position.x - oldPos.x;
			realDiff.vy = instance->position.y - oldPos.y;
			realDiff.vz = instance->position.z - oldPos.z;

			if (realDiff.vx + realDiff.vy + realDiff.vz)
			{
				COLLIDE_UpdateAllTransforms(instance, &realDiff);
			}
		}
	}

	mc = BaseLevel->terrain->MorphColorList;

	if (mc)
	{
		v = BaseLevel->terrain->vertexList;
		endv = &BaseLevel->terrain->vertexList[BaseLevel->terrain->numVertices];

		while (v < endv)
		{
			r0 = (v->rgb15 & 0x1F) << 3;
			r1 = (mc->morphColor15 & 0x1F) << 3;

			g0 = (v->rgb15 >> 2) & 0xF8;
			g1 = (mc->morphColor15 >> 2) & 0xF8;

			b0 = (v->rgb15 >> 7) & 0xF8;
			b1 = (mc->morphColor15 >> 7) & 0xF8;

			v->r0 = r0 + (((r1 - r0) * fixed_time) >> 12);
			v->g0 = g0 + (((g1 - g0) * fixed_time) >> 12);
			v->b0 = b0 + (((b1 - b0) * fixed_time) >> 12);

			v++;
			mc++;
		}
	}
}

void MORPH_GetComponentsForTrackingPoint(struct _TFace* face, struct Level* level)
{
	struct _SVector* v[3];
	struct _Position* offset;
	struct _Position player;
	int n;
	int saved_div;
	int next;
	int side;
	int track;
	int x[2];
	struct _TVertex* vertexList;
	short _x0;
	short _y0;
	short _z0;
	short _x1;
	short _y1;
	short _z1;
	struct _Position* _v;
	struct _Position* _v0;
	int div;

	MORPH_SavedFace = face;
	MORPH_SavedLevel = level;

	if (face != NULL && level != NULL)
	{
		vertexList = level->terrain->vertexList;
		
		v[0] = (struct _SVector*)&vertexList[face->face.v0].vertex;
		v[1] = (struct _SVector*)&vertexList[face->face.v1].vertex;
		v[2] = (struct _SVector*)&vertexList[face->face.v2].vertex;

		_v0 = &gameTrackerX.playerInstance->position;
		
		offset = &level->terrain->BSPTreeArray[gameTrackerX.playerInstance->bspTree].globalOffset;

		_x0 = _v0->x;
		_y0 = _v0->y;
		_z0 = _v0->z;

		_x1 = offset->x;
		_y1 = offset->y;
		_z1 = offset->z;

		_v = &player;

		_v->x = _x0 - _x1;
		_v->y = _y0 - _y1;
		_v->z = _z0 - _z1;

		for(track = 0; track < 2; track++)
		{
			saved_div = 0;
			side = 0;

			for (n = 0; n < 3; n++)
			{
				next = n + 1;

				if (next >= 3)
				{
					next = 0;
				}

				if (track != 1 || n != MORPH_Track[0])
				{
					_v = (struct _Position*)v[0];

					if (player.y < _v->y || v[next]->y < player.y)
					{
						if (player.y >= v[next]->y || _v->y >= player.y)
						{
							if (ABS(saved_div) < ABS(v[next]->y - v[n]->y))
							{
								saved_div = v[next]->y - v[n]->y;
								side = n;
							}
						}
					}
					else
					{
						if (ABS(saved_div) < ABS(v[next]->y - v[n]->y))
						{
							saved_div = v[next]->y - v[n]->y;
							side = n;
						}
					}
				}
			}

			MORPH_Track[track] = side;

			div = side + 1;
			
			if (div >= 3)
			{
				div = 0;
			}

			if (saved_div != 0)
			{
				_v = (struct _Position*)v[side];

				MORPH_Component[track] = ((player.y - _v->y) << 12) / saved_div;
			}
			else
			{
				MORPH_Component[track] = 0;
			}

			div = MORPH_Component[track] * (v[div]->x - v[side]->x);
			
			if (div < 0)
			{
				div += 4095;
			}
			
			x[track] = v[side]->x + (div >> 12);
		}

		if (x[0] != x[1])
		{
			MORPH_Component[2] = ((player.x - x[0]) << 12) / (x[1] - x[0]);
		}
		else
		{
			MORPH_Component[2] = 0;
		}
	}
}

void MORPH_AveragePoint(struct _SVector* start, struct _SVector* end, int interp, struct _SVector* out)
{
	if (interp >= 0)
	{
		if (interp >= 4097)
		{
			interp = 4096;
		}

		LoadAverageShort12((SVECTOR*)start, (SVECTOR*)end, 4096 - interp, interp, (SVECTOR*)out);
	}
	else
	{
		if (interp < -4096)
		{
			interp = -4096;
		}

		LoadAverageShort12((SVECTOR*)end, (SVECTOR*)start, interp + 4096, -interp, (SVECTOR*)out);
	}
}

void MORPH_UpdateTrackingPoint(struct _TFace* face, struct Level* level)
{
	struct _SVector* v[3];
	struct _SVector p1;
	struct _SVector p2;
	struct _SVector p3;
	struct _Position* offset;
	int next;
	struct _TVertex* vertexList;
	short _x0;
	short _y0;
	short _z0;
	short _x1;
	short _y1;
	short _z1;
	struct _Position* _v0;

	if (face != NULL && level != NULL)
	{
		vertexList = level->terrain->vertexList;

		v[0] = (struct _SVector*)&vertexList[face->face.v0];
		v[1] = (struct _SVector*)&vertexList[face->face.v1];
		v[2] = (struct _SVector*)&vertexList[face->face.v2];

		next = MORPH_Track[0] + 1;

		if (next >= 3)
		{
			next = 0;
		}

		MORPH_AveragePoint(v[MORPH_Track[0]], v[next], MORPH_Component[0], &p1);

		next = MORPH_Track[1] + 1;

		if (next >= 3)
		{
			next = 0;
		}

		MORPH_AveragePoint(v[MORPH_Track[1]], v[next], MORPH_Component[1], &p2);

		MORPH_AveragePoint(&p1, &p2, MORPH_Component[2], &p3);

		_z0 = p3.z;
		_y0 = p3.y;
		_x0 = p3.x;

		offset = &level->terrain->BSPTreeArray[gameTrackerX.playerInstance->bspTree].globalOffset;

		_x1 = offset->x;
		_y1 = offset->y;
		_z1 = offset->z;

		_x0 += _x1;
		_y0 += _y1;
		_z0 += _z1;

		p3.x = _x0;
		p3.y = _y0;
		p3.z = _z0;

		_v0 = &gameTrackerX.playerInstance->position;

		_v0->x = _x0;
		_v0->y = _y0;
		_v0->z = _z0;

		gameTrackerX.playerInstance->cachedTFace = -1;

		gameTrackerX.playerInstance->cachedBSPTree = 0;
	}
}

void MORPH_ToggleMorph()
{
	struct Level* level;
	int i;

	SOUND_PlaneShift(gameTrackerX.gameData.asmData.MorphType == 0);

	INSTANCE_Broadcast(NULL, 10, 0x1000020, gameTrackerX.gameData.asmData.MorphType);

	MORPH_GetComponentsForTrackingPoint(gameTrackerX.playerInstance->tface, (struct Level*)gameTrackerX.playerInstance->tfaceLevel);
	
	MORPH_UpdateTrackingPoint(gameTrackerX.playerInstance->tface, (struct Level*)gameTrackerX.playerInstance->tfaceLevel);

	gameTrackerX.gameData.asmData.MorphTime = 0;

	SOUND_Play3dSound(&gameTrackerX.playerInstance->position, 26, -350, 127, 32767);

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 2)
		{
			level = StreamTracker.StreamList[i].level;

			if (gameTrackerX.gameData.asmData.MorphType == 1)
			{
				if (level->materialSignal != NULL)
				{
					level->materialSignal->flags |= 0x1;

					SIGNAL_HandleSignal(gameTrackerX.playerInstance, &level->materialSignal->signalList[0], 8);
					EVENT_AddSignalToReset(level->materialSignal);
				}
			}
			else
			{
				if (level->spectralSignal != NULL)
				{
					level->spectralSignal->flags |= 0x1;

					SIGNAL_HandleSignal(gameTrackerX.playerInstance, &level->spectralSignal->signalList[0], 8);
					EVENT_AddSignalToReset(level->spectralSignal);
				}
			}
		}
	}
}

void MORPH_DoStep(struct _StreamUnit* streamUnit, char* baseAreaName)//Matching - 98.73%
{
	struct Level* level;

	GAMEPAD_Shock1(64, 61440);

	level = streamUnit->level;

	if (level->terrain->MorphDiffList != NULL)
	{
		VM_UpdateMorph(level, 0);

		if (gameTrackerX.gameData.asmData.MorphTime == 1000)
		{
			if (gameTrackerX.gameData.asmData.MorphType == 0)
			{
				gameTrackerX.gameData.asmData.MorphType ^= 0x1;
				
				MORPH_UpdateNormals(level);
			}
			else
			{
				gameTrackerX.gameData.asmData.MorphType ^= 0x1;

				MORPH_BringBackNormals(level);
			}

			gameTrackerX.gameData.asmData.MorphType ^= 0x1;
			
			level->morphLastStep = -1;
		}
		else if (gameTrackerX.gameData.asmData.MorphType == 0)
		{
			MORPH_AddOffsets(level, gameTrackerX.gameData.asmData.MorphTime);
		}
		else
		{
			MORPH_SubtractOffsets(level, gameTrackerX.gameData.asmData.MorphTime);
		}
	}
}

void MORPH_SetFog(struct _StreamUnit* streamUnit, int mainUnitFlag)//Matching - 97.87%
{
	long time;
	struct Level* level;
	int fogNear;
	int fogFar;

	time = (gameTrackerX.gameData.asmData.MorphTime << 12) / 1000;
	level = streamUnit->level;

	if (gameTrackerX.gameData.asmData.MorphType == 0)
	{
		time = 4096 - time;
	}

	fogNear = (level->holdFogNear - level->spectralFogNear) * time / 4096 + level->spectralFogNear;
	fogFar = (level->holdFogFar - level->spectralFogFar) * time / 4096 + level->spectralFogFar;

	if (mainUnitFlag != 0)
	{
		streamUnit->UnitFogNear = fogNear;
		streamUnit->TargetFogNear = fogNear;
		streamUnit->UnitFogFar = fogFar;
		streamUnit->TargetFogFar = fogFar;
	}
	else
	{
		STREAM_SetStreamFog(streamUnit, (short)fogNear, (short)fogFar);
	}
}

void MORPH_UpdateTextures()//Matching - 95%
{
	int time;

	time = (gameTrackerX.gameData.asmData.MorphTime << 12) / 1000;
	
	if (gameTrackerX.gameData.asmData.MorphType == 1)
	{
		time = 4096 - time;
	}

	MORPH_ChangeAreaPalettes(time);
}

void MORPH_Continue()
{
	int i;
	long mode;

	if (gameTrackerX.gameData.asmData.MorphTime == 0)
	{
		MORPH_InMorphInstanceListFlags();
	}

	gameTrackerX.gameData.asmData.MorphTime += 20;

	MORPH_InMorphDoFadeValues();

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 2)
		{
			MORPH_DoStep(&StreamTracker.StreamList[i], StreamTracker.StreamList[i].baseAreaName);

			MORPH_SetFog(&StreamTracker.StreamList[i], 0);
		}
	}

	mode = INSTANCE_Query(gameTrackerX.playerInstance, 0xA);

	if (gameTrackerX.playerInstance->tface != NULL && mode >= 0)
	{
		if (gameTrackerX.playerInstance->tface == MORPH_SavedFace)
		{
			MORPH_UpdateTrackingPoint(MORPH_SavedFace, MORPH_SavedLevel);
		}
		else
		{
			MORPH_GetComponentsForTrackingPoint(gameTrackerX.playerInstance->tface, (struct Level*)gameTrackerX.playerInstance->tfaceLevel);
	
			MORPH_UpdateTrackingPoint(gameTrackerX.playerInstance->tface, (struct Level*)gameTrackerX.playerInstance->tfaceLevel);
		}
	}

	MORPH_UpdateTextures();

	if (gameTrackerX.gameData.asmData.MorphTime == 1000)
	{
		gameTrackerX.gameData.asmData.MorphType ^= 0x1;

		if (gameTrackerX.gameData.asmData.MorphType == 0)
		{
			gameTrackerX.playerInstance->flags2 &= 0xF7FFFFFF;
		}
		else
		{
			gameTrackerX.playerInstance->flags2 |= 0x8000000;
		}

		MORPH_SetupInstanceListFlags();
	}
}

void STREAM_MORPH_Relocate()
{
	MORPH_SavedFace = NULL;

	MORPH_SavedLevel = NULL;
}

int AddVertex(VECTOR* v0, PSX_RECT* rect)
{
	SVECTOR v;
	int x;
	int y;
	int z;
	int scr_x;
	int scr_y;

	if (v0->vx < 0)
	{
		v0->vx += -32768;
	}
	else if (v0->vx > 0)
	{
		v0->vx += 32768;
	}

	if (v0->vy < 0)
	{
		v0->vy += -32768;
	}
	else if (v0->vy > 0)
	{
		v0->vy += 32768;
	}

	if (v0->vz < 0)
	{
		v0->vz += -32768;
	}
	else if (v0->vz > 0)
	{
		v0->vz += 32768;
	}

	v.vx = ((SVECTOR*)&v0->vx)->vy;
	v.vy = ((SVECTOR*)&v0->vy)->vy;
	v.vz = ((SVECTOR*)&v0->vz)->vy;

	gte_ldv0(&v);
	gte_rt();
	gte_stsv(&v);

	if (v.vz > 0)
	{
		x = v.vx;
		y = v.vy;
		z = v.vz;

		scr_x = (((x * 320) / z)) + (SCREEN_WIDTH / 2);
		scr_y = (((y * 320) / z)) + (SCREEN_HEIGHT / 2);

		rect->x = (rect->x < scr_x) ? rect->x : scr_x;
		rect->w = (scr_x < rect->w) ? rect->w : scr_x;

		rect->y = (rect->y < scr_y) ? rect->y : scr_y;
		rect->h = (scr_y < rect->h) ? rect->h : scr_y;

		return z;
	}
	
	return -1;
}

int GetPlaneDist(int k, int j, int i, VECTOR* v)//Matching - 100%
{
	return (((v->vx >> 12) - (theCamera.core.position.x << 4)) * theCamera.core.vvNormalWorVecMat[k].m[j][0]) + 
		   (((v->vy >> 12) - (theCamera.core.position.y << 4)) * theCamera.core.vvNormalWorVecMat[k].m[j][1]) + 
		   (((v->vz >> 12) - (theCamera.core.position.z << 4)) * theCamera.core.vvNormalWorVecMat[k].m[j][2]) ;
}

void CalcVert(VECTOR *v, VECTOR *v1, VECTOR *v2, int dist1, int dist2, int k, int j)
{ 
	int diff;

	diff = (dist1 - dist2) >> 12;

	v->vx = (((v2->vx - v1->vx) >> 12) * (dist2 / diff)) + v2->vx;

	v->vy = (((v2->vy - v1->vy) >> 12) * (dist2 / diff)) + v2->vy;

	v->vz = (((v2->vz - v1->vz) >> 12) * (dist2 / diff)) + v2->vz;
}

int AddClippedTri(SVECTOR* iv, PSX_RECT* cliprect, int *minz)
{
	int clip0;
	int clip1;
	int i;
	int j;
	int k;
	int l;
	int l_1;
	int numvert;
	int newnumvert;
	VECTOR v0[16];
	VECTOR v1[16];
	VECTOR* src;
	VECTOR* dst;
	VECTOR* tmp;
	int z;

	minz[0] = 65535;
	
	src = &v0[0];
	dst = &v1[0];

	for (i = 0; i < 3; i++)
	{
		src[i].vx = iv[i].vx << 16;

		src[i].vy = iv[i].vy << 16;

		src[i].vz = iv[i].vz << 16;
	}

	numvert = 3;
	i = 0;
	j = 0;

	do
	{
		j = i;

		if (i >= 3)
		{
			j = i - 3;
			k = 1;
		}
		else
		{
			k = 0;
		}


		clip0 = GetPlaneDist(k, j, i, src);
		l_1 = 1;
		newnumvert = 0;
		l = 0;

		if (numvert > 0)
		{

			do
			{
				if (l_1 >= numvert)
				{
					l_1 = 0;
				}

				clip1 = GetPlaneDist(k, j, i, &src[l_1]);

				if (clip0 > 0)
				{
					if (clip1 <= 0)
					{
						dst[l].vx = src[l].vx;
						dst[l].vy = src[l].vy;
						dst[l].vz = src[l].vz;
						dst[l].pad = src[l].pad;

						CalcVert(&dst[l + 1], &src[l_1], &src[l], clip1, clip0, k, j);
					
						newnumvert++;
					}
					else
					{
						dst[l].vx = src[l].vx;
						dst[l].vy = src[l].vy;
						dst[l].vz = src[l].vz;
						dst[l].pad = src[l].pad;

						newnumvert++;
					}
				}
				else
				{
					if (clip1 > 0)
					{
						CalcVert(&dst[l], &src[l], &src[l_1], clip0, clip1, k, j);

						newnumvert++;
					}
				}

				clip0 = clip1;
				l++;
				l_1++;

			} while (l < numvert);
		}
		
		tmp = dst;
		numvert = newnumvert;
		dst = src;
		src = tmp;

		if (numvert < 3)
		{
			return (0 < numvert);
		}

		i++;

	} while (i < 5);

	if (numvert > 0)
	{
		for (i = 0; i < numvert; i++)
		{
			z = AddVertex(&src[i], cliprect);

			if (z < minz[0])
			{
				minz[0] = z;
			}
		}
	}
	
	return 1;
}

int STREAM_GetClipRect(struct StreamUnitPortal *portal, PSX_RECT *rect)
{
	int v1x;
	int v1y;
	int v1z;
	int v2x;
	int v2y;
	int v2z;
	int nx;
	int ny;
	int nz;
	int nx2;
	int ny2;
	int nz2;
	int len;
	int side;
	int side2;
	int retval;
	int horizontal_flag;
	int fullscreen_flag;
	int minz;
	int minz2;
	int dot;

	fullscreen_flag = 0;

	horizontal_flag = 0;

	if (portal->t1[0].z == portal->t1[1].z)
	{
		horizontal_flag = (portal->t1[0].z ^ portal->t1[2].z) < 1;
	}
	
	v1y = portal->t1[0].y - portal->t1[1].y;
	v2z = portal->t1[0].z - portal->t1[2].z;
	v1z = portal->t1[0].z - portal->t1[1].z;
	v2y = portal->t1[0].y - portal->t1[2].y;
	v2x = portal->t1[0].x - portal->t1[2].x;
	v1x = portal->t1[0].x - portal->t1[1].x;

	nx = ((v1y * v2z) - (v2y * v1z)) >> 12;
	ny = ((v2x * v1z) - (v1x * v2z)) >> 12;
	nz = ((v2x * v1y) - (v2x * v1y)) >> 12;

	side = -(((portal->t1[0].x - theCamera.core.position.x) * nx) + ((portal->t1[0].y - theCamera.core.position.y) * ny) + ((portal->t1[0].z - theCamera.core.position.z) * nz));
	
	len = MATH3D_FastSqrt((nx * nx) + (ny * ny) + (nz * nz));
	
	if (ABS(side) < len)
	{
		v1y = portal->t2[0].y - portal->t2[1].y;
		v2z = portal->t2[0].z - portal->t2[2].z;
		v1z = portal->t2[0].z - portal->t2[1].z;
		v2y = portal->t2[0].y - portal->t2[1].y;
		v2x = portal->t2[0].x - portal->t2[2].x;
		v1x = portal->t2[0].x - portal->t2[1].x;

		nx2 = ((v1y * v2z) - (v2y * v1z)) >> 12;
		ny2 = ((v2x * v1z) - (v1x * v2z)) >> 12;
		nz2 = ((v1x * v2y) - (v2x * v1y)) >> 12;

		side2 = -(((portal->t2[0].x - theCamera.core.position.x) * nx2) + ((portal->t2[0].y - theCamera.core.position.y) * ny2) + ((portal->t2[0].z - theCamera.core.position.z) * nz2));
		
		MATH3D_FastSqrt((nx2 * nx2) + (ny2 * ny2) + (nz2 * nz2));

		if (side < side2)
		{
			side = side2;
			nx = nx2;
			ny = ny2;
			nz = nz2;
		}
	}

	if (memcmp(portal->tolevelname, "warpgate", sizeof("warpgate") - 1) != 0)
	{
		if (ABS(side) < len)
		{
			dot = -((((theCamera.focusInstance->matrix + 1)->t[0] - theCamera.core.position.x) * nx) + (((theCamera.focusInstance->matrix + 1)->t[1] - theCamera.core.position.y) * ny) + (((theCamera.focusInstance->matrix + 1)->t[2] - theCamera.core.position.z) * nz));

			if (dot > 0 && horizontal_flag == 0)
			{
				fullscreen_flag = 1;
			}
		}
	}

	if (side < -1024)
	{
		if (fullscreen_flag == 0)
		{
			return 0;
		}
	}

	rect->w += rect->x;
	rect->h += rect->y;

	gte_SetRotMatrix(theCamera.core.wcTransform);
	gte_SetTransMatrix(theCamera.core.wcTransform);

	retval = AddClippedTri((SVECTOR*)&portal->t1[0], rect, &minz);
	retval |= AddClippedTri((SVECTOR*)&portal->t2[0], rect, &minz2);

	if (retval == 0)
	{
		rect->w -= rect->x;
		rect->h -= rect->y;

		return 0;
	}
	else
	{
		if (minz2 < minz)
		{
			minz = minz2;
		}

		if (fullscreen_flag != 0)
		{
			if (minz < 64)
			{
				rect->x = 0;
				rect->y = 0;
				rect->w = SCREEN_WIDTH;
				rect->y = SCREEN_HEIGHT;
				
				return 1;
			}
		}

		if (rect->x < 0)
		{
			rect->x = 0;
		}

		if (rect->y < 0)
		{
			rect->y = 0;
		}

		if (rect->w >= 513)
		{
			rect->w = SCREEN_WIDTH;
		}

		if (rect->h >= 241)
		{
			rect->h = SCREEN_HEIGHT;
		}

		rect->w -= rect->x;
		rect->h -= rect->y;

		if (horizontal_flag != 0)
		{
			if (ABS(side) < len)
			{
				if (nz > 0)
				{
					rect->h = SCREEN_HEIGHT - rect->y;
				}
				else
				{
					rect->h += rect->y;
				}

			}
		}

		if (rect->w > 0)
		{

			return (0 < rect->h);
		}
	}

	return 0;
}

long GetFogColor(struct StreamUnitPortal* portal, struct _StreamUnit* mainStreamUnit, struct Level* mainLevel)
{
	long z1;
	long z2;
	long z3;
	long zval;
	long zval2;
	long interp;
	long Color;
	long MainColor;
	long LevelColor;
	struct Level* level;
	int time;

	MainColor = mainStreamUnit->FogColor;

	level = portal->toStreamUnit->level;

	if (gameTrackerX.gameData.asmData.MorphTime != 1000)
	{
		time = (gameTrackerX.gameData.asmData.MorphTime << 12) / 1000;

		if (gameTrackerX.gameData.asmData.MorphType == 1)
		{
			time = 4096 - time;
		}

		LoadAverageCol(&level->specturalColorR, &level->backColorR, time, 4096 - time, (unsigned char*)&LevelColor);

		LevelColor &= 0xFFFFFF;
	}
	else
	{
		if (gameTrackerX.gameData.asmData.MorphType == 1)
		{
			LevelColor = ((int*)&level->specturalColorR)[0];
		}
		else
		{
			LevelColor = ((int*)&level->backColorR)[0];
		}
	}

	gte_ldv0(&portal->t1[0]);
	gte_ldv1(&portal->t1[1]);
	gte_ldv2(&portal->t1[2]);

	gte_rtpt();

	gte_stsz3(&z1, &z2, &z3);

	if (z2 < z1)
	{
		zval = z3;

		if (z3 < z1)
		{
			zval = z1;
		}
	}
	else
	{
		zval = z3;

		if (z3 < z2)
		{
			zval = z2;
		}
	}

	gte_ldv0(&portal->t2[0]);
	gte_ldv1(&portal->t2[1]);
	gte_ldv2(&portal->t2[2]);

	gte_rtpt();

	gte_stsz3(&z1, &z2, &z3);

	if (z2 < z1)
	{
		zval2 = z3;

		if (z3 < z1)
		{
			zval2 = z1;
		}
	}
	else
	{
		zval2 = z3;

		if (z3 < z2)
		{
			zval2 = z2;
		}
	}

	if (zval < zval2)
	{
		zval = zval2;
	}

	zval += 128;

	if (zval < mainLevel->fogFar)
	{
		zval = mainLevel->fogFar;
	}

	s_zval = (mainLevel->fogFar) >> 2;

	if (MainColor == LevelColor)
	{
		Color = LevelColor & 0xFFF8F8F8;

		if (Color != 0)
		{
			Color |= 0x40404;
		}
	}
	else
	{
		if (mainLevel->fogFar - mainLevel->fogNear < 0)
		{
			return LevelColor;
		}
		else
		{
			interp = (MainColor / (mainLevel->fogFar - mainLevel->fogNear)) >> 4;

			if (interp < 0)
			{
				interp = 0;
			}

			if (interp >= 4097)
			{
				interp = 4096;
			}

			LoadAverageCol((unsigned char*)&MainColor, (unsigned char*)&LevelColor, interp, 4096 - interp, (unsigned char*)&Color);

			if (interp >= 4091)
			{
				Color &= 0xFFF8F8F8;

				if (Color != 0)
				{
					Color |= 0x40404;
				}
			}

			Color &= 0xFFFFFF;
		}
	}

	return Color;
}


void DrawFogRectangle(PSX_RECT* cliprect, struct _PrimPool* primPool, int otzpos, unsigned long** drawot, long color)
{
	POLY_G4* polyg4;
	
	polyg4 = (POLY_G4*)gameTrackerX.primPool->nextPrim;

	if ((unsigned int*)(polyg4 + 1) < gameTrackerX.primPool->lastPrim)
	{
		gameTrackerX.primPool->nextPrim = (unsigned int*)(polyg4 + 1);

		polyg4->x0 = cliprect->x;
		polyg4->y0 = cliprect->y;

		polyg4->x1 = cliprect->x + cliprect->w;
		polyg4->y1 = cliprect->y;

		polyg4->x2 = cliprect->x;
		polyg4->y2 = cliprect->y + cliprect->h;

		polyg4->x3 = cliprect->x + cliprect->w;
		
		setlen(polyg4, 8);

		((int*)&polyg4->r0)[0] = color;
		((int*)&polyg4->r1)[0] = color;
		((int*)&polyg4->r2)[0] = color;
		((int*)&polyg4->r3)[0] = color;

		setcode(polyg4, 0x38);

		polyg4->y3 = cliprect->y + cliprect->h;

#if defined(PSXPC_VERSION)
		addPrim(drawot[otzpos * 2], polyg4);
#else
		addPrim(drawot[otzpos], polyg4);
#endif
	}
}

void STREAM_RenderAdjacantUnit(unsigned long** curOT, struct StreamUnitPortal* curStreamPortal, struct _StreamUnit* toStreamUnit, struct _StreamUnit* mainStreamUnit, PSX_RECT* cliprect)
{
	long portalFogColor;

	if ((MEMPACK_MemoryValidFunc((char*)toStreamUnit->level)))
	{
		RENDER_currentStreamUnitID = toStreamUnit->StreamUnitID;

		portalFogColor = GetFogColor(curStreamPortal, mainStreamUnit, mainStreamUnit->level);
	
		DrawFogRectangle(cliprect, gameTrackerX.primPool, 3071, curOT, portalFogColor);

		PushMatrix();

		StreamRenderLevel(toStreamUnit, mainStreamUnit->level, (unsigned int**)curOT, portalFogColor);
	
		PopMatrix();
	}
}

struct BSPTree* STREAM_GetBspTree(struct _StreamUnit* streamUnit, int bspNumber)//Matching - 100%
{
	struct Level* level;
	struct _Terrain* terrain;
	int d;

	level = streamUnit->level;
	terrain = level->terrain;

	if (terrain->numBSPTrees != 0)
	{
		for (d = 0; d < terrain->numBSPTrees; d++)
		{
			if (terrain->BSPTreeArray[d].ID == bspNumber)
			{
				return &terrain->BSPTreeArray[d];
			}
		}
	}

	return NULL;
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_BlockWarpGateEntrance(struct _StreamUnit *streamUnit /*$a0*/, long collideOn /*$s0*/)
void WARPGATE_BlockWarpGateEntrance(struct _StreamUnit *streamUnit, long collideOn)
{ // line 5214, offset 0x8005f018
	/* begin block 1 */
		// Start line: 5215
		// Start offset: 0x8005F018
		// Variables:
			struct BSPTree *bspTree; // $v1
	/* end block 1 */
	// End offset: 0x8005F078
	// End Line: 5232

	/* begin block 2 */
		// Start line: 12419
	/* end block 2 */
	// End Line: 12420
			UNIMPLEMENTED();
}

void WARPGATE_DrawWarpGateRim(struct _StreamUnit* streamUnit, int drawOn)//Matching - 99.77%
{
	struct BSPTree* bspTree;

	bspTree = STREAM_GetBspTree(streamUnit, 3);
	
	if (bspTree)
	{
		bspTree->flags &= 0xFFFD;

		if (drawOn)
		{
			bspTree->flags &= 0xFFFC;
		}
		else
		{
			bspTree->flags |= 0x1;
		}
	}
}

// autogenerated function stub: 
// void /*$ra*/ WARPGATE_HideAllCloudCovers()
void WARPGATE_HideAllCloudCovers()
{ // line 5258, offset 0x8005f0e0
	/* begin block 1 */
		// Start line: 5260
		// Start offset: 0x8005F0E0
		// Variables:
			struct Object *warpFaceObject; // $a1

		/* begin block 1.1 */
			// Start line: 5266
			// Start offset: 0x8005F0F4
			// Variables:
				struct _Instance *instance; // $v1
				struct _Instance *next; // $a0
		/* end block 1.1 */
		// End offset: 0x8005F138
		// End Line: 5281
	/* end block 1 */
	// End offset: 0x8005F138
	// End Line: 5283

	/* begin block 2 */
		// Start line: 12507
	/* end block 2 */
	// End Line: 12508

	/* begin block 3 */
		// Start line: 12508
	/* end block 3 */
	// End Line: 12509

	/* begin block 4 */
		// Start line: 12511
	/* end block 4 */
	// End Line: 12512
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ WARPGATE_UnHideCloudCoverInUnit(long streamUnitID /*$a0*/)
struct _Instance * WARPGATE_UnHideCloudCoverInUnit(long streamUnitID)
{ // line 5285, offset 0x8005f140
	/* begin block 1 */
		// Start line: 5287
		// Start offset: 0x8005F140
		// Variables:
			struct Object *warpFaceObject; // $a3
			struct _Instance *result; // $a2

		/* begin block 1.1 */
			// Start line: 5294
			// Start offset: 0x8005F154
			// Variables:
				struct _Instance *instance; // $v1
				struct _Instance *next; // $a1
		/* end block 1.1 */
		// End offset: 0x8005F1B0
		// End Line: 5312
	/* end block 1 */
	// End offset: 0x8005F1B0
	// End Line: 5314

	/* begin block 2 */
		// Start line: 12563
	/* end block 2 */
	// End Line: 12564

	/* begin block 3 */
		// Start line: 12564
	/* end block 3 */
	// End Line: 12565

	/* begin block 4 */
		// Start line: 12568
	/* end block 4 */
	// End Line: 12569
				UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_RenderWarpGate(unsigned long **mainOT /*$s3*/, struct StreamUnitPortal *curStreamPortal /*$s2*/, struct _StreamUnit *mainStreamUnit /*$s1*/, struct PSX_RECT *cliprect /*$s4*/)
void STREAM_RenderWarpGate(unsigned long **mainOT, struct StreamUnitPortal *curStreamPortal, struct _StreamUnit *mainStreamUnit, PSX_RECT *cliprect)
{ // line 5318, offset 0x8005f1b8
	/* begin block 1 */
		// Start line: 5319
		// Start offset: 0x8005F1B8
		// Variables:
			struct _StreamUnit *toStreamUnit; // $s0
	/* end block 1 */
	// End offset: 0x8005F4D0
	// End Line: 5428

	/* begin block 2 */
		// Start line: 12634
	/* end block 2 */
	// End Line: 12635
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_RenderWarpUnit(unsigned long **mainOT /*$fp*/, struct StreamUnitPortal *curStreamPortal /*$s0*/, struct _StreamUnit *mainStreamUnit /*$s4*/, struct PSX_RECT *cliprect /*$s2*/)
void WARPGATE_RenderWarpUnit(unsigned long** mainOT, struct StreamUnitPortal* curStreamPortal, struct _StreamUnit* mainStreamUnit, PSX_RECT* cliprect)
{ // line 5431, offset 0x8005f4f0
	/* begin block 1 */
		// Start line: 5432
		// Start offset: 0x8005F4F0
		// Variables:
	unsigned long** curOT; // $s3
	DR_AREA* PortalClip; // $s0
	struct _StreamUnit* toStreamUnit; // $s1

/* begin block 1.1 */
	// Start line: 5465
	// Start offset: 0x8005F5B8
	// Variables:
		//PSX_RECT PortalRect; // stack offset -48
	long portalFogColor; // $s0

/* begin block 1.1.1 */
	// Start line: 5534
	// Start offset: 0x8005F800
	// Variables:
	unsigned long* hld; // $a0
/* end block 1.1.1 */
// End offset: 0x8005F898
// End Line: 5552
/* end block 1.1 */
// End offset: 0x8005F898
// End Line: 5553
/* end block 1 */
// End offset: 0x8005F898
// End Line: 5555

/* begin block 2 */
	// Start line: 12871
/* end block 2 */
// End Line: 12872
	UNIMPLEMENTED();
}

void STREAM_DumpNonResidentObjects()
{
	struct _Instance* instance;
	struct _Instance* next;
	struct Object* object;

	instance = gameTrackerX.instanceList->first;

	while (instance != NULL)
	{
		object = instance->object;

		if (!(object->oflags & 0x2000000))
		{
			if (STREAM_GetStreamUnitWithID(instance->birthStreamUnitID) == 0 &&
				STREAM_IsObjectInAnyUnit(FindObjectInTracker(object)) == 0)
			{
#if !defined(PSX_VERSION)//Temporarily disabled to make PSX compile.
				INSTANCE_ReallyRemoveInstance(gameTrackerX.instanceList, instance, 0);
#endif
			}
		}
		instance = instance->next;
	}

	STREAM_RemoveAllObjectsNotInUse();
}

int STREAM_TryAndDumpNonResident(struct _ObjectTracker* otr)
{
	struct _Instance* instance;
	struct _Instance* next;

	if (otr->objectStatus == 2 && !(otr->object->oflags & 0x2000000) && STREAM_IsObjectInAnyUnit(otr) == 0)
	{
		instance = gameTrackerX.instanceList->first;

		while (instance != NULL)
		{
			if (instance->object == otr->object && instance->LinkParent != NULL)
			{
				if (!(instance->object->oflags2 & 0x80000))
				{
					return 0;
				}
			}

			instance = instance->next;
		}

		instance = gameTrackerX.instanceList->first;

		while (instance != NULL)
		{
			next = instance->next;

			if (instance->object == otr->object)
			{
				SAVE_DeleteInstance(instance);

				if (instance->LinkChild != NULL)
				{
					INSTANCE_ReallyRemoveAllChildren(instance);
					instance = instance->next;
				}

				INSTANCE_ReallyRemoveInstance(gameTrackerX.instanceList, instance, 0);
			}

			instance = next;
		}

		STREAM_RemoveAllObjectsNotInUse();

		return otr->objectStatus < 1;
	}
}
