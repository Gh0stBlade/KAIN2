#include "CORE.H"
#include "STREAM.H"
#include "Game/INSTANCE.H"
#include "GAMELOOP.H"
#include "DEBUG.H"
#include "STRMLOAD.H"
#include "RELMOD.H"
#include "OBTABLE.H"
#include "PSX/AADLIB.H"
#include "MEMPACK.H"
#include "VRAM.H"
#include "GAMELOOP.H"
#include "LIGHT3D.H"
#include "EVENT.H"
#include "PLAN/PLANAPI.H"
#include "SAVEINFO.H"
#include "STRMLOAD.H"
#include "SOUND.H"
#include "CAMERA.H"
#include "MATH3D.H"
#include "Game/FX.H"
#include "Game/COLLIDE.H"
#include "GLYPH.H"
#include "Game/DRAW.H"
#include "Game/GAMEPAD.H"
#include "Game/VM.H"
#include "Game/LIST.H"

#include <stddef.h>
#include "TIMER.H"

long CurrentWarpNumber;

struct WarpGateLoadInfo WarpGateLoadInfo;

struct WarpRoom WarpRoomArray[14];

struct STracker StreamTracker; // offset 0x800D1920

struct _TFace* MORPH_SavedFace;

struct Level* MORPH_SavedLevel;

short MORPH_Component[3];

short MORPH_Track[2];

int s_zval;

void STREAM_FillOutFileNames(char *baseAreaName, char *dramName, char *vramName, char *sfxName)  // Matching - 100%
{ 
	char text[16];
	char *number;

	strcpy(text, baseAreaName);
	number = strpbrk(text, "0123456789");

	if (number != 0)
	{
		number[0] = 0;
	}

	if (dramName != NULL)
	{
		sprintf(dramName, "\\kain2\\area\\%s\\bin\\%s.drm", text, baseAreaName);
	}

	if (vramName != NULL)
	{
		sprintf(vramName, "\\kain2\\area\\%s\\bin\\%s.crm", text, baseAreaName);
	}

	if (sfxName != NULL)
	{
		sprintf(sfxName, "\\kain2\\area\\%s\\bin\\%s.snf", text, baseAreaName);
	}
}

void STREAM_AbortAreaLoad(char* baseAreaName)  // Matching - 100%
{
	char vramName[80];

	STREAM_FillOutFileNames(baseAreaName, NULL, vramName, NULL);
	LOAD_AbortDirectoryChange(baseAreaName);
	LOAD_AbortFileLoad(vramName, VRAM_LoadReturn);
}

void STREAM_Init()  // Matching - 100%
{
	int i;

	for (i = 0; i < 16; i++)
	{
		StreamTracker.StreamList[i].used = 0;
		StreamTracker.StreamList[i].flags = 0;
		StreamTracker.StreamList[i].StreamUnitID = 0;
	}
}

int FindObjectName(char *name)  // Matching - 100%
{
	int i;
	struct _ObjectTracker *otr;

	otr = gameTrackerX.GlobalObjects;
	
	for(i = 0; i < 48; i++, otr++)
	{
		if (otr->objectStatus != 0)
		{
#if defined(UWP)
			if (_strcmpi(otr->name, name) == 0)
#else
			if (strcmpi(otr->name, name) == 0)
#endif
			{
				return i;
			}
		}
	}
	
	return -1;
}

struct _ObjectTracker* FindObjectInTracker(struct Object* object)  // Matching - 100%
{
	int i;
	struct _ObjectTracker* otr;

	otr = gameTrackerX.GlobalObjects;
	
	for (i = 0; i < 48; i++, otr++)
	{
		if (otr->objectStatus != 0)
		{
			if (otr->object == object)
			{
				return otr;
			}
		}
	}

	return NULL;
}

struct _StreamUnit* FindStreamUnitFromLevel(struct Level* level)  // Matching - 100%
{
	struct _StreamUnit* ret;
	long i;

	ret = NULL;

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 2 && StreamTracker.StreamList[i].level == level)
		{
			ret = &StreamTracker.StreamList[i];
			break;
		}
	}

	return ret;
}

void STREAM_LoadObjectReturn(void* loadData, void* data, void* data2)  // Matching - 100%
{
	struct Object* object;
	struct _ObjectTracker* objectTracker;

	GetRCnt(0xF2000000);

	object = (struct Object*)loadData;
	objectTracker = (struct _ObjectTracker*)data;
	gameTimer;

	if ((object->oflags & 0x8000000) && object->relocList != NULL && object->relocModule != NULL)
	{
		RELMOD_InitModulePointers((uintptr_t)object->relocModule, (int*)object->relocList);
	}

	STREAM_PackVRAMObject(objectTracker);
	OBTABLE_InitAnimPointers(objectTracker);
	OBTABLE_InitObjectWithID(object);

	if ((object->oflags2 & 0x800000))
	{
		char objDsfxFileName[64];
		sprintf(objDsfxFileName, "\\kain2\\sfx\\object\\%s\\%s.snf", objectTracker->name, objectTracker->name);

		object->sfxFileHandle = 0;

		if (LOAD_DoesFileExist(objDsfxFileName) != 0)
		{
			object->sfxFileHandle = aadLoadDynamicSfx(objectTracker->name, 0, 0);
		}
	}

	if (objectTracker->vramBlock == NULL)
	{
		objectTracker->objectStatus = 2;
	}
	else
	{
		objectTracker->objectStatus = 4;
	}
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_DumpMonster(struct _ObjectTracker *dumpee /*$s2*/)
void STREAM_DumpMonster(struct _ObjectTracker *dumpee)
{ // line 399, offset 0x8005882c
	/* begin block 1 */
		// Start line: 400
		// Start offset: 0x8005882C
		// Variables:
			struct Object *object; // $s1
			struct _Instance *instance; // $a1

		/* begin block 1.1 */
			// Start line: 407
			// Start offset: 0x80058858
			// Variables:
				struct _Instance *next; // $s0
		/* end block 1.1 */
		// End offset: 0x80058874
		// End Line: 414
	/* end block 1 */
	// End offset: 0x80058880
	// End Line: 417

	/* begin block 2 */
		// Start line: 806
	/* end block 2 */
	// End Line: 807

	/* begin block 3 */
		// Start line: 811
	/* end block 3 */
	// End Line: 812
				UNIMPLEMENTED();
}

int STREAM_InList(char* name, char** nameList)  // Matching - 100%
{
	char** mon;

	mon = nameList;

	while (*mon != NULL)
	{
#if defined(PSXPC_VERSION)
		if (_strcmpi(name, *mon) == 0)
#else
		if (strcmpi(name, *mon) == 0)
#endif
		{
			return 1;
		}

		mon++;
	}

	return 0;
}

int STREAM_IsSpecialMonster(char *name)
{
	static char* mon[6] = {
		"wallcr",
		"aluka",
		"ronin",
		"slaugh"
		"vwraith",
		NULL
	};

	return STREAM_InList(name, mon);
}

void STREAM_DumpSomeMonsters()  // Matching - 100%
{
	struct _ObjectTracker* otr;
	int i;

	otr = gameTrackerX.GlobalObjects;
	for (i = 0; i < 48; i++, otr++)
	{
		if (((otr->objectStatus == 2) && (otr->object != NULL)) && (STREAM_IsSpecialMonster((char*)otr) != 0))
		{
			STREAM_DumpMonster(otr);
		}
	}
}

void STREAM_NoMonsters()  // Matching - 100%
{
	gameTrackerX.gameFlags |= 0x4000000;

	STREAM_DumpSomeMonsters();
}

void STREAM_YesMonsters()  // Matching - 100%
{
	gameTrackerX.gameFlags &= ~0x4000000;
}


int STREAM_IsMonster(char *name)
{ 
	static char* monnames[19] = {
		"skinner",
		"morlock",
		"vlgra",
		"vlgrb",
		"vlgrc",
		"hunter",
		"wrshp",
		"roninbss",
		"skinbos",
		"priests",
		"alukabss",
		"morboss",
		"soul",
		"wallcr",
		"aluka",
		"ronin",
		"sluagh",
		"vwraith",
		NULL,
	};
	
	return STREAM_InList(name, monnames);
}

int STREAM_TryAndDumpANonResidentObject()  // Matching - 100%
{ 
	struct _ObjectTracker* otr;
	int i;

	otr = gameTrackerX.GlobalObjects;

	for (i = 0; i < 48; i++, otr++)
	{
		if (STREAM_TryAndDumpNonResident(otr) != 0)
		{
			return i;
		}
	}

	return -1;
}

int InsertGlobalObject(char* name, struct GameTracker* gameTracker)  // Matching - 100%
{
	char string[64];
	char vramname[64];
	int i;
	struct _ObjectTracker* otr;

	i = -1;
	if ((!(gameTrackerX.gameFlags & 0x4000000) || (STREAM_IsSpecialMonster(name) == 0)) && (!(gameTracker->debugFlags2 & 0x8000) || (STREAM_IsMonster(name) == 0)))
	{
		otr = gameTracker->GlobalObjects;

		for (i = 0; i < 48; i++, otr++)
		{
			if (otr->objectStatus != 0)
			{
				#if defined(PSXPC_VERSION)
				if (_strcmpi(otr->name, name) == 0)
				#else
				if (strcmpi(otr->name, name) == 0)
				#endif
				{
					break;
				}
			}
		}
		if (i == 48)
		{
			for (otr = gameTracker->GlobalObjects, i = 0; i < 48; i++, otr++)
			{
				if (otr->objectStatus == 0)
				{
					break;
				}
			}

			if (i == 48)
			{
				i = STREAM_TryAndDumpANonResidentObject();

				if (i == -1)
				{
					DEBUG_FatalError("The Object tracker is full MAX_OBJECTS=%d\n", 48);
				}
			}

			sprintf(string, "\\kain2\\object\\%s\\%s.drm", name, name);
			sprintf(vramname, "\\kain2\\object\\%s\\%s.crm", name, name);

			strcpy(otr->name, name);

			otr->objectStatus = 1;
			LOAD_NonBlockingBinaryLoad(string, (void*)STREAM_LoadObjectReturn, (void*)otr, NULL, (void**)&otr->object, 1);
			otr->numInUse = 0;
			otr->numObjectsUsing = 0;
		}
	}

	return i;
}

struct _ObjectTracker* STREAM_GetObjectTracker(char* name)  // Matching - 100%
{
	int i;

	i = InsertGlobalObject(name, &gameTrackerX);

	if (i == -1)
	{
		return NULL;
	}
	else
	{
		return &gameTrackerX.GlobalObjects[i];
	}
}

void LoadLevelObjects(struct _StreamUnit* stream)  // Matching - 100%
{
	int objlist_pos;
	char name[20];
	struct Level* level;
	int i;

	STREAM_NextLoadAsNormal();
	objlist_pos = 0;

	while (((unsigned char*)stream->level->objectNameList)[objlist_pos] != 255)
	{
		strcpy(name, (char*)stream->level->objectNameList + objlist_pos);
		InsertGlobalObject(name, &gameTrackerX);

		objlist_pos += 16;
	}

	level = stream->level;

	for (i = 0; i < level->numIntros; i++)
	{
		if (FindObjectName(level->introList[i].name) != -1)
		{
			level->introList[i].flags &= 0xFFFFBFFF;
		}
		else
		{
			level->introList[i].flags |= 0x4000;
		}
	}
}

long STREAM_IsAnInstanceUsingObject(struct Object* object)  // Matching - 100%
{
	struct _Instance* instance;
	struct _Instance* next;
	long ret;
	
	instance = gameTrackerX.instanceList->first;
	ret = 0;

	while (instance != NULL)
	{
		next = instance->next;

		if (instance->object == object)
		{
			ret = 1;
			break;
		}

		instance = next;
	}

	return ret;
}

void STREAM_StreamLoadObjectAbort(void* loadData, void* data, void* data2)  // Matching - 100%
{
	struct _ObjectTracker* objectTracker;

	objectTracker = (struct _ObjectTracker*)data;

	if (loadData != NULL)
	{
		MEMPACK_Free((char*)loadData);
	}

	objectTracker->objectStatus = 0;
}

void STREAM_DumpLoadingObjects()  // Matching - 100%
{
	int i;
	struct _ObjectTracker* tracker;

	tracker = gameTrackerX.GlobalObjects;

	for (i = 0; i < 48; i++, tracker++)
	{
		if (tracker->objectStatus == 1)
		{
			STREAM_DumpObject(tracker);
		}
	}
}

void STREAM_DumpObject(struct _ObjectTracker* objectTracker)  // Matching - 100%
{
	struct Object* object;
	char dramName[64];

	object = objectTracker->object;

	if (objectTracker->objectStatus == 1)
	{
		sprintf(dramName, "\\kain2\\object\\%s\\%s.drm", objectTracker->name, objectTracker->name);
		LOAD_AbortFileLoad(dramName, STREAM_StreamLoadObjectAbort);
	}
	else if (object != NULL)
	{
		if (!(object->oflags & 0x2000000))
		{
			if (objectTracker->vramBlock != NULL)
			{
				VRAM_ClearVramBlock((struct _BlockVramEntry*)objectTracker->vramBlock);
			}

			if ((object->oflags2 & 0x800000) && object->sfxFileHandle != 0)
			{
				aadFreeDynamicSfx(object->sfxFileHandle);
			}

			OBTABLE_RemoveObjectEntry(object);
			MEMPACK_Free((char*)object);

			objectTracker->objectStatus = 0;
		}
		if (object == NULL)
		{
			objectTracker->objectStatus = 0;
		}
	}
	else
	{
		objectTracker->objectStatus = 0;
	}
}

int STREAM_IsObjectInAnyUnit(struct _ObjectTracker* tracker)  // Matching - 100%
{
	int d;
	unsigned char* objlist;

	for (d = 0; d < 16; d++)
	{
		if (StreamTracker.StreamList[d].used == 2 && StreamTracker.StreamList[d].level != NULL)
		{
			objlist = (unsigned char*)StreamTracker.StreamList[d].level->objectNameList;

			while (objlist[0] != 255)
			{
#if defined(PSXPC_VERSION)
				if (_strcmpi(&tracker->name[0], (char*)objlist) == 0)
#else
				if (strcmpi(&tracker->name[0], (char*)objlist) == 0)
#endif
				{
					return 1;
				}

				objlist += 16;
			}
		}
	}

	return 0;
}

void STREAM_RemoveAllObjectsNotInUse()  // Matching - 100%
{
	int i;
	int abort;
	struct _ObjectTracker* tracker;
	struct _ObjectTracker* trackerList;

	trackerList = gameTrackerX.GlobalObjects;

	for (tracker = trackerList, i = 0; i < 0x30; i++, tracker++)
	{
		struct Object* object;

		if (tracker->objectStatus == 2 && (object = tracker->object, (object->oflags & 0x2000000U) == 0) &&
			!STREAM_IsObjectInAnyUnit(tracker) && !STREAM_IsAnInstanceUsingObject(object))
		{
			tracker->objectStatus = 3;
		}
	}

	do
	{
		abort = 1;
		for (tracker = trackerList, i = 0; i < 0x30; i++, tracker++)
		{
			if (tracker->objectStatus == 3)
			{
				int j;

				for (j = 0; j < (signed char)tracker->numObjectsUsing; j++)
				{
					if (trackerList[(signed char)tracker->objectsUsing[j]].objectStatus != 3)
					{
						tracker->objectStatus = 2;
						abort = 0;
						break;
					}
				}
			}
		}
	} while (!abort);

	for (tracker = trackerList, i = 0; i < 0x30; i++, tracker++)
	{
		if (tracker->objectStatus == 3)
		{
			int j;
			struct _ObjectTracker* otr;

			for (otr = trackerList, j = 0; j < 0x30; j++, otr++)
			{
				if ((unsigned short)(otr->objectStatus - 1) < 2 || (signed short)(otr->objectStatus) == 4)
				{
					int k;

					for (k = 0; k < (signed char)otr->numObjectsUsing; k++)
					{
						if ((signed char)otr->objectsUsing[k] == i)
						{
							int l;

							otr->numObjectsUsing--;

							for (l = k; l < (signed char)otr->numObjectsUsing; l++)
							{
								otr->objectsUsing[l] = otr->objectsUsing[l + 1];
							}

							break;
						}
					}
				}
			}

			STREAM_DumpObject(tracker);
		}
	}

	for (tracker = trackerList, i = 0; i < 0x30; i++, tracker++)
	{
		if (tracker->objectStatus == 1 && !STREAM_IsObjectInAnyUnit(tracker) && (signed char)tracker->numObjectsUsing == 0)
		{
			STREAM_DumpObject(tracker);
		}
	}
}

void RemoveAllObjects(struct GameTracker* gameTracker)  // Matching - 100%
{
	int i;
	struct _ObjectTracker* tracker;

	for (i = 0, tracker = &gameTracker->GlobalObjects[i]; i < 48; i++, tracker++)
	{
		if (tracker->objectStatus != 0)
		{
			STREAM_DumpObject(tracker);
		}
	}
}

struct Level* STREAM_GetLevelWithID(long id)  // Matching - 100%
{
	struct Level* retLevel;
	long i;

	retLevel = NULL;

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 2)
		{
			if (StreamTracker.StreamList[i].StreamUnitID == id)
			{
				retLevel = StreamTracker.StreamList[i].level;
				break;
			}
		}
	}

	return retLevel;
}

struct _StreamUnit* STREAM_GetStreamUnitWithID(long id)  // Matching - 100%
{
	struct _StreamUnit* retUnit;
	long i;

	retUnit = NULL;
	
	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 2)
		{
			if (StreamTracker.StreamList[i].StreamUnitID == id)
			{
				retUnit = &StreamTracker.StreamList[i];
				break;
			}
		}
	}

	return retUnit;
}

void STREAM_CalculateWaterLevel(struct Level* level)//Matching - 100%
{
	struct _Terrain* terrain;
	int i;
	struct _TFace* tface;
	long waterZLevel;

	waterZLevel = -32767;

	if (level->waterZLevel == 0)
	{
		if ((level->unitFlags & 0x1))
		{
			level->waterZLevel = 32767;
		}
		else
		{
			terrain = level->terrain;

			tface = (struct _TFace*)terrain->faceList;

			for (i = terrain->numFaces; i > 0; i--, tface++)
			{
				if ((tface->attr & 8) != 0)
				{
					if (terrain->vertexList[tface->face.v0].vertex.z == terrain->vertexList[tface->face.v1].vertex.z &&
						terrain->vertexList[tface->face.v0].vertex.z == terrain->vertexList[tface->face.v2].vertex.z)
					{
						if (waterZLevel == -32767)
						{
							waterZLevel = terrain->vertexList[tface->face.v0].vertex.z;
						}
						else if (waterZLevel != terrain->vertexList[tface->face.v0].vertex.z)
						{
							break;
						}
					}

				}
			}
			if (waterZLevel == -32767)
			{
				level->waterZLevel = -32767;
			}
			else
			{
				level->waterZLevel = waterZLevel + level->terrain->BSPTreeArray[0].globalOffset.z;
			}
		}
	}
}

int STREAM_IsMorphInProgress()  // Matching - 100%
{
	return gameTrackerX.gameData.asmData.MorphTime != 1000;
}


long STREAM_GetWaterZLevel(struct Level* level, struct _Instance* instance)  // Matching - 100%
{
	int waterZLevel;

	if ((instance->flags2 & 0x8000000) != 0)
	{
		if (!(instance->object->oflags2 & 0x2000000) && gameTrackerX.gameData.asmData.MorphTime != 1000)
		{
			waterZLevel = level->waterZLevel;
		}
		else
		{
			waterZLevel = -32767;
		}
	}
	else
	{
		if (!(instance->object->oflags2 & 0x2000000) && gameTrackerX.gameData.asmData.MorphTime != 1000)
		{
			waterZLevel = -32767;
		}
		else
		{
			waterZLevel = level->waterZLevel;
		}
	}
	return waterZLevel;
}

void STREAM_SetMainFog(struct _StreamUnit* streamUnit)  // Matching - 100%
{
	struct Level* level;

	level = streamUnit->level;

	if (gameTrackerX.gameData.asmData.MorphType != 0)
	{
		streamUnit->UnitFogNear = level->spectralFogNear;
		streamUnit->UnitFogFar = level->spectralFogFar;
	}
	else
	{
		streamUnit->UnitFogNear = level->holdFogNear;
		streamUnit->UnitFogFar = level->holdFogFar;
	}

	streamUnit->TargetFogNear = streamUnit->UnitFogNear;
	streamUnit->TargetFogFar = streamUnit->UnitFogFar;
}

void STREAM_SetStreamFog(struct _StreamUnit* streamUnit, short fogNear, short fogFar)  // Matching - 100%
{
	short unitFogFar; 
	int unitFogHold;

	unitFogFar = FindStreamUnitFromLevel(gameTrackerX.level)->UnitFogFar;

	if (fogFar < unitFogFar)
	{
		unitFogFar = fogFar;
	}

	unitFogHold = unitFogFar - 2000;

	streamUnit->TargetFogFar = unitFogFar;
	streamUnit->UnitFogFar = unitFogFar;

	if (fogNear < unitFogHold)
	{
		unitFogHold = fogNear;
	}
	
	streamUnit->TargetFogNear = unitFogHold;
	streamUnit->UnitFogNear = unitFogHold;
}

void STREAM_ConnectStream(struct _StreamUnit* streamUnit)
{
	struct _StreamUnit* mainUnit;
	struct StreamUnitPortal* streamPortal;
	int numportals;
	struct StreamUnitPortal* streamPortal2;
	int numportals2;
	int i;
	int j;
	char text[16];
	char* commapos;
	int signalID;
	struct _StreamUnit* connectStream;
	struct _SVector offset;
	long d;
	long hookedUp;

	WARPGATE_UpdateAddToArray(streamUnit);

	if (gameTrackerX.StreamUnitID != streamUnit->StreamUnitID)
	{
		numportals2 = ((long*)streamUnit->level->terrain->StreamUnits)[0];
		streamPortal2 = (struct StreamUnitPortal*)((long*)streamUnit->level->terrain->StreamUnits + 1);

		mainUnit = STREAM_GetStreamUnitWithID(gameTrackerX.StreamUnitID);

		for (j = 0; j < numportals2; j++)
		{
			strcpy(text, streamPortal2[j].tolevelname);
			commapos = strchr(text, ',');
			signalID = 0;

			if (commapos != 0)
			{
				commapos[0] = 0;
				signalID = atoi(&commapos[1]);
			}

			connectStream = STREAM_GetStreamUnitWithID(streamPortal2[j].streamID);

			if (strcmpi(text, "warpgate") == 0 && WARPGATE_IsUnitWarpRoom(mainUnit))
			{
				connectStream = mainUnit;
			}

			streamPortal2[j].toStreamUnit = connectStream;

			if (connectStream != NULL && connectStream == mainUnit)
			{
				numportals = ((long*)mainUnit->level->terrain->StreamUnits)[0];
				streamPortal = (struct StreamUnitPortal*)((long*)mainUnit->level->terrain->StreamUnits + 1);

				for (i = 0; i < numportals; i++)
				{
					if (signalID == streamPortal[i].MSignalID)
					{
						offset.x = streamPortal[i].minx - streamPortal2[j].minx;
						offset.y = streamPortal[i].miny - streamPortal2[j].miny;
						offset.z = streamPortal[i].minz - streamPortal2[j].minz;

						RelocateLevel(streamUnit->level, &offset);
					}
				}
			}
		}

		connectStream = &StreamTracker.StreamList[0];

		for (d = 0; d < 16; d++)
		{
			if (StreamTracker.StreamList[d].used == 2 && connectStream != streamUnit)
			{
				numportals2 = ((long*)StreamTracker.StreamList[d].level->terrain->StreamUnits)[0];
				streamPortal2 = (struct StreamUnitPortal*)((long*)StreamTracker.StreamList[d].level->terrain->StreamUnits + 1);

				for (j = 0; j < numportals2; j++)
				{
					strcpy(text, streamPortal2->tolevelname);

					commapos = strchr(text, ',');

					hookedUp = 0;

					if (commapos != NULL)
					{
						commapos[0] = 0;

						signalID = atoi(&commapos[1]);
					}

					if (streamPortal2[j].streamID == streamUnit->StreamUnitID)
					{
						streamPortal2[j].toStreamUnit = streamUnit;
						hookedUp = 1;
					}
					else
					{
						if (strcmpi(text, "warpgate") == 0 && WARPGATE_IsUnitWarpRoom(streamUnit))
						{
							streamPortal2[j].toStreamUnit = streamUnit;
							hookedUp = 1;
						}
					}

					if (hookedUp == 1 && connectStream == mainUnit)
					{
						numportals = ((long*)streamUnit->level->terrain->StreamUnits)[0];

						streamPortal = (struct StreamUnitPortal*)((long*)streamUnit->level->terrain->StreamUnits + 1);

						for (i = 0; i < numportals; i++)
						{
							if (signalID == streamPortal[i].MSignalID)
							{
								offset.x = streamPortal2[j].minx - streamPortal[i].minx;
								offset.y = streamPortal2[j].miny - streamPortal[i].miny;
								offset.z = streamPortal2[j].minz - streamPortal[i].minz;

								RelocateLevel(streamUnit->level, &offset);
								break;
							}
						}
					}
				}
			}
		}

		for (i = 0; i < streamUnit->level->numIntros; i++)
		{
			if (strcmpi(streamUnit->level->introList[i].name, "raziel") == 0)
			{
				streamUnit->level->introList[i].flags |= 0x8;
				break;
			}
		}
	}
}
void STREAM_StreamLoadLevelAbort(void* loadData, void* data, void* data2)  // Matching - 100%
{
	struct _StreamUnit* streamUnit;

	streamUnit = (struct _StreamUnit*)data2;

	if (loadData != NULL)
	{
		MEMPACK_Free((char*)loadData);
	}

	streamUnit->level = NULL;
	streamUnit->used = 0;
	streamUnit->flags = 0;
}

void STREAM_DoObjectLoadAndDump(struct _StreamUnit* streamUnit)  // Matching - 100%
{
	int i;

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 1)
		{
			return;
		}
	}

	STREAM_RemoveAllObjectsNotInUse();
}

void STREAM_FinishLoad(struct _StreamUnit *streamUnit)
{
	struct Level *level;
	char sfxName[80];

	STREAM_FillOutFileNames(streamUnit->baseAreaName, NULL, NULL, sfxName);

	level = streamUnit->level;
	level->morphLastStep = -1;
	
	streamUnit->sfxFileHandle = 0;
	
	if (LOAD_DoesFileExist(sfxName) != 0)
	{
		streamUnit->sfxFileHandle = aadLoadDynamicSfx(streamUnit->baseAreaName, streamUnit->StreamUnitID, 1);
	}
	
	LoadLevelObjects(streamUnit);
	
	streamUnit->FogColor = (level->cpad1 << 24) | (level->backColorB << 16) | (level->backColorG << 8) | (level->backColorR);
	streamUnit->TargetFogFar = level->fogFar;
	streamUnit->TargetFogNear = level->fogNear;

	LIGHT_CalcDQPTable(level);
	
	STREAM_CalculateWaterLevel(level);

	if (gameTrackerX.gameData.asmData.MorphType == 1)
	{
		MORPH_UpdateNormals(level);
	}

	STREAM_ConnectStream(streamUnit);

	streamUnit->used = 2;

	STREAM_DoObjectLoadAndDump(streamUnit);

	EVENT_LoadEventsForLevel(streamUnit->StreamUnitID, level);
	
	PLANAPI_InitPlanMkrList(streamUnit);

	if (level->startUnitLoadedSignal != NULL)
	{
		level->startUnitLoadedSignal->flags |= 0x1;
		
		SIGNAL_HandleSignal(gameTrackerX.playerInstance, &level->startUnitLoadedSignal->signalList[0], 0);
		
		EVENT_AddSignalToReset(level->startUnitLoadedSignal);
	}

	SAVE_IntroForStreamID(streamUnit);
	SAVE_UpdateLevelWithSave(streamUnit);
	
	EVENT_AddStreamToInstanceList(streamUnit);
	
	WARPGATE_FixUnit(streamUnit);
}

void STREAM_LoadLevelReturn(void* loadData, void* data, void* data2)  // Matching - 100%
{
	GetRCnt(0xF2000000);
	gameTimer;

	((struct _StreamUnit*)data2)->StreamUnitID = ((struct Level*)loadData)->streamUnitID;

	gameTrackerX.StreamUnitID = ((struct Level*)loadData)->streamUnitID;
	gameTrackerX.level = (struct Level*)loadData;

	STREAM_SetMainFog(((struct _StreamUnit*)data2));
	STREAM_FinishLoad(((struct _StreamUnit*)data2));
}

void STREAM_StreamLoadLevelReturn(void* loadData, void* data, void* data2)  // Matching - 100%
{
	struct Level* level;
	struct _StreamUnit* streamUnit;

	GetRCnt(0xF2000000);
	gameTimer;

	level = (struct Level*)loadData;
	streamUnit = (struct _StreamUnit*)data2;
	streamUnit->StreamUnitID = level->streamUnitID;

	if (streamUnit->used == 3)
	{
		streamUnit->used = 0;
		streamUnit->flags = 0;

		MEMPACK_Free((char*)streamUnit->level);

		streamUnit->level = NULL;

		return;
	}

	if (gameTrackerX.gameData.asmData.MorphType != 0)
	{
		STREAM_SetStreamFog(streamUnit, level->spectralFogNear, level->spectralFogFar);
	}
	else
	{
		STREAM_SetStreamFog(streamUnit, level->holdFogNear, level->holdFogFar);
	}

	STREAM_FinishLoad(streamUnit);

	if (gameTrackerX.playerInstance != NULL && level->streamUnitID == gameTrackerX.playerInstance->currentStreamUnitID)
	{
		strcpy(gameTrackerX.baseAreaName, level->worldName);

		STREAM_SetMainFog(streamUnit);

		gameTrackerX.StreamUnitID = level->streamUnitID;
		gameTrackerX.level = level;
	}
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_UpdateLevelPointer(struct Level *oldLevel /*$a0*/, struct Level *newLevel /*$a1*/, long sizeOfLevel /*$a2*/)
void STREAM_UpdateLevelPointer(struct Level *oldLevel, struct Level *newLevel, long sizeOfLevel)
{ // line 1623, offset 0x80059e18
	/* begin block 1 */
		// Start line: 1624
		// Start offset: 0x80059E18
		// Variables:
			long i; // $t0
			long offset; // $t1
			struct GameTracker *gameTracker; // $v0

		/* begin block 1.1 */
			// Start line: 1652
			// Start offset: 0x80059E7C
			// Variables:
				struct _Instance *instance; // $a3
		/* end block 1.1 */
		// End offset: 0x8005A00C
		// End Line: 1692
	/* end block 1 */
	// End offset: 0x8005A0F0
	// End Line: 1714

	/* begin block 2 */
		// Start line: 3246
	/* end block 2 */
	// End Line: 3247
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _StreamUnit * /*$ra*/ STREAM_WhichUnitPointerIsIn(void *pointer /*$s3*/)
struct _StreamUnit * STREAM_WhichUnitPointerIsIn(void *pointer)
{ // line 1719, offset 0x8005a108
	/* begin block 1 */
		// Start line: 1720
		// Start offset: 0x8005A108
		// Variables:
			int i; // $s2
			int size; // $v1
			struct Level *level; // $s0
	/* end block 1 */
	// End offset: 0x8005A194
	// End Line: 1740

	/* begin block 2 */
		// Start line: 3981
	/* end block 2 */
	// End Line: 3982
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_UpdateObjectPointer(struct Object *oldObject /*$s2*/, struct Object *newObject /*$s3*/, long sizeOfObject /*$s4*/)
void STREAM_UpdateObjectPointer(struct Object *oldObject, struct Object *newObject, long sizeOfObject)
{ // line 1742, offset 0x8005a1b4
	/* begin block 1 */
		// Start line: 1743
		// Start offset: 0x8005A1B4
		// Variables:
			long i; // $a3
			long d; // $a1
			struct GameTracker *gameTracker; // $s0
			long offset; // $s1
			struct _ObjectTracker *otr; // $t0

		/* begin block 1.1 */
			// Start line: 1763
			// Start offset: 0x8005A208
			// Variables:
				int j; // $a1
				struct Object *object; // $a2
		/* end block 1.1 */
		// End offset: 0x8005A294
		// End Line: 1773

		/* begin block 1.2 */
			// Start line: 1791
			// Start offset: 0x8005A2F0
			// Variables:
				struct _Instance *instance; // $s0
		/* end block 1.2 */
		// End offset: 0x8005A408
		// End Line: 1820
	/* end block 1 */
	// End offset: 0x8005A434
	// End Line: 1828

	/* begin block 2 */
		// Start line: 4049
	/* end block 2 */
	// End Line: 4050
				UNIMPLEMENTED();
}

void STREAM_UpdateInstanceCollisionInfo(struct _HModel* oldHModel, struct _HModel* newHModel)  // Matching - 100%
{
	struct _Instance* instance;

	instance = gameTrackerX.instanceList->first;
	
	while (instance != NULL)
	{
		if (instance->hModelList == oldHModel)
		{
			instance->hModelList = newHModel;
		}

		instance = instance->next;
	}
}

void STREAM_LoadMainVram(struct GameTracker* gameTracker, char* baseAreaName, struct _StreamUnit* streamUnit)  // Matching - 100%
{
	char dramName[80];
	char vramName[80];
	struct VramBuffer* vramBuffer;
	struct Level* level;

	level = streamUnit->level;

	STREAM_FillOutFileNames(gameTracker->baseAreaName, dramName, vramName, NULL);

	vramBuffer = (struct VramBuffer*)MEMPACK_Malloc((level->vramSize.w << 1) + 20, 0x23);

	vramBuffer->lineOverFlow = (short*)(vramBuffer + 1);
	vramBuffer->flags = 0;
	vramBuffer->x = (level->vramSize.x) + SCREEN_WIDTH;
	vramBuffer->y = level->vramSize.y;
	vramBuffer->w = level->vramSize.w;
	vramBuffer->h = level->vramSize.h;

	M_TrackClutUpdate = 0;

	vramBuffer->yOffset = 0;
	vramBuffer->lengthOfLeftOverData = 0;

	LOAD_NonBlockingBufferedLoad(vramName, VRAM_TransferBufferToVram, vramBuffer, NULL);
}

void STREAM_MoveIntoNewStreamUnit()  // Matching - 100%
{
	gameTrackerX.playerInstance->cachedTFace = -1;
	gameTrackerX.playerInstance->cachedTFaceLevel = NULL;
	gameTrackerX.playerInstance->currentStreamUnitID = gameTrackerX.moveRazielToStreamID;

	INSTANCE_UpdateFamilyStreamUnitID(gameTrackerX.playerInstance);

	GAMELOOP_StreamLevelLoadAndInit(gameTrackerX.S_baseAreaName, &gameTrackerX, gameTrackerX.toSignal, gameTrackerX.fromSignal);

	gameTrackerX.SwitchToNewStreamUnit = 0;

	if (gameTrackerX.SwitchToNewWarpIndex != -1)
	{
		SndPlayVolPan(388, 127, 64, 0);
		CurrentWarpNumber = gameTrackerX.SwitchToNewWarpIndex;
	}
}

struct _StreamUnit* STREAM_LoadLevel(char* baseAreaName, struct StreamUnitPortal* streamPortal, int loadnext)  // Matching - 100%
{
	int i;
	long streamID;
	struct _StreamUnit* streamUnit;
	struct Level* level;
	char dramName[80];

	streamID = -1;

	if (streamPortal != NULL)
	{
		streamID = streamPortal->streamID;
	}

	for (i = 0; i < 16; i++)
	{
		streamUnit = &StreamTracker.StreamList[i];

		if (streamUnit->used != 0)
		{
#if defined(PSXPC_VERSION)
			if (_strcmpi(streamUnit->baseAreaName, baseAreaName) == 0)
#else
			if (strcmpi(streamUnit->baseAreaName, baseAreaName) == 0)
#endif
			{
				if (streamUnit->used == 3)
				{
					streamUnit->used = 1;
					break;
				}
				else if (streamUnit->used != 1)
				{
					streamUnit->FrameCount = 0;

					if (streamPortal == NULL)
					{
						strcpy(gameTrackerX.baseAreaName, baseAreaName);

						STREAM_SetMainFog(streamUnit);

						gameTrackerX.StreamUnitID = streamUnit->StreamUnitID;
						gameTrackerX.level = streamUnit->level;
					}
					else
					{
						level = streamUnit->level;

						STREAM_ConnectStream(streamUnit);

						if (gameTrackerX.gameData.asmData.MorphType != 0)
						{
							STREAM_SetStreamFog(streamUnit, (short)level->spectralFogNear, (short)level->spectralFogFar);
						}
						else
						{
							STREAM_SetStreamFog(streamUnit, (short)level->holdFogNear, (short)level->holdFogFar);
						}
					}
					break;

				}
				else
				{
					break;
				}
			}
		}
	}

	if (i == 16)
	{
		for (i = 0; i < 16; i++)
		{
			streamUnit = &StreamTracker.StreamList[i];

			if (streamUnit->used == 0)
			{
				STREAM_FillOutFileNames(baseAreaName, dramName, NULL, NULL);

				streamUnit->used = 1;

				strcpy(streamUnit->baseAreaName, baseAreaName);

				streamUnit->StreamUnitID = streamID;
				streamUnit->FrameCount = 0;
				streamUnit->flags = 0;

				if (streamPortal == NULL)
				{
					strcpy(gameTrackerX.baseAreaName, baseAreaName);

					gameTrackerX.StreamUnitID = streamUnit->StreamUnitID;

					LOAD_NonBlockingBinaryLoad(dramName, (void*)STREAM_LoadLevelReturn, NULL, streamUnit, (void**)&streamUnit->level, 2);

					break;
				}
				else
				{
					streamPortal->toStreamUnit = NULL;

					LOAD_NonBlockingBinaryLoad(dramName, (void*)STREAM_StreamLoadLevelReturn, NULL, streamUnit, (void**)&streamUnit->level, 2);

					break;
				}
			}
		}
	}

	return streamUnit;
}

void RemoveIntroducedLights(struct Level* level)  // Matching - 100%
{
	int i;

	LIGHT_Restore(gameTrackerX.lightInfo);

	gameTrackerX.lightInfo->numSavedColors = 0;

	for (i = 0; i < level->numSpotLights; i++)
	{
		if ((level->spotLightList[i].flags & 0x10))
		{
			LIST_DeleteFunc(&level->spotLightList[i].node);
		}
	}

	for (i = 0; i < level->numPointLights; i++)
	{
		if ((level->pointLightList[i].flags & 0x10))
		{
			LIST_DeleteFunc(&level->pointLightList[i].node);
		}
	}
}

void STREAM_RemoveInstancesWithIDInInstanceList(struct _InstanceList* list, long id, struct Level* level)  // Matching - 100%
{
	struct _Instance* instance;
	struct _Instance* next;

	instance = list->first;
	while (instance == next, instance != NULL)
	{
		next = instance->next;
		if (instance->currentStreamUnitID == id)
		{
			SAVE_Instance(instance, level);
			INSTANCE_ReallyRemoveInstance(list, instance, 0);
			instance = next;
		}
		else
		{
			if (instance->birthStreamUnitID == id)
			{
				SAVE_Instance(instance, level);
				instance->intro = NULL;
			}
			instance = next;
		}
	}
}

void STREAM_MarkUnitNeeded(long streamID)  // Matching - 100%
{
	int i;

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used != 0)
		{
			if (streamID == StreamTracker.StreamList[i].StreamUnitID)
			{
				StreamTracker.StreamList[i].FrameCount = gameTrackerX.displayFrameCount;
				return;
			}
		}
	}
}

void STREAM_DumpUnit(struct _StreamUnit* streamUnit, long doSave)
{
	int i;
	int j;
	int numportals;
	char dramName[80];
	struct _SFXMkr* sfxMkr;

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 2)
		{
			numportals = ((int*)StreamTracker.StreamList[i].level->terrain->StreamUnits)[0];

			for (j = 0; j < numportals; j++)
			{
				if (((struct StreamUnitPortal*)((int*)StreamTracker.StreamList[i].level->terrain->StreamUnits + 1))[j].toStreamUnit == streamUnit)
				{
					((struct StreamUnitPortal*)((int*)StreamTracker.StreamList[i].level->terrain->StreamUnits + 1))[j].toStreamUnit = NULL;
				}
			}
		}
	}
	
	if (streamUnit->used == 1 || streamUnit->used == 3)
	{
		STREAM_FillOutFileNames(streamUnit->baseAreaName, dramName, NULL, NULL);

		LOAD_AbortFileLoad(dramName, (void*)&STREAM_StreamLoadLevelAbort);

		streamUnit->used = 0;
	}

	if (WARPGATE_IsUnitWarpRoom(streamUnit))
	{
		WARPGATE_RemoveFromArray(streamUnit);
	}
	
	EVENT_RemoveStreamToInstanceList(streamUnit);

	for (i = 0; i < streamUnit->level->NumberOfSFXMarkers; i++)
	{
		sfxMkr = &streamUnit->level->SFXMarkerList[i];

		SOUND_EndInstanceSounds(sfxMkr->soundData, sfxMkr->sfxTbl);
	}
	
	if (streamUnit->sfxFileHandle != 0)
	{
		aadFreeDynamicSfx(streamUnit->sfxFileHandle);
	}

	PLANAPI_DeleteNodeFromPoolByUnit(streamUnit->StreamUnitID);

	STREAM_RemoveInstancesWithIDInInstanceList(gameTrackerX.instanceList, streamUnit->StreamUnitID, streamUnit->level);

	if (doSave != 0)
	{
		EVENT_SaveEventsFromLevel(streamUnit->StreamUnitID, streamUnit->level);
		SAVE_CreatedSavedLevel(streamUnit->StreamUnitID, streamUnit->level);
	}

	MEMPACK_Free((char*)streamUnit->level);

	streamUnit->level = NULL;
	streamUnit->used = 0;
	streamUnit->flags = 0;
}

void STREAM_DumpAllUnitsNotNeeded()  // Matching - 100%
{
	int i;

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used != 0 && StreamTracker.StreamList[i].FrameCount != gameTrackerX.displayFrameCount)
		{
			STREAM_DumpUnit(&StreamTracker.StreamList[i], 1);
		}
	}
}

void STREAM_DumpAllLevels(long IDNoRemove, int DoSave)  // Matching - 100%
{
	int i;

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used != 0 && StreamTracker.StreamList[i].StreamUnitID != IDNoRemove)
		{
			STREAM_DumpUnit(&StreamTracker.StreamList[i], DoSave);
		}
	}
}

void STREAM_LoadCurrentWarpRoom(struct StreamUnitPortal* streamPortal, struct _StreamUnit* mainStreamUnit)  // Matching - 100%
{
	if (strcmpi(mainStreamUnit->level->worldName, WarpRoomArray[CurrentWarpNumber].name) == 0)
	{
		WarpGateLoadInfo.loading = 3;
		WarpGateLoadInfo.curTime = WarpGateLoadInfo.maxTime;
	}

	WarpRoomArray[CurrentWarpNumber].streamUnit = STREAM_LoadLevel(WarpRoomArray[CurrentWarpNumber].name, streamPortal, 0);
	if (WarpRoomArray[CurrentWarpNumber].streamUnit != NULL)
	{
		streamPortal->toStreamUnit = WarpRoomArray[CurrentWarpNumber].streamUnit;
		WarpRoomArray[CurrentWarpNumber].streamUnit->flags |= 1;
	}
}

void WARPGATE_RelocateLoadedWarpRooms(struct _StreamUnit* mainUnit, struct StreamUnitPortal* streamPortal)  // Matching - 100%
{
	int i;

	for (i = 0; i < 16; i++)
	{
		if ((StreamTracker.StreamList[i].used == 2) && (&StreamTracker.StreamList[i] != mainUnit)
			&& (StreamTracker.StreamList[i].flags & 1) != 0)
		{
			STREAM_LoadLevel(StreamTracker.StreamList[i].baseAreaName, streamPortal, 0);
		}
	}
}

long WARPGATE_GetWarpRoomIndex(char* name)  // Matching - 100%
{
	int i;
	
	for (i = 0; i < 14; i++)
	{
		if (strcmpi(WarpRoomArray[i].name, name) == 0)
		{
			return i;
		}
	}

	return -1;
}

void WARPGATE_UpdateAddToArray(struct _StreamUnit* streamUnit)  // Matching - 100%
{
	int i;

	i = WARPGATE_GetWarpRoomIndex(streamUnit->baseAreaName);

	if (i != -1)
	{
		WarpRoomArray[i].streamUnit = streamUnit;
	}
}

void WARPGATE_RemoveFromArray(struct _StreamUnit* streamUnit)  // Matching - 100%
{
	if (WARPGATE_GetWarpRoomIndex(streamUnit->baseAreaName) == -1)
	{
		CurrentWarpNumber = 0;
	}
}

void WARPGATE_Init()  // Matching - 100%
{ 
	int n;
	
	WarpGateLoadInfo.fadeValue = 4096;
	WarpGateLoadInfo.warpgate_in_use = 0;
	WarpGateLoadInfo.loading = 0;
	WarpGateLoadInfo.blocked = 0;
	WarpGateLoadInfo.curTime = 0;
	WarpGateLoadInfo.maxTime = 61440;
	WarpGateLoadInfo.warpFaceInstance = NULL;

	CurrentWarpNumber = 0;

	for (n = 13; n >= 0; n--)
	{
		WarpRoomArray[n].streamUnit = NULL;
	}
}

void WARPGATE_StartUsingWarpgate()  // Matching - 100%
{
	if (WarpGateLoadInfo.warpgate_in_use == 0)
	{
		SndPlayVolPan(367, 127, 64, 0);
	}

	WarpGateLoadInfo.warpgate_in_use = 1;
}

void WARPGATE_EndUsingWarpgate()  // Matching - 100%
{
	if (WarpGateLoadInfo.warpgate_in_use == 1)
	{
		SndPlayVolPan(386, 127, 64, 0);
	}

	WarpGateLoadInfo.warpgate_in_use = 0;
}

int WARPGATE_IsWarpgateInUse()  // Matching - 100%
{
	return WarpGateLoadInfo.warpgate_in_use;
}

int WARPGATE_IsWarpgateActive()  // Matching - 100%
{
	return WarpGateLoadInfo.loading != 0;
}

int WARPGATE_IsWarpgateUsable()  // Matching - 100%
{
	return WarpGateLoadInfo.loading == 4 && WarpGateLoadInfo.blocked == 0;
}

int WARPGATE_IsWarpgateReady()  // Matching - 100%
{
	return WarpGateLoadInfo.loading == 4;
}

int WARPGATE_IsWarpgateSpectral()  // Matching - 100%
{
	return strcmpi(WarpRoomArray[CurrentWarpNumber].name, "under3") < 1U;
}


int WARPGATE_IsObjectOnWarpSide(struct _Instance* instance)  // Matching - 100%
{
	int side;
	int temp, temp2;  // not from SYMDUMP

	if (WarpGateLoadInfo.warpFaceInstance != NULL)
	{
		side = ~(WarpGateLoadInfo.warpFaceInstance->position.y - theCamera.core.position.y);
		temp = side < 0;
		temp2 = temp;
		if ((WarpGateLoadInfo.warpFaceInstance->position.y - instance->position.y) < 0)
		{
			if (temp == 1)
			{
				return 1;
			}
		}
		else if (temp2 == 0)
		{
			return 1;
		}
	}
	return 0;
}

void WARPGATE_IsItActive(struct _StreamUnit *streamUnit)
{
	struct Level *level;
	int d;

	level = streamUnit->level;
	streamUnit->flags |= 0x1;

	if (level->PuzzleInstances != NULL && level->PuzzleInstances->numPuzzles > 0)
	{
		for (d = 0; d < level->PuzzleInstances->numPuzzles; d++)
		{
			if (level->PuzzleInstances->eventInstances[d]->eventNumber == 1)
			{
				if ((gameTrackerX.streamFlags & 0x400000))
				{
					level->PuzzleInstances->eventInstances[d]->eventVariables[0] = level->PuzzleInstances->eventInstances[d]->eventNumber;
				}

				if (level->PuzzleInstances->eventInstances[d]->eventVariables[0] != level->PuzzleInstances->eventInstances[d]->eventNumber)
				{
					return;
				}

				streamUnit->flags |= 0x8;
				return;
			}
		}
	}

	return;
}

long WARPGATE_IsUnitWarpRoom(struct _StreamUnit* streamUnit)  // Matching - 100%
{
	struct Level* level;
	long isWarpRoom;
	struct StreamUnitPortal* streamPortal;
	long numPortals;
	long d;

	level = streamUnit->level;

	isWarpRoom = 0;

	numPortals = ((long*)level->terrain->StreamUnits)[0];  // cast needs revalidating

	streamPortal = (struct StreamUnitPortal*)((long*)level->terrain->StreamUnits + 1);  // cast needs revalidating

	for (d = 0; d < numPortals; d++, streamPortal++)
	{
		if ((streamPortal->flags & 0x1))
		{
			isWarpRoom = 1;
		}
	}

	return isWarpRoom;
}

void WARPGATE_FixUnit(struct _StreamUnit *streamUnit)  // Matching - 100%
{ 
	if (WARPGATE_IsUnitWarpRoom(streamUnit) != 0)
	{
		WARPGATE_IsItActive(streamUnit);
	}
}

void STREAM_MarkWarpUnitsNeeded()  // Matching - 100%
{
	int i;

	for(i = 0; i < 16; i++)
	{
		if ((StreamTracker.StreamList[i].flags & 0x1))
		{
			StreamTracker.StreamList[i].FrameCount = gameTrackerX.displayFrameCount;
		}
	}
}

long WARPGATE_IncrementIndex()
{
	long result;
	
	result = 1;

	if (WarpGateLoadInfo.loading == 4)
	{
		SndPlayVolPan(387, 127, 64, 0);

		WarpGateLoadInfo.loading = 1;
		WarpGateLoadInfo.curTime = 0;
		WarpGateLoadInfo.warpFaceInstance->fadeValue = 4096;
		WarpGateLoadInfo.warpFaceInstance = NULL;

		WarpRoomArray[CurrentWarpNumber].streamUnit->StreamUnitID = 0;

		CurrentWarpNumber = (CurrentWarpNumber + 1) % 14;

		if (strcmpi(gameTrackerX.baseAreaName, WarpRoomArray->name) == 0)
		{
			CurrentWarpNumber = (CurrentWarpNumber + 1) % 14;
		}

		hud_warp_arrow_flash = -8192;
	}
	
	return result;
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_CalcWarpFade(int timeInc /*$a0*/)
void WARPGATE_CalcWarpFade(int timeInc)
{ // line 2615, offset 0x8005b320
	/* begin block 1 */
		// Start line: 6175
	/* end block 1 */
	// End Line: 6176

	/* begin block 2 */
		// Start line: 6176
	/* end block 2 */
	// End Line: 6177
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// long /*$ra*/ WARPGATE_DecrementIndex()
long WARPGATE_DecrementIndex()
{ // line 2624, offset 0x8005b390
	/* begin block 1 */
		// Start line: 2625
		// Start offset: 0x8005B390
		// Variables:
			long result; // $s0
	/* end block 1 */
	// End offset: 0x8005B454
	// End Line: 2652

	/* begin block 2 */
		// Start line: 6194
	/* end block 2 */
	// End Line: 6195
			UNIMPLEMENTED();
	return 0;
}

void PreloadAllConnectedUnits(struct _StreamUnit* streamUnit, struct _SVector* offset)
{
	int i;
	char text[16];
	int numportals;
	char* commapos;
	struct StreamUnitPortal* stream;

	gameTrackerX.displayFrameCount += 1;

	numportals = ((long*)streamUnit->level->terrain->StreamUnits)[0];

	for (i = 0; i < numportals; i++)
	{
		stream = (struct StreamUnitPortal*)((long*)streamUnit->level->terrain->StreamUnits + 1) + i;

		strcpy(text, stream->tolevelname);

		commapos = strchr(text, ',');

		if (commapos != NULL)
		{
			commapos[0] = 0;
		}
		
		if (strcmpi(text, "warpgate") == 0)
		{
			STREAM_MarkWarpUnitsNeeded();
		}
		else
		{
			STREAM_MarkUnitNeeded(stream->streamID);
		}
	}

	STREAM_MarkUnitNeeded(streamUnit->StreamUnitID);

	STREAM_DumpAllUnitsNotNeeded();

	RelocateLevelWithInstances(streamUnit->level, offset);

	MEMPACK_DoGarbageCollection();

	numportals = ((long*)streamUnit->level->terrain->StreamUnits)[0];

	for (i = 0; i < numportals; i++)
	{
		stream = (struct StreamUnitPortal*)((long*)streamUnit->level->terrain->StreamUnits + 1) + i;

		strcpy(text, stream->tolevelname);

		commapos = strchr(text, ',');

		if (commapos != NULL)
		{
			commapos[0] = 0;

			if (strcmpi(text, "warpgate") == 0)
			{
				stream->toStreamUnit = NULL;

				streamUnit->fromSignal |= 0x1;

				WARPGATE_RelocateLoadedWarpRooms(streamUnit, stream);
			}
			else
			{
				STREAM_LoadLevel(text, stream, 1);
			}
		}
	}
}

void RelocateLevel(struct Level* level, struct _SVector* offset)  // Matching - 100%
{
	int curTree;
	short _x0;
	short _y0;
	short _z0;
	short _x1;
	short _y1;
	short _z1;
	struct _Position* _v;

	RelocateTerrain(level->terrain, offset);

	RelocateVMObjects(level->vmobjectList, level->numVMObjects, offset);

	RelocateBGObjects(level->bgObjectList, level->numBGObjects, offset);

	RelocateCameras((struct _CameraKey*)level->cameraList, level->numCameras, offset);

	RelocateSavedCameras(&theCamera, level, offset);

	level->deathZ += offset->z;

	RelocatePlanMarkers(level->PlanMarkerList, level->NumberOfPlanMarkers, offset);

	RelocateSFXMarkers(level->SFXMarkerList, level->NumberOfSFXMarkers, offset);

	if (level->waterZLevel != -32767 && level->waterZLevel != 32767)
	{
		level->waterZLevel += offset->z;
	}

	for (curTree = 0; curTree < level->terrain->numBSPTrees; curTree++)
	{
		_v = &level->terrain->BSPTreeArray[curTree].globalOffset;

		_x0 = _v->x;
		_y0 = _v->y;
		_z0 = _v->z;

		_x1 = offset->x;
		_y1 = offset->y;
		_z1 = offset->z;

		_x0 += _x1;
		_y0 += _y1;
		_z0 += _z1;

		_v->x = _x0;
		_v->y = _y0;
		_v->z = _z0;
	}
}

void RelocateCameras(struct _CameraKey* cameraList, long numCameras, struct _SVector* offset)  // Matching - 100%
{
	int i;
	
	for (i = 0; i < numCameras; i++)
	{
		cameraList[i].x += offset->x;
		cameraList[i].y += offset->y;
		cameraList[i].z += offset->z;

		cameraList[i].tx += offset->x;
		cameraList[i].ty += offset->y;
		cameraList[i].tz += offset->z;
	}
}

void RelocateSavedCameras(struct Camera* camera, struct Level* level, struct _SVector* offset)
{
	int i;
	short _x0;
	short _y0;
	short _z0;
	short _x1;
	short _y1;
	short _z1;
	struct _Position* _v;

	if (camera->stack >= 0)
	{
		for (i = 0; camera->stack >= i; i++)
		{
			if (camera->savedMode[i] == 5 && camera->savedCinematic[i].level == level)
			{
				_v = &camera->savedCinematic[i].position;

				_x1 = offset->x;
				_y1 = offset->y;
				_z1 = offset->z;

				_x0 = _v->x;
				_y0 = _v->y;
				_z0 = _v->z;

				_v->x = _x0 + _x1;
				_v->y = _y0 + _y1;
				_v->z = _z0 + _z1;

				_v = &camera->savedCinematic[i].focusPoint;

				_x0 = _v->x;
				_y0 = _v->y;
				_z0 = _v->z;

				_x1 = offset->x;
				_y1 = offset->y;
				_z1 = offset->z;

				_v->x = _x0 + _x1;
				_v->y = _y0 + _y1;
				_v->z = _z0 + _z1;

				_v = &camera->savedCinematic[i].targetPos;

				_x0 = _v->x;
				_y0 = _v->y;
				_z0 = _v->z;

				_x1 = offset->x;
				_y1 = offset->y;
				_z1 = offset->z;

				_v->x = _x0 + _x1;
				_v->y = _y0 + _y1;
				_v->z = _z0 + _z1;

				_v = &camera->savedCinematic[i].targetFocusPoint;

				_x0 = _v->x;
				_y0 = _v->y;
				_z0 = _v->z;

				_x1 = offset->x;
				_y1 = offset->y;
				_z1 = offset->z;

				_v->x = _x0 + _x1;
				_v->y = _y0 + _y1;
				_v->z = _z0 + _z1;
			}
		}
	}
}

void RelocateLevelWithInstances(struct Level *level, struct _SVector *offset)  // Matching - 100%
{
	RelocateLevel(level, offset);

	RelocateInstances(offset);

	RelocatePlanPool((struct PlanningNode*)gameTrackerX.planningPool, offset);
}

void RelocateTerrain(struct _Terrain* terrain, struct _SVector* offset)  // Matching - 100%
{
	int i;

	for (i = 0; i < terrain->numIntros; i++)
	{
		terrain->introList[i].position.x += offset->x;
		terrain->introList[i].position.y += offset->y;
		terrain->introList[i].position.z += offset->z;

		if (terrain->introList[i].multiSpline != NULL)
		{
			STREAM_AdjustMultiSpline(terrain->introList[i].multiSpline, offset);
		}
	}

	RelocateStreamPortals((struct StreamUnitPortal*)((long*)terrain->StreamUnits + 1), ((long*)terrain->StreamUnits)[0], offset);  // cast needs revalidating
}

void RelocateVMObjects(struct _VMObject* vobjectlist, long numvmobjs, struct _SVector* offset)  // Matching - 100%
{
	int i;

	for (i = 0; i < numvmobjs; i++)
	{
		vobjectlist[i].position.x += offset->x;
		vobjectlist[i].position.y += offset->y;
		vobjectlist[i].position.z += offset->z;
	}
}

void RelocateBGObjects(struct _BGObject* BGObjList, long numBGObjs, struct _SVector* offset)
{
	int i;
	int d;

	for (i = 0; i < numBGObjs; i++)
	{
		for (d = 0; d < BGObjList->numVertices; d++)
		{
			BGObjList[i].vertexList[d].x += offset->x;
			BGObjList[i].vertexList[d].y += offset->y;
			BGObjList[i].vertexList[d].z += offset->z;
		}
	}
}

void RelocatePlanPool(struct PlanningNode* planPool, struct _SVector* offset)//Matching - 99.78%
{
	int i;
	short ox;
	short oy;
	short oz;

	ox = offset->x;
	oy = offset->y;
	oz = offset->z;

	for (i = PLANAPI_NumNodesInPool(planPool); i != 0; i--, planPool++)
	{
		planPool->pos.x += ox;
		planPool->pos.y += oy;
		planPool->pos.z += oz;
	}

	poolManagementData->playerPosAtLastPlanMkrUpdate.x += ox;
	poolManagementData->playerPosAtLastPlanMkrUpdate.y += oy;
	poolManagementData->playerPosAtLastPlanMkrUpdate.z += oz;
}

void RelocatePlanMarkers(struct _PlanMkr* planMkrList, int numPlanMkrs, struct _SVector* offset)
{ 
	int i;
	short ox;
	short oy;
	short oz;

	ox = offset->x;
	oy = offset->y;
	oz = offset->z;

	for (i = 0; i < numPlanMkrs; i++)
	{
		planMkrList[i].pos.x += ox;
		planMkrList[i].pos.y += oy;
		planMkrList[i].pos.z += oz;
	}
}

void RelocateSFXMarkers(struct _SFXMkr* sfxMkrList, int numSFXMkrs, struct _SVector* offset)
{
	int i;
	short ox;
	short oy;
	short oz;

	ox = offset->x;
	oy = offset->y;
	oz = offset->z;

	for (i = 0; i != numSFXMkrs; i++)
	{
		sfxMkrList[i].pos.x += ox;
		sfxMkrList[i].pos.y += oy;
		sfxMkrList[i].pos.z += oz;
	}
}

void STREAM_AdjustMultiSpline(struct MultiSpline* multi, struct _SVector* offset)
{
	int i;

	if (multi->positional != NULL && multi->positional->numkeys > 0)
	{
		for (i = 0; i < multi->positional->numkeys; i++)
		{
			multi->positional->key[i].point.x += offset->x;
			multi->positional->key[i].point.y += offset->y;
			multi->positional->key[i].point.z += offset->z;
		}
	}
}

void STREAM_RelocateInstance(struct _Instance* instance, struct _SVector* offset)  // Matching - 100%
{
	STREAM_OffsetInstancePosition(instance, offset, 1);

	INSTANCE_Post(instance, 0x100008, (uintptr_t)offset);
}

void STREAM_OffsetInstancePosition(struct _Instance* instance, struct _SVector* offset, int streamSignalFlag)  // Matching - 100%
{
	instance->position.x += offset->x;
	instance->position.y += offset->y;
	instance->position.z += offset->z;

	instance->oldPos.x += offset->x;
	instance->oldPos.y += offset->y;
	instance->oldPos.z += offset->z;

	instance->shadowPosition.x += offset->x;
	instance->shadowPosition.y += offset->y;
	instance->shadowPosition.z += offset->z;

	COLLIDE_UpdateAllTransforms(instance, (SVECTOR*)offset);
	COLLIDE_MoveAllTransforms(instance, (struct _Position*)offset);

	if (instance == theCamera.focusInstance)
	{
		CAMERA_Relocate(&theCamera, offset, streamSignalFlag);
	}
}

void STREAM_SetInstancePosition(struct _Instance* instance, struct evPositionData* data)  // Matching - 100%
{
	struct _SVector offset;

	offset.x = data->x - instance->position.x;
	offset.y = data->y - instance->position.y;
	offset.z = data->z - instance->position.z;

	STREAM_OffsetInstancePosition(instance, &offset, 0);
}

void RelocateInstances(struct _SVector* offset)  // Matching - 100%
{
	struct _Instance* instance;

	instance = gameTrackerX.instanceList->first;

	while (instance != NULL)
	{
		STREAM_RelocateInstance(instance, offset);

		instance = instance->next;
	}

	FX_Relocate(offset);
}

void RelocateStreamPortals(struct StreamUnitPortal* StreamUnitList, int NumStreamUnits, struct _SVector* offset)  // Matching - 100%
{
	int i;
	int d;

	for (i = 0; i < NumStreamUnits; i++)
	{
		StreamUnitList[i].maxx += offset->x;
		StreamUnitList[i].maxy += offset->y;
		StreamUnitList[i].maxz += offset->z;

		StreamUnitList[i].minx += offset->x;
		StreamUnitList[i].miny += offset->y;
		StreamUnitList[i].minz += offset->z;

		for (d = 0; d < 3; d++)
		{
			StreamUnitList[i].t1[d].x += offset->x;
			StreamUnitList[i].t1[d].y += offset->y;
			StreamUnitList[i].t1[d].z += offset->z;
		}

		for (d = 0; d < 3; d++)
		{
			StreamUnitList[i].t2[d].x += offset->x;
			StreamUnitList[i].t2[d].y += offset->y;
			StreamUnitList[i].t2[d].z += offset->z;
		}
	}
}

void STREAM_PackVRAMObject(struct _ObjectTracker* objectTracker)  // Matching - 100%
{
	struct VramSize* vramSize;
	struct VramBuffer* vramBuffer;
	char fileName[64];
	struct _BlockVramEntry* vramBlock;

	vramSize = &objectTracker->object->vramSize;

	if (vramSize->x != -1 && VRAM_GetObjectVramSpace(vramSize, objectTracker) != 0)
	{
		vramBlock = (struct _BlockVramEntry*)objectTracker->vramBlock;

		if (vramBlock != NULL)
		{
			AdjustVramCoordsObject(SCREEN_WIDTH, 0, vramBlock->x, vramBlock->y, objectTracker->object);
		}

		sprintf(fileName, "\\kain2\\object\\%s\\%s.crm", objectTracker->name, objectTracker->name);

		vramBuffer = (struct VramBuffer*)MEMPACK_Malloc((vramBlock->w << 1) + sizeof(struct VramBuffer), 0x23);

		vramBuffer->lineOverFlow = (short*)(vramBuffer + 1);
		vramBuffer->flags = 0;
		vramBuffer->x = vramBlock->x;
		vramBuffer->y = vramBlock->y;
		vramBuffer->w = vramBlock->w;
		vramBuffer->h = vramBlock->h;
		vramBuffer->yOffset = 0;
		vramBuffer->lengthOfLeftOverData = 0;

		LOAD_NonBlockingBufferedLoad(fileName, (void*)VRAM_TransferBufferToVram, vramBuffer, objectTracker);
	}
	else
	{
		objectTracker->vramBlock = NULL;
	}
}

void MORPH_SetupInstanceFlags(struct _Instance *instance)
{ 
	if (!(instance->object->oflags & 0x80000))
	{
		if (gameTrackerX.gameData.asmData.MorphType == 0)
		{
			if (!(instance->flags2 & 0x8000000))
			{
				instance->flags2 &= 0xEFFFFFFF;
				instance->flags2 &= 0xFBFFFFFF;
				return;
			}
		}
		else
		{
			instance->flags2 &= 0xEFFFFFFF;
			instance->flags2 &= 0xFBFFFFFF;
			return;
		}

		instance->flags2 &= 0x10000000;

		if (MEMPACK_MemoryValidFunc((char*)instance->data) != 0)
		{
			if (!(instance->object->oflags2 & 0x2000000) && instance->LinkParent != NULL && !(instance->LinkParent->object->oflags2 & 0x2000000))
			{
				return;
			}

			INSTANCE_Post(instance, 0x40026, 0);

			instance->flags2 |= 0x4000000;
		}
	}
}

void MORPH_SetupInstanceListFlags()
{
	struct _Instance* instance;

	instance = gameTrackerX.instanceList->first;

	while (instance != NULL)
	{
		MORPH_SetupInstanceFlags(instance);

		instance = instance->next;
	}
}

void MORPH_InMorphInstanceListFlags() // Matching - 99.81%
{ 
	struct _Instance* instance;
	instance = gameTrackerX.instanceList->first;
	while (instance != 0)
	{
		if ((instance->flags2 & 0x4000000) != 0)
		{
			instance->flags2 &= 0xEFFFFFFF;
		}
		instance->flags2 &= 0xFBFFFFFF;
		instance = instance->next;
	}
}

void MORPH_InMorphDoFadeValues()//Matching - 94.35%
{
	int fade1;
	int fade2;

	fade1 = ((gameTrackerX.gameData.asmData.MorphTime) << 12) / 1000;
	fade2 = 4096 - fade1;

	if (gameTrackerX.gameData.asmData.MorphType == 0)
	{
		gameTrackerX.spectral_fadeValue = fade1;
		gameTrackerX.material_fadeValue = fade2;
	}
	else
	{

		gameTrackerX.spectral_fadeValue = fade2;
		gameTrackerX.material_fadeValue = fade1;
	}
}

void MORPH_UpdateTimeMult()
{
	short ratio;

	if (gameTrackerX.gameData.asmData.MorphTime != 1000)
	{
		ratio = gameTrackerX.gameData.asmData.MorphTime - 750;

		if (gameTrackerX.gameData.asmData.MorphType != 0)
		{
			if (ratio < 0)
			{
				ratio = 0;
			}
		}
		else 
		{
			if (ratio >= 251)
			{
				ratio = 250;
			}

			ratio = 250 - ratio;
		}

		gameTrackerX.materialTimeMult = (gameTrackerX.globalTimeMult * (((ratio * 65536) / 4000) - (((ratio * 65536) >> 4) >> 0x1F)) * 16) >> 16;
	
		if (gameTrackerX.materialTimeMult == 0)
		{
			gameTrackerX.materialTimeMult = 1;
		}

		if (gameTrackerX.gameData.asmData.MorphType == 0)
		{
			ratio = gameTrackerX.gameData.asmData.MorphTime - 750;

			if (ratio < 0)
			{
				ratio = 0;
			}
		}
		else
		{
			if (ratio >= 251)
			{
				ratio = 250;
			}

			ratio = 250 - ratio;
		}

		gameTrackerX.spectralTimeMult = (gameTrackerX.globalTimeMult * (((ratio * 65536) / 4000) - (((ratio * 65536) >> 4) >> 0x1F)) * 16) >> 16;
		
		if (gameTrackerX.spectralTimeMult == 0)
		{
			gameTrackerX.spectralTimeMult = 1;
		}
	}
	else
	{
		if (gameTrackerX.gameData.asmData.MorphType == 0)
		{
			gameTrackerX.spectralTimeMult = 0;
			gameTrackerX.materialTimeMult = gameTrackerX.globalTimeMult;
		}
		else
		{
			gameTrackerX.materialTimeMult = 0;
			gameTrackerX.spectralTimeMult = gameTrackerX.globalTimeMult;
		}
	}
}

void MORPH_UpdateNormals(struct Level* BaseLevel)//Matching - 93.33%
{
	SVECTOR realDiff; // stack offset -32
	struct _Position oldPos; // stack offset -24
	struct _TFace* face; // $v1
	long faceCount; // $a2
	struct _TVertex* v; // $a1
	struct _MorphVertex* mv; // $a3
	struct _MorphColor* mc; // $a0
	short h1; // $v1
	short* morphNormals; // $a1
	struct _TVertex* endv; // $a2
	struct _BSPNode* node; // $v1
	struct _BSPLeaf* leaf; // $a1
	struct _Sphere_noSq hsphere; // stack offset -32
	struct _BoundingBox hbox; // stack offset -24
	struct _Terrain* terrain; // $a0
	long curTree; // $t0
	struct _Instance* instance; // $s0
	struct Intro* intro;

	morphNormals = BaseLevel->terrain->morphNormalIdx;
	faceCount = BaseLevel->terrain->numFaces;
	face = BaseLevel->terrain->faceList;
	while (faceCount > 0)
	{
		h1 = face->normal;
		face->normal = *morphNormals;
		*morphNormals++ = h1;
		face++;
		faceCount--;
	}

	terrain = BaseLevel->terrain;
	mv = terrain->MorphDiffList;

	if (BaseLevel->terrain->MorphDiffList != NULL)
	{
		for (; mv->vindex >= 0; mv++)
		{
			v = &BaseLevel->terrain->vertexList[mv->vindex];

			v->vertex.x = mv->hx + mv->x;
			v->vertex.y = mv->hy + mv->y;
			v->vertex.z = mv->hz + mv->z;
		}
	}
	mc = BaseLevel->terrain->MorphColorList;

	if (mc)
	{
		endv = &BaseLevel->terrain->vertexList[BaseLevel->terrain->numVertices];

		v = BaseLevel->terrain->vertexList;

		while (v < endv)
		{
			v->r0 = ((unsigned short)mc->morphColor15 & 0x1F) << 3;
			v->g0 = ((unsigned short)mc->morphColor15 >> 2) & 0xF8;
			v->b0 = ((unsigned short)mc->morphColor15 >> 7) & 0xF8;

			v++;
			mc++;
		}
	}

	for (curTree = 0; curTree < BaseLevel->terrain->numBSPTrees; curTree++)
	{
		node = BaseLevel->terrain->BSPTreeArray[curTree].bspRoot;

		while (node < (struct _BSPNode*)BaseLevel->terrain->BSPTreeArray[curTree].startLeaves)
		{
			hsphere = node->sphere;
			node->sphere = node->spectralSphere;
			node->spectralSphere = hsphere;
			node++;
		}

		leaf = BaseLevel->terrain->BSPTreeArray[curTree].startLeaves;
		while (leaf < BaseLevel->terrain->BSPTreeArray[curTree].endLeaves)
		{
			hsphere = leaf->sphere;
			leaf->sphere = leaf->spectralSphere;
			leaf->spectralSphere = hsphere;

			hbox = leaf->spectralBox;
			leaf->box = leaf->spectralBox;
			leaf->spectralBox = hbox;
			leaf++;
		}
	}

	instance = gameTrackerX.instanceList->first;

	for (; instance; instance = instance->next)
	{
		intro = instance->intro;

		if (intro && (*(unsigned int*)&intro->spectralPosition.x || intro->spectralPosition.z) && (!(instance->flags2 & 0x8)))
		{
			oldPos = instance->position;

			instance->position.x = intro->position.x + intro->spectralPosition.x;
			instance->position.y = intro->position.y + intro->spectralPosition.y;
			instance->position.z = intro->position.z + intro->spectralPosition.z;

			realDiff.vx = instance->position.x - oldPos.x;
			realDiff.vy = instance->position.y - oldPos.y;
			realDiff.vz = instance->position.z - oldPos.z;

			if (realDiff.vx + realDiff.vy + realDiff.vz)
			{
				COLLIDE_UpdateAllTransforms(instance, &realDiff);
			}
		}
	}
}

void MORPH_BringBackNormals(struct Level* BaseLevel)  // Matching - 100%
{
	struct _TFace* face;
	long faceCount;
	struct _TVertex* v;
	struct _MorphVertex* mv;
	struct _MorphColor* mc;
	short h1;
	short* morphNormals;

	face = (struct _TFace*)&BaseLevel->terrain->faceList->normal;
	faceCount = BaseLevel->terrain->numFaces;
	morphNormals = BaseLevel->terrain->morphNormalIdx;

	for (; faceCount > 0; )
	{
		h1 = face->face.v0;
		face->face.v0 = *morphNormals;
		*morphNormals = h1;
		morphNormals++;
		face++;
		faceCount--;
	}

	mv = BaseLevel->terrain->MorphDiffList;

	if (mv != NULL)
	{
		while (-1 < mv->vindex)
		{
			v = &BaseLevel->terrain->vertexList[mv->vindex];
			(v->vertex).x = mv->hx;
			(v->vertex).y = mv->hy;
			(v->vertex).z = mv->hz;
			mv++;
		}
	}

	mc = BaseLevel->terrain->MorphColorList;

	if (mc != NULL)
	{
		struct _TVertex* endv;

		endv = &BaseLevel->terrain->vertexList[BaseLevel->terrain->numVertices];

		for (v = BaseLevel->terrain->vertexList; v < endv; v++)
		{
			v->r0 = (v->rgb15 & 0x1f) << 3;
			v->g0 = (v->rgb15 >> 2) & 0xf8;
			v->b0 = (v->rgb15 >> 7) & 0xf8;
		}
	}

	{
		struct _BSPNode* node;
		struct _BSPLeaf* leaf;
		struct _Sphere_noSq hsphere;
		struct _BoundingBox hbox;
		struct _Terrain* terrain;
		long curTree;

		terrain = BaseLevel->terrain;

		for (curTree = 0; curTree < terrain->numBSPTrees; curTree++)
		{
			node = terrain->BSPTreeArray[curTree].bspRoot;

			for (; (struct _BSPLeaf*)node < terrain->BSPTreeArray[curTree].startLeaves; node++)
			{
				hsphere = node->sphere;
				node->sphere = node->spectralSphere;
				node->spectralSphere = hsphere;
			}

			leaf = terrain->BSPTreeArray[curTree].startLeaves;

			for (; leaf < terrain->BSPTreeArray[curTree].endLeaves; leaf++)
			{
				hsphere = leaf->sphere;
				leaf->sphere = leaf->spectralSphere;
				leaf->spectralSphere = hsphere;
				hbox = leaf->box;
				leaf->box = leaf->spectralBox;
				leaf->spectralBox = hbox;
			}
		}
	}

	{
		struct _Instance* instance;

		for (instance = gameTrackerX.instanceList->first; instance != NULL; instance = instance->next)
		{
			if (instance->intro != NULL)
			{
				SVECTOR realDiff;
				struct _Position oldPos;
				struct Intro* temp;  // not from SYMDUMP

				temp = instance->intro;

				if ((temp->spectralPosition.x != 0 || temp->spectralPosition.y != 0 || temp->spectralPosition.z != 0) && (!(instance->flags2 & 8)))
				{
					oldPos = instance->position;
					instance->position.x = temp->position.x;
					instance->position.y = temp->position.y;
					instance->position.z = temp->position.z;
					realDiff.vx = instance->position.x - oldPos.x;
					realDiff.vy = instance->position.y - oldPos.y;
					realDiff.vz = instance->position.z - oldPos.z;
					if (realDiff.vx + realDiff.vy + realDiff.vz != 0)
					{
						COLLIDE_UpdateAllTransforms(instance, &realDiff);
					}
				}
			}
		}
	}

	return;
}

void MORPH_AddOffsets(struct Level* BaseLevel, int time)//Matching - 98.67%
{
	struct _TVertex* v;
	struct _MorphVertex* mv;
	struct _MorphColor* mc;
	long m;
	long fixed_time;
	struct _Instance* instance;
	SVECTOR diff;
	SVECTOR realDiff;
	struct _Position oldPos;
	long r0;
	long g0;
	long b0;
	long r1;
	long g1;
	long b1;
	struct _TVertex* endv;
	struct Intro* intro;

	instance = gameTrackerX.instanceList->first;

	if (time < 501)
	{
		time = time * 2 * time * 2 * time / 2000000;
	}
	else
	{
		time = 1000 - (1000 - time) * 2 * (1000 - time) * 2 * (1000 - time) / 2000000;
	}

	mv = BaseLevel->terrain->MorphDiffList;
	fixed_time = (time << 12) / 1000;

	if (BaseLevel->terrain->MorphDiffList != NULL)
	{
		for (; mv->vindex >= 0; mv++)
		{
			v = &BaseLevel->terrain->vertexList[mv->vindex];

			v->vertex.x = (short)(mv->hx + ((mv->x * fixed_time) >> 12));
			v->vertex.y = (short)(mv->hy + ((mv->y * fixed_time) >> 12));
			v->vertex.z = (short)(mv->hz + ((mv->z * fixed_time) >> 12));
		}
	}
	for (; instance; instance = instance->next)
	{
		intro = instance->intro;

		if (intro && (*(unsigned int*)&intro->spectralPosition.x || intro->spectralPosition.z) && ((instance->flags2 & 0x8)) == 0)
		{
			diff.vx = (short)((intro->spectralPosition.x * fixed_time) >> 12);
			diff.vy = (short)((intro->spectralPosition.y * fixed_time) >> 12);
			diff.vz = (short)((intro->spectralPosition.z * fixed_time) >> 12);

			oldPos = instance->position;

			instance->position.x = intro->position.x + oldPos.x;
			instance->position.y = intro->position.y + oldPos.y;
			instance->position.z = intro->position.z + oldPos.z;

			realDiff.vx = instance->position.x - oldPos.x;
			realDiff.vy = instance->position.y - oldPos.y;
			realDiff.vz = instance->position.z - oldPos.z;

			if (realDiff.vx + realDiff.vy + realDiff.vz)
			{
				COLLIDE_UpdateAllTransforms(instance, &realDiff);
			}
		}
	}

	mc = BaseLevel->terrain->MorphColorList;

	if (mc)
	{
		v = BaseLevel->terrain->vertexList;
		endv = &BaseLevel->terrain->vertexList[BaseLevel->terrain->numVertices];

		while (v < endv)
		{
			r0 = (v->rgb15 & 0x1F) << 3;
			r1 = (mc->morphColor15 & 0x1F) << 3;

			g0 = (v->rgb15 >> 2) & 0xF8;
			g1 = (mc->morphColor15 >> 2) & 0xF8;

			b0 = (v->rgb15 >> 7) & 0xF8;
			b1 = (mc->morphColor15 >> 7) & 0xF8;

			v->r0 = (unsigned char)(r0 + (((r1 - r0) * fixed_time) >> 12));
			v->g0 = (unsigned char)(g0 + (((g1 - g0) * fixed_time) >> 12));
			v->b0 = (unsigned char)(b0 + (((b1 - b0) * fixed_time) >> 12));

			v++;
			mc++;
		}
	}
}

void MORPH_SubtractOffsets(struct Level* BaseLevel, int time)//Matching - 98.68%
{
	struct _TVertex* v;
	struct _MorphVertex* mv;
	struct _MorphColor* mc;
	long m;
	long fixed_time;
	struct _Instance* instance;
	SVECTOR diff;
	SVECTOR realDiff;
	struct _Position oldPos;
	long r0;
	long g0;
	long b0;
	long r1;
	long g1;
	long b1;
	struct _TVertex* endv;
	struct Intro* intro;

	instance = gameTrackerX.instanceList->first;

	if (time < 501)
	{
		time = time * 2 * time * 2 * time / 2000000;
	}
	else
	{
		time = 1000 - (1000 - time) * 2 * (1000 - time) * 2 * (1000 - time) / 2000000;
	}

	mv = BaseLevel->terrain->MorphDiffList;
	fixed_time = ((1000 - time) << 12) / 1000;

	if (BaseLevel->terrain->MorphDiffList != NULL)
	{
		for (; mv->vindex >= 0; mv++)
		{
			v = &BaseLevel->terrain->vertexList[mv->vindex];

			v->vertex.x = (short)(mv->hx + ((mv->x * fixed_time) >> 12));
			v->vertex.y = (short)(mv->hy + ((mv->y * fixed_time) >> 12));
			v->vertex.z = (short)(mv->hz + ((mv->z * fixed_time) >> 12));
		}
	}

	for (; instance; instance = instance->next)
	{
		intro = instance->intro;

		if (intro && (*(unsigned int*)&intro->spectralPosition.x || intro->spectralPosition.z) && ((instance->flags2 & 0x8)) == 0)
		{
			diff.vx = (short)((intro->spectralPosition.x * fixed_time) >> 12);
			diff.vy = (short)((intro->spectralPosition.y * fixed_time) >> 12);
			diff.vz = (short)((intro->spectralPosition.z * fixed_time) >> 12);

			oldPos = instance->position;

			instance->position.x = intro->position.x + oldPos.x;
			instance->position.y = intro->position.y + oldPos.y;
			instance->position.z = intro->position.z + oldPos.z;

			realDiff.vx = instance->position.x - oldPos.x;
			realDiff.vy = instance->position.y - oldPos.y;
			realDiff.vz = instance->position.z - oldPos.z;

			if (realDiff.vx + realDiff.vy + realDiff.vz)
			{
				COLLIDE_UpdateAllTransforms(instance, &realDiff);
			}
		}
	}

	mc = BaseLevel->terrain->MorphColorList;

	if (mc)
	{
		v = BaseLevel->terrain->vertexList;
		endv = &BaseLevel->terrain->vertexList[BaseLevel->terrain->numVertices];

		while (v < endv)
		{
			r0 = (v->rgb15 & 0x1F) << 3;
			r1 = (mc->morphColor15 & 0x1F) << 3;

			g0 = (v->rgb15 >> 2) & 0xF8;
			g1 = (mc->morphColor15 >> 2) & 0xF8;

			b0 = (v->rgb15 >> 7) & 0xF8;
			b1 = (mc->morphColor15 >> 7) & 0xF8;

			v->r0 = (unsigned char)(r0 + (((r1 - r0) * fixed_time) >> 12));
			v->g0 = (unsigned char)(g0 + (((g1 - g0) * fixed_time) >> 12));
			v->b0 = (unsigned char)(b0 + (((b1 - b0) * fixed_time) >> 12));

			v++;
			mc++;
		}
	}
}

void MORPH_GetComponentsForTrackingPoint(struct _TFace* face, struct Level* level)
{
	struct _SVector* v[3];
	struct _Position* offset;
	struct _Position player;
	int n;
	int saved_div;
	int next;
	int side;
	int track;
	int x[2];
	struct _TVertex* vertexList;
	short _x0;
	short _y0;
	short _z0;
	short _x1;
	short _y1;
	short _z1;
	struct _Position* _v;
	struct _Position* _v0;
	int div;

	MORPH_SavedFace = face;
	MORPH_SavedLevel = level;

	if (face != NULL && level != NULL)
	{
		vertexList = level->terrain->vertexList;
		
		v[0] = (struct _SVector*)&vertexList[face->face.v0].vertex;
		v[1] = (struct _SVector*)&vertexList[face->face.v1].vertex;
		v[2] = (struct _SVector*)&vertexList[face->face.v2].vertex;

		_v0 = &gameTrackerX.playerInstance->position;
		
		offset = &level->terrain->BSPTreeArray[gameTrackerX.playerInstance->bspTree].globalOffset;

		_x0 = _v0->x;
		_y0 = _v0->y;
		_z0 = _v0->z;

		_x1 = offset->x;
		_y1 = offset->y;
		_z1 = offset->z;

		_v = &player;

		_v->x = _x0 - _x1;
		_v->y = _y0 - _y1;
		_v->z = _z0 - _z1;

		for(track = 0; track < 2; track++)
		{
			saved_div = 0;
			side = 0;

			for (n = 0; n < 3; n++)
			{
				next = n + 1;

				if (next >= 3)
				{
					next = 0;
				}

				if (track != 1 || n != MORPH_Track[0])
				{
					_v = (struct _Position*)v[0];

					if (player.y < _v->y || v[next]->y < player.y)
					{
						if (player.y >= v[next]->y || _v->y >= player.y)
						{
							if (ABS(saved_div) < ABS(v[next]->y - v[n]->y))
							{
								saved_div = v[next]->y - v[n]->y;
								side = n;
							}
						}
					}
					else
					{
						if (ABS(saved_div) < ABS(v[next]->y - v[n]->y))
						{
							saved_div = v[next]->y - v[n]->y;
							side = n;
						}
					}
				}
			}

			MORPH_Track[track] = side;

			div = side + 1;
			
			if (div >= 3)
			{
				div = 0;
			}

			if (saved_div != 0)
			{
				_v = (struct _Position*)v[side];

				MORPH_Component[track] = ((player.y - _v->y) << 12) / saved_div;
			}
			else
			{
				MORPH_Component[track] = 0;
			}

			div = MORPH_Component[track] * (v[div]->x - v[side]->x);
			
			if (div < 0)
			{
				div += 4095;
			}
			
			x[track] = v[side]->x + (div >> 12);
		}

		if (x[0] != x[1])
		{
			MORPH_Component[2] = ((player.x - x[0]) << 12) / (x[1] - x[0]);
		}
		else
		{
			MORPH_Component[2] = 0;
		}
	}
}

void MORPH_AveragePoint(struct _SVector* start, struct _SVector* end, int interp, struct _SVector* out)
{
	if (interp >= 0)
	{
		if (interp >= 4097)
		{
			interp = 4096;
		}

		LoadAverageShort12((SVECTOR*)start, (SVECTOR*)end, 4096 - interp, interp, (SVECTOR*)out);
	}
	else
	{
		if (interp < -4096)
		{
			interp = -4096;
		}

		LoadAverageShort12((SVECTOR*)end, (SVECTOR*)start, interp + 4096, -interp, (SVECTOR*)out);
	}
}

void MORPH_UpdateTrackingPoint(struct _TFace* face, struct Level* level)
{
	struct _SVector* v[3];
	struct _SVector p1;
	struct _SVector p2;
	struct _SVector p3;
	struct _Position* offset;
	int next;
	struct _TVertex* vertexList;
	short _x0;
	short _y0;
	short _z0;
	short _x1;
	short _y1;
	short _z1;
	struct _Position* _v0;

	if (face != NULL && level != NULL)
	{
		vertexList = level->terrain->vertexList;

		v[0] = (struct _SVector*)&vertexList[face->face.v0];
		v[1] = (struct _SVector*)&vertexList[face->face.v1];
		v[2] = (struct _SVector*)&vertexList[face->face.v2];

		next = MORPH_Track[0] + 1;

		if (next >= 3)
		{
			next = 0;
		}

		MORPH_AveragePoint(v[MORPH_Track[0]], v[next], MORPH_Component[0], &p1);

		next = MORPH_Track[1] + 1;

		if (next >= 3)
		{
			next = 0;
		}

		MORPH_AveragePoint(v[MORPH_Track[1]], v[next], MORPH_Component[1], &p2);

		MORPH_AveragePoint(&p1, &p2, MORPH_Component[2], &p3);

		_z0 = p3.z;
		_y0 = p3.y;
		_x0 = p3.x;

		offset = &level->terrain->BSPTreeArray[gameTrackerX.playerInstance->bspTree].globalOffset;

		_x1 = offset->x;
		_y1 = offset->y;
		_z1 = offset->z;

		_x0 += _x1;
		_y0 += _y1;
		_z0 += _z1;

		p3.x = _x0;
		p3.y = _y0;
		p3.z = _z0;

		_v0 = &gameTrackerX.playerInstance->position;

		_v0->x = _x0;
		_v0->y = _y0;
		_v0->z = _z0;

		gameTrackerX.playerInstance->cachedTFace = -1;

		gameTrackerX.playerInstance->cachedBSPTree = 0;
	}
}

void MORPH_ToggleMorph()
{
	struct Level* level;
	int i;

	SOUND_PlaneShift(gameTrackerX.gameData.asmData.MorphType == 0);

	INSTANCE_Broadcast(NULL, 10, 0x1000020, gameTrackerX.gameData.asmData.MorphType);

	MORPH_GetComponentsForTrackingPoint(gameTrackerX.playerInstance->tface, (struct Level*)gameTrackerX.playerInstance->tfaceLevel);
	
	MORPH_UpdateTrackingPoint(gameTrackerX.playerInstance->tface, (struct Level*)gameTrackerX.playerInstance->tfaceLevel);

	gameTrackerX.gameData.asmData.MorphTime = 0;

	SOUND_Play3dSound(&gameTrackerX.playerInstance->position, 26, -350, 127, 32767);

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 2)
		{
			level = StreamTracker.StreamList[i].level;

			if (gameTrackerX.gameData.asmData.MorphType == 1)
			{
				if (level->materialSignal != NULL)
				{
					level->materialSignal->flags |= 0x1;

					SIGNAL_HandleSignal(gameTrackerX.playerInstance, &level->materialSignal->signalList[0], 8);
					EVENT_AddSignalToReset(level->materialSignal);
				}
			}
			else
			{
				if (level->spectralSignal != NULL)
				{
					level->spectralSignal->flags |= 0x1;

					SIGNAL_HandleSignal(gameTrackerX.playerInstance, &level->spectralSignal->signalList[0], 8);
					EVENT_AddSignalToReset(level->spectralSignal);
				}
			}
		}
	}
}

void MORPH_DoStep(struct _StreamUnit* streamUnit, char* baseAreaName)//Matching - 98.73%
{
	struct Level* level;

	GAMEPAD_Shock1(64, 61440);

	level = streamUnit->level;

	if (level->terrain->MorphDiffList != NULL)
	{
		VM_UpdateMorph(level, 0);

		if (gameTrackerX.gameData.asmData.MorphTime == 1000)
		{
			if (gameTrackerX.gameData.asmData.MorphType == 0)
			{
				gameTrackerX.gameData.asmData.MorphType ^= 0x1;
				
				MORPH_UpdateNormals(level);
			}
			else
			{
				gameTrackerX.gameData.asmData.MorphType ^= 0x1;

				MORPH_BringBackNormals(level);
			}

			gameTrackerX.gameData.asmData.MorphType ^= 0x1;
			
			level->morphLastStep = -1;
		}
		else if (gameTrackerX.gameData.asmData.MorphType == 0)
		{
			MORPH_AddOffsets(level, gameTrackerX.gameData.asmData.MorphTime);
		}
		else
		{
			MORPH_SubtractOffsets(level, gameTrackerX.gameData.asmData.MorphTime);
		}
	}
}

void MORPH_SetFog(struct _StreamUnit* streamUnit, int mainUnitFlag)//Matching - 97.87%
{
	long time;
	struct Level* level;
	int fogNear;
	int fogFar;

	time = (gameTrackerX.gameData.asmData.MorphTime << 12) / 1000;
	level = streamUnit->level;

	if (gameTrackerX.gameData.asmData.MorphType == 0)
	{
		time = 4096 - time;
	}

	fogNear = (level->holdFogNear - level->spectralFogNear) * time / 4096 + level->spectralFogNear;
	fogFar = (level->holdFogFar - level->spectralFogFar) * time / 4096 + level->spectralFogFar;

	if (mainUnitFlag != 0)
	{
		streamUnit->UnitFogNear = fogNear;
		streamUnit->TargetFogNear = fogNear;
		streamUnit->UnitFogFar = fogFar;
		streamUnit->TargetFogFar = fogFar;
	}
	else
	{
		STREAM_SetStreamFog(streamUnit, (short)fogNear, (short)fogFar);
	}
}

void MORPH_UpdateTextures()//Matching - 95%
{
	int time;

	time = (gameTrackerX.gameData.asmData.MorphTime << 12) / 1000;
	
	if (gameTrackerX.gameData.asmData.MorphType == 1)
	{
		time = 4096 - time;
	}

	MORPH_ChangeAreaPalettes(time);
}

void MORPH_Continue()
{
	int i;
	long mode;

	if (gameTrackerX.gameData.asmData.MorphTime == 0)
	{
		MORPH_InMorphInstanceListFlags();
	}

	gameTrackerX.gameData.asmData.MorphTime += 20;

	MORPH_InMorphDoFadeValues();

	for (i = 0; i < 16; i++)
	{
		if (StreamTracker.StreamList[i].used == 2)
		{
			MORPH_DoStep(&StreamTracker.StreamList[i], StreamTracker.StreamList[i].baseAreaName);

			MORPH_SetFog(&StreamTracker.StreamList[i], 0);
		}
	}

	mode = INSTANCE_Query(gameTrackerX.playerInstance, 0xA);

	if (gameTrackerX.playerInstance->tface != NULL && mode >= 0)
	{
		if (gameTrackerX.playerInstance->tface == MORPH_SavedFace)
		{
			MORPH_UpdateTrackingPoint(MORPH_SavedFace, MORPH_SavedLevel);
		}
		else
		{
			MORPH_GetComponentsForTrackingPoint(gameTrackerX.playerInstance->tface, (struct Level*)gameTrackerX.playerInstance->tfaceLevel);
	
			MORPH_UpdateTrackingPoint(gameTrackerX.playerInstance->tface, (struct Level*)gameTrackerX.playerInstance->tfaceLevel);
		}
	}

	MORPH_UpdateTextures();

	if (gameTrackerX.gameData.asmData.MorphTime == 1000)
	{
		gameTrackerX.gameData.asmData.MorphType ^= 0x1;

		if (gameTrackerX.gameData.asmData.MorphType == 0)
		{
			gameTrackerX.playerInstance->flags2 &= 0xF7FFFFFF;
		}
		else
		{
			gameTrackerX.playerInstance->flags2 |= 0x8000000;
		}

		MORPH_SetupInstanceListFlags();
	}
}

void STREAM_MORPH_Relocate()
{
	MORPH_SavedFace = NULL;

	MORPH_SavedLevel = NULL;
}

int AddVertex(VECTOR* v0, PSX_RECT* rect)
{
	SVECTOR v;
	int x;
	int y;
	int z;
	int scr_x;
	int scr_y;

	if (v0->vx < 0)
	{
		v0->vx += -32768;
	}
	else if (v0->vx > 0)
	{
		v0->vx += 32768;
	}

	if (v0->vy < 0)
	{
		v0->vy += -32768;
	}
	else if (v0->vy > 0)
	{
		v0->vy += 32768;
	}

	if (v0->vz < 0)
	{
		v0->vz += -32768;
	}
	else if (v0->vz > 0)
	{
		v0->vz += 32768;
	}

	v.vx = ((SVECTOR*)&v0->vx)->vy;
	v.vy = ((SVECTOR*)&v0->vy)->vy;
	v.vz = ((SVECTOR*)&v0->vz)->vy;

	gte_ldv0(&v);
	gte_rt();
	gte_stsv(&v);

	if (v.vz > 0)
	{
		x = v.vx;
		y = v.vy;
		z = v.vz;

		scr_x = (((x * 320) / z)) + (SCREEN_WIDTH / 2);
		scr_y = (((y * 320) / z)) + (SCREEN_HEIGHT / 2);

		rect->x = (rect->x < scr_x) ? rect->x : scr_x;
		rect->w = (scr_x < rect->w) ? rect->w : scr_x;

		rect->y = (rect->y < scr_y) ? rect->y : scr_y;
		rect->h = (scr_y < rect->h) ? rect->h : scr_y;

		return z;
	}
	
	return -1;
}

int GetPlaneDist(int k, int j, int i, VECTOR* v)//Matching - 100%
{
	return (((v->vx >> 12) - (theCamera.core.position.x << 4)) * theCamera.core.vvNormalWorVecMat[k].m[j][0]) + 
		   (((v->vy >> 12) - (theCamera.core.position.y << 4)) * theCamera.core.vvNormalWorVecMat[k].m[j][1]) + 
		   (((v->vz >> 12) - (theCamera.core.position.z << 4)) * theCamera.core.vvNormalWorVecMat[k].m[j][2]) ;
}

void CalcVert(VECTOR *v, VECTOR *v1, VECTOR *v2, int dist1, int dist2, int k, int j)
{ 
	int diff;

	diff = (dist1 - dist2) >> 12;

	v->vx = (((v2->vx - v1->vx) >> 12) * (dist2 / diff)) + v2->vx;

	v->vy = (((v2->vy - v1->vy) >> 12) * (dist2 / diff)) + v2->vy;

	v->vz = (((v2->vz - v1->vz) >> 12) * (dist2 / diff)) + v2->vz;
}

int AddClippedTri(SVECTOR* iv, PSX_RECT* cliprect, int *minz)
{
	int clip0;
	int clip1;
	int i;
	int j;
	int k;
	int l;
	int l_1;
	int numvert;
	int newnumvert;
	VECTOR v0[16];
	VECTOR v1[16];
	VECTOR* src;
	VECTOR* dst;
	VECTOR* tmp;
	int z;

	minz[0] = 65535;
	
	src = &v0[0];
	dst = &v1[0];

	for (i = 0; i < 3; i++)
	{
		src[i].vx = iv[i].vx << 16;

		src[i].vy = iv[i].vy << 16;

		src[i].vz = iv[i].vz << 16;
	}

	numvert = 3;
	i = 0;
	j = 0;

	do
	{
		j = i;

		if (i >= 3)
		{
			j = i - 3;
			k = 1;
		}
		else
		{
			k = 0;
		}


		clip0 = GetPlaneDist(k, j, i, src);
		l_1 = 1;
		newnumvert = 0;
		l = 0;

		if (numvert > 0)
		{

			do
			{
				if (l_1 >= numvert)
				{
					l_1 = 0;
				}

				clip1 = GetPlaneDist(k, j, i, &src[l_1]);

				if (clip0 > 0)
				{
					if (clip1 <= 0)
					{
						dst[l].vx = src[l].vx;
						dst[l].vy = src[l].vy;
						dst[l].vz = src[l].vz;
						dst[l].pad = src[l].pad;

						CalcVert(&dst[l + 1], &src[l_1], &src[l], clip1, clip0, k, j);
					
						newnumvert++;
					}
					else
					{
						dst[l].vx = src[l].vx;
						dst[l].vy = src[l].vy;
						dst[l].vz = src[l].vz;
						dst[l].pad = src[l].pad;

						newnumvert++;
					}
				}
				else
				{
					if (clip1 > 0)
					{
						CalcVert(&dst[l], &src[l], &src[l_1], clip0, clip1, k, j);

						newnumvert++;
					}
				}

				clip0 = clip1;
				l++;
				l_1++;

			} while (l < numvert);
		}
		
		tmp = dst;
		numvert = newnumvert;
		dst = src;
		src = tmp;

		if (numvert < 3)
		{
			return (0 < numvert);
		}

		i++;

	} while (i < 5);

	if (numvert > 0)
	{
		for (i = 0; i < numvert; i++)
		{
			z = AddVertex(&src[i], cliprect);

			if (z < minz[0])
			{
				minz[0] = z;
			}
		}
	}
	
	return 1;
}

int STREAM_GetClipRect(struct StreamUnitPortal* portal, PSX_RECT* rect)//Matching - 83.29%
{
	int v1x;
	int v1y;
	int v1z;
	int v2x;
	int v2y;
	int v2z;
	int nx;
	int ny;
	int nz;
	int nx2;
	int ny2;
	int nz2;
	int len;
	int side;
	int side2;
	int retval;
	int horizontal_flag;
	int fullscreen_flag;
	int minz;
	int minz2;
	int dot;

	fullscreen_flag = 0;
	horizontal_flag = 0;

	if (portal->t1[0].z == portal->t1[1].z)
	{
		horizontal_flag = (portal->t1[0].z == portal->t1[2].z);
	}

	v1y = portal->t1[0].y - portal->t1[1].y;
	v2z = portal->t1[0].z - portal->t1[2].z;
	v1z = portal->t1[0].z - portal->t1[1].z;
	v2y = portal->t1[0].y - portal->t1[2].y;
	v1x = portal->t1[0].x - portal->t1[1].x;
	v2x = portal->t1[0].x - portal->t1[2].x;

	nx = ((v1y * v2z) - (v2y * v1z)) >> 12;
	ny = ((v2x * v1z) - (v1x * v2z)) >> 12;
	nz = ((v1x * v2y) - (v2x * v1y)) >> 12;

	side = -(((portal->t1[0].x - theCamera.core.position.x) * nx) + ((portal->t1[0].y - theCamera.core.position.y) * ny) + ((portal->t1[0].z - theCamera.core.position.z) * nz));

	len = MATH3D_FastSqrt((nx * nx) + (ny * ny) + (nz * nz));

	if (ABS(side) < len)
	{
		v1y = portal->t2[0].y - portal->t2[1].y;
		v2z = portal->t2[0].z - portal->t2[2].z;
		v1z = portal->t2[0].z - portal->t2[1].z;
		v2y = portal->t2[0].y - portal->t2[1].y;
		v2x = portal->t2[0].x - portal->t2[2].x;
		v1x = portal->t2[0].x - portal->t2[1].x;

		nx2 = ((v1y * v2z) - (v2y * v1z)) >> 12;
		ny2 = ((v2x * v1z) - (v1x * v2z)) >> 12;
		nz2 = ((v1x * v2y) - (v2x * v1y)) >> 12;

		side2 = -(((portal->t2[0].x - theCamera.core.position.x) * nx2) + ((portal->t2[0].y - theCamera.core.position.y) * ny2) + ((portal->t2[0].z - theCamera.core.position.z) * nz2));

		MATH3D_FastSqrt((nx2 * nx2) + (ny2 * ny2) + (nz2 * nz2));

		if (side < side2)
		{
			side = side2;
			nx = nx2;
			ny = ny2;
			nz = nz2;
		}
	}

	if (memcmp(portal->tolevelname, "warpgate", sizeof("warpgate") - 1) != 0)
	{
		if (ABS(side) < len)
		{
			dot = -((((theCamera.focusInstance->matrix + 1)->t[0] - theCamera.core.position.x) * nx) + (((theCamera.focusInstance->matrix + 1)->t[1] - theCamera.core.position.y) * ny) + (((theCamera.focusInstance->matrix + 1)->t[2] - theCamera.core.position.z) * nz));

			if (dot > 0 && horizontal_flag == 0)
			{
				fullscreen_flag = 1;
			}
		}
	}

	if (side < -1024)
	{
		if (fullscreen_flag == 0)
		{
			return 0;
		}
	}

	rect->w += rect->x;
	rect->h += rect->y;

	gte_SetRotMatrix(theCamera.core.wcTransform);
	gte_SetTransMatrix(theCamera.core.wcTransform);

	retval = AddClippedTri((SVECTOR*)&portal->t1[0], rect, &minz);
	retval |= AddClippedTri((SVECTOR*)&portal->t2[0], rect, &minz2);

	if (retval == 0)
	{
		rect->w -= rect->x;
		rect->h -= rect->y;

		return 0;
	}
	else
	{
		if (minz2 < minz)
		{
			minz = minz2;
		}

		if (fullscreen_flag != 0)
		{
			if (minz < 64)
			{
				rect->x = 0;
				rect->y = 0;
				rect->w = SCREEN_WIDTH;
				rect->h = SCREEN_HEIGHT;

				return 1;
			}
		}

		if (rect->x < 0)
		{
			rect->x = 0;
		}

		if (rect->y < 0)
		{
			rect->y = 0;
		}

		if (rect->w >= 513)
		{
			rect->w = SCREEN_WIDTH;
		}

		if (rect->h >= 241)
		{
			rect->h = SCREEN_HEIGHT;
		}

		rect->w -= rect->x;
		rect->h -= rect->y;

		if (horizontal_flag != 0)
		{
			side = ABS(side);

			if (side < len)
			{
				if (nz > 0)
				{
					rect->h = SCREEN_HEIGHT - rect->y;
				}
				else
				{
					rect->h = rect->y + rect->h;
					rect->y = 0;
				}
			}
		}

		if (rect->w > 0)
		{
			return (0 < rect->h);
		}
	}

	return 0;
}

long GetFogColor(struct StreamUnitPortal* portal, struct _StreamUnit* mainStreamUnit, struct Level* mainLevel)
{
	long z1;
	long z2;
	long z3;
	long zval;
	long zval2;
	long interp;
	long Color;
	long MainColor;
	long LevelColor;
	struct Level* level;
	int time;

	MainColor = mainStreamUnit->FogColor;

	level = portal->toStreamUnit->level;

	if (gameTrackerX.gameData.asmData.MorphTime != 1000)
	{
		time = (gameTrackerX.gameData.asmData.MorphTime << 12) / 1000;

		if (gameTrackerX.gameData.asmData.MorphType == 1)
		{
			time = 4096 - time;
		}

		LoadAverageCol(&level->specturalColorR, &level->backColorR, time, 4096 - time, (unsigned char*)&LevelColor);

		LevelColor &= 0xFFFFFF;
	}
	else
	{
		if (gameTrackerX.gameData.asmData.MorphType == 1)
		{
			LevelColor = ((int*)&level->specturalColorR)[0];
		}
		else
		{
			LevelColor = ((int*)&level->backColorR)[0];
		}
	}

	gte_ldv0(&portal->t1[0]);
	gte_ldv1(&portal->t1[1]);
	gte_ldv2(&portal->t1[2]);

	gte_rtpt();

	gte_stsz3(&z1, &z2, &z3);

	if (z2 < z1)
	{
		zval = z3;

		if (z3 < z1)
		{
			zval = z1;
		}
	}
	else
	{
		zval = z3;

		if (z3 < z2)
		{
			zval = z2;
		}
	}

	gte_ldv0(&portal->t2[0]);
	gte_ldv1(&portal->t2[1]);
	gte_ldv2(&portal->t2[2]);

	gte_rtpt();

	gte_stsz3(&z1, &z2, &z3);

	if (z2 < z1)
	{
		zval2 = z3;

		if (z3 < z1)
		{
			zval2 = z1;
		}
	}
	else
	{
		zval2 = z3;

		if (z3 < z2)
		{
			zval2 = z2;
		}
	}

	if (zval < zval2)
	{
		zval = zval2;
	}

	zval += 128;

	if (zval < mainLevel->fogFar)
	{
		zval = mainLevel->fogFar;
	}

	s_zval = (mainLevel->fogFar) >> 2;

	if (MainColor == LevelColor)
	{
		Color = LevelColor & 0xFFF8F8F8;

		if (Color != 0)
		{
			Color |= 0x40404;
		}
	}
	else
	{
		if (mainLevel->fogFar - mainLevel->fogNear < 0)
		{
			return LevelColor;
		}
		else
		{
			interp = (((mainLevel->fogFar - mainLevel->fogNear) << 16) / (mainLevel->fogFar - mainLevel->fogNear)) >> 4;

			if (interp < 0)
			{
				interp = 0;
			}

			if (interp >= 4097)
			{
				interp = 4096;
			}

			LoadAverageCol((unsigned char*)&MainColor, (unsigned char*)&LevelColor, interp, 4096 - interp, (unsigned char*)&Color);

			if (interp >= 4091)
			{
				Color &= 0xFFF8F8F8;

				if (Color != 0)
				{
					Color |= 0x40404;
				}
			}

			Color &= 0xFFFFFF;
		}
	}

	return Color;
}


void DrawFogRectangle(PSX_RECT* cliprect, struct _PrimPool* primPool, int otzpos, unsigned long** drawot, long color)
{
	POLY_G4* polyg4;
	
	polyg4 = (POLY_G4*)gameTrackerX.primPool->nextPrim;

	if ((unsigned int*)(polyg4 + 1) < gameTrackerX.primPool->lastPrim)
	{
		gameTrackerX.primPool->nextPrim = (unsigned int*)(polyg4 + 1);

		polyg4->x0 = cliprect->x;
		polyg4->y0 = cliprect->y;

		polyg4->x1 = cliprect->x + cliprect->w;
		polyg4->y1 = cliprect->y;

		polyg4->x2 = cliprect->x;
		polyg4->y2 = cliprect->y + cliprect->h;

		polyg4->x3 = cliprect->x + cliprect->w;
		
		setlen(polyg4, 8);

		((int*)&polyg4->r0)[0] = color;
		((int*)&polyg4->r1)[0] = color;
		((int*)&polyg4->r2)[0] = color;
		((int*)&polyg4->r3)[0] = color;

		setcode(polyg4, 0x38);

		polyg4->y3 = cliprect->y + cliprect->h;

#if defined(PSXPC_VERSION)
		addPrim(drawot[otzpos * 2], polyg4);
#else
		addPrim(drawot[otzpos], polyg4);
#endif
	}
}

void STREAM_RenderAdjacantUnit(unsigned long** curOT, struct StreamUnitPortal* curStreamPortal, struct _StreamUnit* toStreamUnit, struct _StreamUnit* mainStreamUnit, PSX_RECT* cliprect)
{
	long portalFogColor;

	if ((MEMPACK_MemoryValidFunc((char*)toStreamUnit->level)))
	{
		RENDER_currentStreamUnitID = (short)toStreamUnit->StreamUnitID;

		portalFogColor = GetFogColor(curStreamPortal, mainStreamUnit, mainStreamUnit->level);
	
		DrawFogRectangle(cliprect, gameTrackerX.primPool, 3071, curOT, portalFogColor);

		PushMatrix();

		StreamRenderLevel(toStreamUnit, mainStreamUnit->level, (unsigned int**)curOT, portalFogColor);
	
		PopMatrix();
	}
}

struct BSPTree* STREAM_GetBspTree(struct _StreamUnit* streamUnit, int bspNumber)//Matching - 100%
{
	struct Level* level;
	struct _Terrain* terrain;
	int d;

	level = streamUnit->level;
	terrain = level->terrain;

	if (terrain->numBSPTrees != 0)
	{
		for (d = 0; d < terrain->numBSPTrees; d++)
		{
			if (terrain->BSPTreeArray[d].ID == bspNumber)
			{
				return &terrain->BSPTreeArray[d];
			}
		}
	}

	return NULL;
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_BlockWarpGateEntrance(struct _StreamUnit *streamUnit /*$a0*/, long collideOn /*$s0*/)
void WARPGATE_BlockWarpGateEntrance(struct _StreamUnit *streamUnit, long collideOn)
{ // line 5214, offset 0x8005f018
	/* begin block 1 */
		// Start line: 5215
		// Start offset: 0x8005F018
		// Variables:
			struct BSPTree *bspTree; // $v1
	/* end block 1 */
	// End offset: 0x8005F078
	// End Line: 5232

	/* begin block 2 */
		// Start line: 12419
	/* end block 2 */
	// End Line: 12420
			UNIMPLEMENTED();
}

void WARPGATE_DrawWarpGateRim(struct _StreamUnit* streamUnit, int drawOn)//Matching - 99.77%
{
	struct BSPTree* bspTree;

	bspTree = STREAM_GetBspTree(streamUnit, 3);
	
	if (bspTree)
	{
		bspTree->flags &= 0xFFFD;

		if (drawOn)
		{
			bspTree->flags &= 0xFFFC;
		}
		else
		{
			bspTree->flags |= 0x1;
		}
	}
}

// autogenerated function stub: 
// void /*$ra*/ WARPGATE_HideAllCloudCovers()
void WARPGATE_HideAllCloudCovers()
{ // line 5258, offset 0x8005f0e0
	/* begin block 1 */
		// Start line: 5260
		// Start offset: 0x8005F0E0
		// Variables:
			struct Object *warpFaceObject; // $a1

		/* begin block 1.1 */
			// Start line: 5266
			// Start offset: 0x8005F0F4
			// Variables:
				struct _Instance *instance; // $v1
				struct _Instance *next; // $a0
		/* end block 1.1 */
		// End offset: 0x8005F138
		// End Line: 5281
	/* end block 1 */
	// End offset: 0x8005F138
	// End Line: 5283

	/* begin block 2 */
		// Start line: 12507
	/* end block 2 */
	// End Line: 12508

	/* begin block 3 */
		// Start line: 12508
	/* end block 3 */
	// End Line: 12509

	/* begin block 4 */
		// Start line: 12511
	/* end block 4 */
	// End Line: 12512
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ WARPGATE_UnHideCloudCoverInUnit(long streamUnitID /*$a0*/)
struct _Instance * WARPGATE_UnHideCloudCoverInUnit(long streamUnitID)
{ // line 5285, offset 0x8005f140
	/* begin block 1 */
		// Start line: 5287
		// Start offset: 0x8005F140
		// Variables:
			struct Object *warpFaceObject; // $a3
			struct _Instance *result; // $a2

		/* begin block 1.1 */
			// Start line: 5294
			// Start offset: 0x8005F154
			// Variables:
				struct _Instance *instance; // $v1
				struct _Instance *next; // $a1
		/* end block 1.1 */
		// End offset: 0x8005F1B0
		// End Line: 5312
	/* end block 1 */
	// End offset: 0x8005F1B0
	// End Line: 5314

	/* begin block 2 */
		// Start line: 12563
	/* end block 2 */
	// End Line: 12564

	/* begin block 3 */
		// Start line: 12564
	/* end block 3 */
	// End Line: 12565

	/* begin block 4 */
		// Start line: 12568
	/* end block 4 */
	// End Line: 12569
				UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ STREAM_RenderWarpGate(unsigned long **mainOT /*$s3*/, struct StreamUnitPortal *curStreamPortal /*$s2*/, struct _StreamUnit *mainStreamUnit /*$s1*/, struct PSX_RECT *cliprect /*$s4*/)
void STREAM_RenderWarpGate(unsigned long **mainOT, struct StreamUnitPortal *curStreamPortal, struct _StreamUnit *mainStreamUnit, PSX_RECT *cliprect)
{ // line 5318, offset 0x8005f1b8
	/* begin block 1 */
		// Start line: 5319
		// Start offset: 0x8005F1B8
		// Variables:
			struct _StreamUnit *toStreamUnit; // $s0
	/* end block 1 */
	// End offset: 0x8005F4D0
	// End Line: 5428

	/* begin block 2 */
		// Start line: 12634
	/* end block 2 */
	// End Line: 12635
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ WARPGATE_RenderWarpUnit(unsigned long **mainOT /*$fp*/, struct StreamUnitPortal *curStreamPortal /*$s0*/, struct _StreamUnit *mainStreamUnit /*$s4*/, struct PSX_RECT *cliprect /*$s2*/)
void WARPGATE_RenderWarpUnit(unsigned long** mainOT, struct StreamUnitPortal* curStreamPortal, struct _StreamUnit* mainStreamUnit, PSX_RECT* cliprect)
{ // line 5431, offset 0x8005f4f0
	/* begin block 1 */
		// Start line: 5432
		// Start offset: 0x8005F4F0
		// Variables:
	unsigned long** curOT; // $s3
	DR_AREA* PortalClip; // $s0
	struct _StreamUnit* toStreamUnit; // $s1

/* begin block 1.1 */
	// Start line: 5465
	// Start offset: 0x8005F5B8
	// Variables:
		//PSX_RECT PortalRect; // stack offset -48
	long portalFogColor; // $s0

/* begin block 1.1.1 */
	// Start line: 5534
	// Start offset: 0x8005F800
	// Variables:
	unsigned long* hld; // $a0
/* end block 1.1.1 */
// End offset: 0x8005F898
// End Line: 5552
/* end block 1.1 */
// End offset: 0x8005F898
// End Line: 5553
/* end block 1 */
// End offset: 0x8005F898
// End Line: 5555

/* begin block 2 */
	// Start line: 12871
/* end block 2 */
// End Line: 12872
	UNIMPLEMENTED();
}

void STREAM_DumpNonResidentObjects()
{
	struct _Instance* instance;
	struct _Instance* next;
	struct Object* object;

	instance = gameTrackerX.instanceList->first;

	while (instance != NULL)
	{
		object = instance->object;

		if (!(object->oflags & 0x2000000))
		{
			if (STREAM_GetStreamUnitWithID(instance->birthStreamUnitID) == 0 &&
				STREAM_IsObjectInAnyUnit(FindObjectInTracker(object)) == 0)
			{
				INSTANCE_ReallyRemoveInstance(gameTrackerX.instanceList, instance, 0);
			}
		}
		instance = instance->next;
	}

	STREAM_RemoveAllObjectsNotInUse();
}

int STREAM_TryAndDumpNonResident(struct _ObjectTracker* otr)
{
	struct _Instance* instance;
	struct _Instance* next;

	if (otr->objectStatus == 2 && !(otr->object->oflags & 0x2000000) && STREAM_IsObjectInAnyUnit(otr) == 0)
	{
		instance = gameTrackerX.instanceList->first;

		while (instance != NULL)
		{
			if (instance->object == otr->object && instance->LinkParent != NULL)
			{
				if (!(instance->object->oflags2 & 0x80000))
				{
					return 0;
				}
			}

			instance = instance->next;
		}

		instance = gameTrackerX.instanceList->first;

		while (instance != NULL)
		{
			next = instance->next;

			if (instance->object == otr->object)
			{
				SAVE_DeleteInstance(instance);

				if (instance->LinkChild != NULL)
				{
					INSTANCE_ReallyRemoveAllChildren(instance);
					instance = instance->next;
				}

				INSTANCE_ReallyRemoveInstance(gameTrackerX.instanceList, instance, 0);
			}

			instance = next;
		}

		STREAM_RemoveAllObjectsNotInUse();

		return otr->objectStatus < 1;
	}

    return 0;
}
