#include "CORE.H"

#include "Game/COLLIDE.H"
#include "Game/PHYSICS.H"
#include "Game/STREAM.H"
#include "Game/BSP.H"
#include "Game/MATH3D.H"
#include "Game/PHYSOBS.H"
#include "Game/STATE.H"
#include "Game/FX.H"

void SetNoPtCollideInFamily(struct _Instance* instance)
{
	struct _Instance* child;

	child = instance->LinkChild;

	instance->flags &= 0xFFFFFFBF;

	while (child != NULL)
	{
		ResetNoPtCollideInFamily(child);

		child = child->LinkSibling;
	}
}


void ResetNoPtCollideInFamily(struct _Instance* instance)
{
	struct _Instance* child;

	child = instance->LinkChild;

	instance->flags &= 0xFFFFFFBF;

	while (child != NULL)
	{
		ResetNoPtCollideInFamily(child);

		child = child->LinkSibling;
	}
}

void PHYSICS_CheckLineInWorld(struct _Instance* instance, struct _PCollideInfo* pcollideInfo)
{
	pcollideInfo->collideType = 63;

	PHYSICS_CheckLineInWorldMask(instance, pcollideInfo);
}

void PHYSICS_CheckLineInWorldMask(struct _Instance* instance, struct _PCollideInfo* pcollideInfo)//Matching - 99.31%
{
	struct Level* level;

	level = STREAM_GetLevelWithID(instance->currentStreamUnitID);

	pcollideInfo->inst = NULL;
	pcollideInfo->instance = instance;

	SetNoPtCollideInFamily(instance);

	if (level != NULL)
	{
		COLLIDE_PointAndWorld(pcollideInfo, level);
	}
	else
	{
		pcollideInfo->type = 0;
	}

	ResetNoPtCollideInFamily(instance);
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckLinkedMove(struct _Instance *instance /*$s2*/, int Data /*stack 4*/, short Mode /*stack -72*/)
int PhysicsCheckLinkedMove(struct _Instance *instance, int Data, short Mode)
{ // line 124, offset 0x80074754
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsDefaultLinkedMoveResponse(struct _Instance *instance /*$s0*/, struct evPhysicsLinkedMoveData *Data /*$s1*/, int updateTransforms /*$a2*/)
void PhysicsDefaultLinkedMoveResponse(struct _Instance *instance, struct evPhysicsLinkedMoveData *Data, int updateTransforms)
{ // line 272, offset 0x80074bb0
	UNIMPLEMENTED();
}

int PhysicsCheckGravity(struct _Instance* instance, int Data, short Mode)//Matching - 93.82%
{
	struct evPhysicsGravityData* Ptr;
	SVECTOR D;
	SVECTOR N;
	short Dot;
	int rc;
	struct _PCollideInfo CInfo;
	SVECTOR Old;
	SVECTOR New;
	int slide;
	int stillOnOldTFace;
	struct Level* level;
	struct _TFace* tface;
	struct _Instance* oldOn;
	int dx;
	int dy;
	int dz;

	rc = 0;

	D.vx = 0;
	D.vy = 0;
	D.vz = 240;

	slide = 0;

	CInfo.newPoint = &New;
	CInfo.oldPoint = &Old;

	Old.vx = New.vx = instance->position.x;
	Old.vy = New.vy = instance->position.y;
	Old.vz = New.vz = instance->position.z;

	Ptr = (struct evPhysicsGravityData*)Data;

	Old.vz += Ptr->UpperOffset;
	New.vz -= Ptr->LowerOffset;

	if (Old.vz < New.vz)
	{
		CInfo.type = 0;
	}
	else
	{
		if (instance->cachedTFace != -1 && instance->cachedTFaceLevel != NULL)
		{
			tface = NULL;

			level = STREAM_GetLevelWithID(((struct Level*)instance->cachedTFaceLevel)->streamUnitID);

			gameTrackerX.gameFlags |= 0x8000;

			if (level != NULL)
			{
				tface = &level->terrain->faceList[instance->cachedTFace];

				stillOnOldTFace = COLLIDE_PointAndTfaceFunc(level->terrain, &level->terrain->BSPTreeArray[instance->cachedBSPTree], (struct _SVector*)&New, (struct _SVector*)&Old, tface, 0, 0);
			}
			else
			{
				stillOnOldTFace = 0;

			}

			if (stillOnOldTFace == 0)
			{
				instance->waterFace = NULL;

				PHYSICS_CheckLineInWorld(instance, &CInfo);
			}
			else
			{
				CInfo.type = 3;
				CInfo.prim = tface;
				CInfo.inst = (struct _Instance*)level;
				CInfo.segment = instance->cachedBSPTree;

				COLLIDE_GetNormal((short)tface->normal, (short*)level->terrain->normalList, (struct _SVector*)&CInfo.wNormal);
			}
		}
		else
		{
			instance->waterFace = NULL;

			gameTrackerX.gameFlags |= 0x8000;

			PHYSICS_CheckLineInWorld(instance, &CInfo);
		}

		gameTrackerX.gameFlags &= ~0x8000;
	}

	if ((unsigned)(short)(CInfo.type - 2) < 2 || CInfo.type == 5)
	{
		if (CInfo.wNormal.vz < Ptr->slipSlope && CInfo.wNormal.vz > 0)
		{
			N.vx = (-(CInfo.wNormal.vx * -(unsigned short)CInfo.wNormal.vz) < 0) ? ((-(CInfo.wNormal.vx * -(unsigned short)CInfo.wNormal.vz) + 0xFFF)) : ((-(CInfo.wNormal.vx * -(unsigned short)CInfo.wNormal.vz)));
			N.vx >>= 12;
			N.vy = (-(CInfo.wNormal.vy * -(unsigned short)CInfo.wNormal.vz) < 0) ? ((-(CInfo.wNormal.vy * -(unsigned short)CInfo.wNormal.vz) + 0xFFF)) : ((-(CInfo.wNormal.vy * -(unsigned short)CInfo.wNormal.vz)));
			N.vy >>= 12;
			N.vz = (-(CInfo.wNormal.vz * -(unsigned short)CInfo.wNormal.vz) < 0) ? ((-(CInfo.wNormal.vz * -(unsigned short)CInfo.wNormal.vz) + 0xFFF)) : ((-(CInfo.wNormal.vz * -(unsigned short)CInfo.wNormal.vz)));
			N.vz >>= 12;

			Dot = ((instance->zVel < -48) ? -instance->zVel : 48);

			Old.vx = New.vx = CInfo.newPoint->vx + N.vx * Dot / 4096;
			Old.vy = New.vy = CInfo.newPoint->vy + N.vy * Dot / 4096;
			Old.vz = New.vz = CInfo.newPoint->vz + N.vz * Dot / 4096;

			Old.vz += Ptr->UpperOffset;
			New.vz -= Ptr->LowerOffset;

			PHYSICS_CheckLineInWorld(instance, &CInfo);

			if ((unsigned)((unsigned short)CInfo.type - 2) < 2 || CInfo.type == 5)
			{
				if (CInfo.wNormal.vz < Ptr->slipSlope && CInfo.wNormal.vz > 0)
				{
					slide = 1;
				}
				else
				{
					instance->position.x = CInfo.newPoint->vx;
					instance->position.y = CInfo.newPoint->vy;
				}
			}
		}
	}

	if (CInfo.type == 3)
	{
		instance->cachedBSPTree = CInfo.segment;

		instance->cachedTFace = (int)(-0x55555555 * (unsigned int)((char*)CInfo.prim - (unsigned int)CInfo.inst->node.prev[4].prev)) >> 2;

		instance->cachedTFaceLevel = CInfo.inst;
	}
	else
	{
		instance->cachedTFace = -1;

		instance->cachedTFaceLevel = NULL;
	}

	if ((unsigned)((unsigned short)CInfo.type - 2) < 2 || CInfo.type == 5)
	{
		if ((Mode & 0x7))
		{
			if (slide != 0)
			{
				Ptr->x = CInfo.newPoint->vx - instance->position.x;
				Ptr->y = CInfo.newPoint->vy - instance->position.y;
			}
			else
			{
				Ptr->x = 0;
				Ptr->y = 0;
			}

			Ptr->z = CInfo.newPoint->vz - instance->position.z;

		}

		if ((Mode & 0x2) && slide == 0)
		{
			INSTANCE_Post(instance, 0x4010008, Data);
		}

		if (slide == 1)
		{
			if ((Mode & 0x2))
			{
				INSTANCE_Post(instance, 0x4010200, Data);
			}

			rc |= 0x100000;
		}

		if ((Mode & 0x4))
		{
			if (CheckPhysOb(instance) == 0 || CheckPhysObFamily(instance, 1) == 0 || instance->attachedID == 0)
			{
				PhysicsDefaultGravityResponse(instance, Ptr);
			}
		}

		if (CInfo.type != 1)
		{
			instance->wNormal.x = CInfo.wNormal.vx;
			instance->wNormal.y = CInfo.wNormal.vy;
			instance->wNormal.z = CInfo.wNormal.vz;
		}
		else
		{
			instance->wNormal.x = 0;
			instance->wNormal.y = 0;
			instance->wNormal.z = 4096;
		}

		if (CInfo.type != 3 && CInfo.inst != NULL && (CInfo.inst->object->oflags & 0x400))
		{
			rc |= PhysicsCheckLinkedMove(instance, SetPhysicsLinkedMoveData(CInfo.inst, CInfo.segment, NULL, NULL), Mode);
		}
		else
		{
			if (instance->attachedID != 0)
			{
				oldOn = INSTANCE_Find(instance->attachedID);

				if (oldOn != NULL)
				{
					oldOn->flags2 &= 0xFFFFFF7F;
				}
			}

			instance->attachedID = 0;
		}

		if ((instance->flags2 & 0x40))
		{
			instance->shadowPosition = instance->position;

			instance->flags |= 0x8000000;
		}

		if (CInfo.type == 3)
		{
			if (instance->tface != CInfo.prim)
			{
				instance->oldTFace = (struct _TFace*)CInfo.prim;

				instance->tface = (struct _TFace*)CInfo.prim;

				instance->tfaceLevel = CInfo.inst;

				instance->bspTree = CInfo.segment;

				if (CInfo.segment == 0)
				{
					rc |= 0x80000;
				}
			}
		}
		else
		{
			if (instance->tface != NULL)
			{
				instance->oldTFace = instance->tface;

				instance->tface = NULL;

				instance->tfaceLevel = NULL;

				instance->bspTree = 0;
			}
		}

		rc |= 0x1;
	}
	else
	{
		if (instance->tface != NULL)
		{
			instance->oldTFace = instance->tface;

			instance->tface = NULL;

			instance->tfaceLevel = NULL;

			instance->bspTree = 0;
		}
	}

	instance->attachedID = 0;

	if ((Mode & 0x2))
	{
		INSTANCE_Post(instance, 0x4000001, Data);
	}

	return rc;
}

void PhysicsDefaultGravityResponse(struct _Instance *instance, struct evPhysicsGravityData *Data)
{
	instance->position.x += Data->x;
	instance->position.y += Data->y;

	if (instance == gameTrackerX.playerInstance && Data->z >= 129)
	{
		instance->position.z += 128;
	}
	else
	{
		instance->position.z += Data->z;
	}
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckEdgeGrabbing(struct _Instance *instance /*$s2*/, struct GameTracker *gameTracker /*$a1*/, int Data /*stack 8*/, short Mode /*$s7*/)
int PhysicsCheckEdgeGrabbing(struct _Instance *instance, struct GameTracker *gameTracker, int Data, short Mode)
{ // line 589, offset 0x80075468
	/* begin block 1 */
		// Start line: 590
		// Start offset: 0x80075468
		// Variables:
			struct evPhysicsEdgeData *Ptr; // $s1
			int rc; // $s6
			VECTOR OutTrans; // stack offset -120
			SVECTOR *ExtraRot; // $v0
			//struct _PCollideInfo CInfo; // stack offset -104
			SVECTOR Old; // stack offset -56
			SVECTOR New; // stack offset -48
			static MATRIX TempMat; // offset 0x0
			static MATRIX *pTempMat; // offset 0x20
			int wallCrawl; // $fp
			int freeSpot; // $s3
	/* end block 1 */
	// End offset: 0x80075AEC
	// End Line: 873

	/* begin block 2 */
		// Start line: 1345
	/* end block 2 */
	// End Line: 1346
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsDefaultEdgeGrabResponse(struct _Instance *instance /*$s2*/, struct evPhysicsEdgeData *Data /*$s1*/, int blockFlag /*$a2*/)
void PhysicsDefaultEdgeGrabResponse(struct _Instance *instance, struct evPhysicsEdgeData *Data, int blockFlag)
{ // line 886, offset 0x80075b20
	/* begin block 1 */
		// Start line: 887
		// Start offset: 0x80075B20
		// Variables:
			struct _SVector normal; // stack offset -88
			struct _G2EulerAngles_Type ea1; // stack offset -80
			VECTOR OutTrans; // stack offset -72
			MATRIX TempMat; // stack offset -56
			SVECTOR New; // stack offset -24

		/* begin block 1.1 */
			// Start line: 936
			// Start offset: 0x80075C3C
			// Variables:
				long dp; // $v0
		/* end block 1.1 */
		// End offset: 0x80075C3C
		// End Line: 936
	/* end block 1 */
	// End offset: 0x80075C3C
	// End Line: 936

	/* begin block 2 */
		// Start line: 2031
	/* end block 2 */
	// End Line: 2032
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckSliding(struct _Instance *instance /*$s3*/, int Data /*$a1*/, short Mode /*$s6*/)
int PhysicsCheckSliding(struct _Instance *instance, int Data, short Mode)
{ // line 983, offset 0x80075dc4
	/* begin block 1 */
		// Start line: 984
		// Start offset: 0x80075DC4
		// Variables:
			struct evPhysicsSlideData *Ptr; // $s0
			int rc; // $s1
			VECTOR OutTrans; // stack offset -120
			struct _SVector normal; // stack offset -104
			//struct _PCollideInfo CInfo; // stack offset -96
			SVECTOR Old; // stack offset -48
			SVECTOR New; // stack offset -40
			static MATRIX *pTempMat; // offset 0x24

		/* begin block 1.1 */
			// Start line: 1015
			// Start offset: 0x80075E4C
		/* end block 1.1 */
		// End offset: 0x80075E4C
		// End Line: 1017

		/* begin block 1.2 */
			// Start line: 1024
			// Start offset: 0x80075E88
			// Variables:
				int Temp; // $a3
		/* end block 1.2 */
		// End offset: 0x80075F5C
		// End Line: 1032
	/* end block 1 */
	// End offset: 0x80076244
	// End Line: 1166

	/* begin block 2 */
		// Start line: 2245
	/* end block 2 */
	// End Line: 2246
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsUpdateTface(struct _Instance *instance /*$s0*/, int Data /*$a1*/)
int PhysicsUpdateTface(struct _Instance *instance, int Data)
{ // line 1177, offset 0x80076270
	/* begin block 1 */
		// Start line: 1178
		// Start offset: 0x80076270
		// Variables:
			//struct _PCollideInfo CInfo; // stack offset -72
			SVECTOR Old; // stack offset -24
			SVECTOR New; // stack offset -16
	/* end block 1 */
	// End offset: 0x8007635C
	// End Line: 1219

	/* begin block 2 */
		// Start line: 2786
	/* end block 2 */
	// End Line: 2787
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckBlockers(struct _Instance *instance /*$s3*/, struct GameTracker *gameTracker /*$a1*/, int Data /*$s4*/, short Mode /*$s2*/)
int PhysicsCheckBlockers(struct _Instance *instance, struct GameTracker *gameTracker, int Data, short Mode)
{ // line 1232, offset 0x8007636c
	/* begin block 1 */
		// Start line: 1233
		// Start offset: 0x8007636C
		// Variables:
			struct evPhysicsEdgeData *Ptr; // $s1
			VECTOR OutTrans; // stack offset -120
			//struct _PCollideInfo CInfo; // stack offset -104
			SVECTOR Old; // stack offset -56
			SVECTOR New; // stack offset -48
			static MATRIX *pTempMat; // offset 0x28

		/* begin block 1.1 */
			// Start line: 1276
			// Start offset: 0x80076418
			// Variables:
				struct _TFace *tface; // $s0

			/* begin block 1.1.1 */
				// Start line: 1278
				// Start offset: 0x80076418
				// Variables:
					int Dot; // $a0
					SVECTOR Force; // stack offset -40
			/* end block 1.1.1 */
			// End offset: 0x800764FC
			// End Line: 1323

			/* begin block 1.1.2 */
				// Start line: 1351
				// Start offset: 0x800765D0
				// Variables:
					struct _HFace *hface; // stack offset -32
			/* end block 1.1.2 */
			// End offset: 0x800765D0
			// End Line: 1357
		/* end block 1.1 */
		// End offset: 0x800766E8
		// End Line: 1401
	/* end block 1 */
	// End offset: 0x800766EC
	// End Line: 1404

	/* begin block 2 */
		// Start line: 2909
	/* end block 2 */
	// End Line: 2910
					UNIMPLEMENTED();
	return 0;
}


int PhysicsCheckSwim(struct _Instance* instance, int Data, short Mode)//Matching - 98.81%
{
	struct evPhysicsSwimData* Ptr;
	int rc;
	int Depth;
	int WaterDepth;
	struct _PCollideInfo CInfo;
	SVECTOR Old;
	SVECTOR New;
	long waterZLevel;

	Ptr = (struct evPhysicsSwimData*)Data;

	waterZLevel = STREAM_GetWaterZLevel(STREAM_GetLevelWithID(instance->currentStreamUnitID), instance);

	Depth = instance->matrix[1].t[2] - waterZLevel;

	if (waterZLevel == -32767)
	{
		Depth = 1;
		WaterDepth = -32767;
	}
	else
	{
		WaterDepth = -32767;

		if (waterZLevel == 0x7FFF)
		{
			Depth = -32767;
		}
		else if (Ptr->CheckDepth)
		{
			CInfo.oldPoint = &Old;
			CInfo.newPoint = &New;

			Old.vx = New.vx = instance->matrix[1].t[0];
			Old.vy = New.vy = instance->matrix[1].t[1];
			Old.vz = New.vz = instance->matrix[1].t[2];

			New.vz -= Ptr->WadeDepth * 4;
			Old.vz += Ptr->TreadDepth;

			gameTrackerX.gameFlags |= 0x8000;
			
			instance->waterFace = 0;
			
			PHYSICS_CheckLineInWorld(instance, &CInfo);

			gameTrackerX.gameFlags &= ~0x8000;

			if (CInfo.type)
			{
				WaterDepth = Depth + CInfo.newPoint->vz - instance->matrix[1].t[2];
			}
			else
			{
				WaterDepth = Depth - 4 * Ptr->WadeDepth;
			}
		}
		else
		{
			Ptr->Depth = Depth;
			
			WaterDepth = instance->matrix->t[2] - waterZLevel;
	
			Ptr->WaterDepth = WaterDepth;
		}
	}
	
	if ((Mode & 0x3))
	{
		Ptr->Depth = Depth;
		
		Ptr->WaterDepth = WaterDepth;
	}
	
	Ptr->WaterLevel = waterZLevel;
	
	rc = PhysicsDefaultCheckSwimResponse(instance, (struct evPhysicsSwimData*)Data);
	
	Ptr->rc = rc;
	
	if ((Mode & 0x2))
	{
		INSTANCE_Post(instance, 0x4020000, Data);
	}

	FX_UpdateInstanceWaterSplit(instance);
	
	return rc;
}

// autogenerated function stub: 
// int /*$ra*/ PhysicsDefaultCheckSwimResponse(struct _Instance *instance /*$s2*/, struct evPhysicsSwimData *Data /*$s3*/)
int PhysicsDefaultCheckSwimResponse(struct _Instance *instance, struct evPhysicsSwimData *Data)
{ // line 1584, offset 0x800768fc
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsForceSetWater(struct _Instance *instance /*$s1*/, int *Time /*$t0*/, int Depth /*$a2*/, int rate /*$a3*/, int maxAmplitude /*stack 16*/)
void PhysicsForceSetWater(struct _Instance *instance, int *Time, int Depth, int rate, int maxAmplitude)
{ // line 1856, offset 0x80076af4
	UNIMPLEMENTED();
}

int PhysicsCheckLOS(struct _Instance* instance, int Data, int Mode) //Matching - 99.58%
{
	struct _PCollideInfo CInfo;

	CInfo.oldPoint = (SVECTOR*)(Data + 8);
	CInfo.newPoint = (SVECTOR*)Data;
	PHYSICS_CheckLineInWorld(instance, &CInfo);

	return CInfo.type == 0;
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsCheckDropHeight(struct _Instance *instance /*$s2*/, int Data /*$a1*/, int Mode /*$s3*/)
int PhysicsCheckDropHeight(struct _Instance *instance, int Data, int Mode)
{ // line 1915, offset 0x80076bfc
	/* begin block 1 */
		// Start line: 1916
		// Start offset: 0x80076BFC
		// Variables:
			struct evPhysicsDropHeightData *data; // $s0
			struct Level *level; // $v0
			SVECTOR newPos; // stack offset -104
			SVECTOR oldPos; // stack offset -96
			int rc; // $s1
			int lowZ; // $v1
			//struct _PCollideInfo CInfo; // stack offset -88
			static MATRIX TempMat; // offset 0x30
			static MATRIX *pTempMat; // offset 0x50

		/* begin block 1.1 */
			// Start line: 1929
			// Start offset: 0x80076C30
			// Variables:
				VECTOR outTrans; // stack offset -40
				SVECTOR *ExtraRot; // $v0
		/* end block 1.1 */
		// End offset: 0x80076C74
		// End Line: 1958

		/* begin block 1.2 */
			// Start line: 1982
			// Start offset: 0x80076D40
			// Variables:
				long waterZLevel; // $a0
		/* end block 1.2 */
		// End offset: 0x80076D7C
		// End Line: 2000
	/* end block 1 */
	// End offset: 0x80076E6C
	// End Line: 2048

	/* begin block 2 */
		// Start line: 4438
	/* end block 2 */
	// End Line: 4439
				UNIMPLEMENTED();
	return 0;
}

int PhysicsCheckDropOff(struct _Instance* instance, int Data, short Mode)//Matching - 98.79%
{
	struct evPhysicsDropOffData* Ptr;
	int rc;
	VECTOR OutTrans;
	SVECTOR* ExtraRot;
	struct _PCollideInfo CInfo;
	SVECTOR New;
	SVECTOR Old;
	static MATRIX TempMat;
	static MATRIX* pTempMat;

	CInfo.oldPoint = &Old;

	Ptr = (struct evPhysicsDropOffData*)Data;

	CInfo.newPoint = &New;

	ExtraRot = (SVECTOR*)INSTANCE_Query(instance, 0x8);
	rc = 0;

	if (instance->matrix != NULL)
	{
		if (ExtraRot != NULL)
		{
			pTempMat = &TempMat;

			RotMatrix(ExtraRot, pTempMat);

			MulMatrix2(instance->matrix, pTempMat);
		}
		else
		{
			pTempMat = instance->matrix;
		}

		New.vx = Ptr->xOffset;
		New.vy = Ptr->yOffset;
		New.vz = 0;

		ApplyMatrix(pTempMat, &New, &OutTrans);

		Old.vx = instance->position.x + OutTrans.vx;
		Old.vy = instance->position.y + OutTrans.vy;
		Old.vz = instance->position.z + OutTrans.vz;

		New.vx = Old.vx;
		New.vy = Old.vy;
		New.vz = Old.vz - Ptr->DropOffset;
		Old.vz += Ptr->UpperOffset;

		PHYSICS_CheckLineInWorld(instance, &CInfo);

		if ((unsigned int)((unsigned short)CInfo.type - 2) < 2 || (CInfo.type == 5))
		{
			if (Mode & 0x2)
			{
				if (CInfo.wNormal.vz > Ptr->slipSlope)
				{
					INSTANCE_Post(instance, 0x4010080, 1);
				}
				else
				{

					INSTANCE_Post(instance, 0x4010080, 0);
					rc = 8;
				}
			}
			if (CInfo.wNormal.vz < Ptr->slipSlope && CInfo.wNormal.vz > 0 && CInfo.newPoint->vz > instance->position.z)
			{
				INSTANCE_Post(instance, 0x4010401, 0);
			}
		}
		else
		{
			if (!CInfo.type)
			{
				if ((Mode & 0x2))
				{
					INSTANCE_Post(instance, 0x4010080, 0);
				}
				rc = 8;
			}
		}
	}
	return rc;
}


// autogenerated function stub: 
// int /*$ra*/ PhysicsFollowWall(struct _Instance *instance /*$s2*/, struct GameTracker *gameTracker /*$a1*/, int Data /*$s7*/, short Mode /*$s5*/)
int PhysicsFollowWall(struct _Instance *instance, struct GameTracker *gameTracker, int Data, short Mode)
{ // line 2209, offset 0x800770ac
	/* begin block 1 */
		// Start line: 2210
		// Start offset: 0x800770AC
		// Variables:
			VECTOR OutTrans; // stack offset -168
			struct evPhysicsWallCrawlData *Ptr; // $s1
			//struct _PCollideInfo CInfo; // stack offset -152
			SVECTOR New; // stack offset -104
			SVECTOR Old; // stack offset -96
			static MATRIX *pTempMat; // offset 0x84

		/* begin block 1.1 */
			// Start line: 2281
			// Start offset: 0x800771E8
			// Variables:
				_Position A; // stack offset -88
				_Position B; // stack offset -80
				MATRIX mat; // stack offset -72
		/* end block 1.1 */
		// End offset: 0x800772E4
		// End Line: 2341
	/* end block 1 */
	// End offset: 0x8007758C
	// End Line: 2488

	/* begin block 2 */
		// Start line: 4418
	/* end block 2 */
	// End Line: 4419
				UNIMPLEMENTED();
	return 0;
}

void PhysicsMoveLocalZClamp(struct _Instance* instance, long segment, long time, long clamp) //Matching - 99.91%
{
	struct _Position pos;
	SVECTOR v;
	SVECTOR dv;

	memset(&pos, 0, sizeof(struct _Position));

	PhysicsMove(instance, &pos, time);

	v.vx = pos.x;
	v.vy = -pos.y;
	v.vz = pos.z;

	ApplyMatrixSV(&instance->matrix[segment], &v, &dv);

	instance->position.x += dv.vx;
	instance->position.y += dv.vy;

	if (clamp == 0)
	{
		instance->position.z += dv.vz;
	}
}

void PhysicsMove(struct _Instance* instance, struct _Position* position, long time)//Matching - 90.87%
{
	long _xVel;
	long _yVel;
	long _zVel;
	long xVel;
	long yVel;
	long zVel;
	long xat;
	long yat;
	long zat;
	long x;
	long y;
	long z;

	_xVel = xVel = instance->xVel;
	_yVel = yVel = instance->yVel;
	_zVel = zVel = instance->zVel;

	xat = (instance->xAccl * time) < 0 ? ((instance->xAccl * time) + 0xFFF) : (instance->xAccl * time);
	xat >>= 12;
	yat = (instance->yAccl * time) < 0 ? ((instance->yAccl * time) + 0xFFF) : (instance->yAccl * time);
	yat >>= 12;
	zat = (instance->zAccl * time) < 0 ? ((instance->zAccl * time) + 0xFFF) : (instance->zAccl * time);
	zat >>= 12;

	xVel = (xVel * time) < 0 ? ((xVel * time) + 0xFFF) : (xVel * time);
	xVel >>= 12;
	x = (xat * time) < 0 ? (((xat * time) + 0x1FFF)) : (xat * time);
	x >>= 13;
	position->x += xVel + x;

	yVel = (yVel * time) < 0 ? ((yVel * time) + 0xFFF) : (yVel * time);
	yVel >>= 12;
	y = (yat * time) < 0 ? (((yat * time) + 0x1FFF)) : (yat * time);
	y >>= 13;
	position->y += yVel + y;

	zVel = (zVel * time) < 0 ? ((zVel * time) + 0xFFF) : (zVel * time);
	zVel >>= 12;
	z = (zat * time) < 0 ? (((zat * time) + 0x1FFF)) : (zat * time);
	z >>= 13;
	position->z += zVel + z;

	_xVel += xat;
	_yVel += yat;
	_zVel += zat;

	if (instance->maxXVel < _xVel || _xVel < -instance->maxXVel)
	{
		_xVel = instance->maxXVel;
	}

	if (instance->maxYVel < _yVel || _yVel < -instance->maxYVel)
	{
		_yVel = instance->maxYVel;
	}

	if (instance->maxZVel < _zVel || _zVel < -instance->maxZVel)
	{
		_zVel = instance->maxZVel;
	}

	instance->xVel = _xVel;
	instance->yVel = _yVel;
	instance->zVel = _zVel;
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsSetVelFromZRot(struct _Instance *instance /*$s2*/, short angle /*$a1*/, long magnitude /*$s1*/)
void PhysicsSetVelFromZRot(struct _Instance *instance, short angle, long magnitude)
{ // line 2734, offset 0x80077830
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ PhysicsSetVelFromRot(struct _Instance *instance /*$s0*/, struct _Rotation *rot /*$a1*/, long magnitude /*$a2*/)
void PhysicsSetVelFromRot(struct _Instance *instance, struct _Rotation *rot, long magnitude)
{ // line 2745, offset 0x800778a0
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ PHYSICS_SetVAndAFromRot(struct _Instance *instance /*$s0*/, struct _Rotation *rot /*$a1*/, long v /*$s1*/, long a /*$s2*/)
void PHYSICS_SetVAndAFromRot(struct _Instance *instance, struct _Rotation *rot, long v, long a)
{ // line 2765, offset 0x80077910
	UNIMPLEMENTED();
}

long PHYSICS_FindAFromDAndT(long d, long t)
{
	if (t != 0)
	{
		return MAX((d * 8192) / (t * t), (d * 8192) / (t * t) + 4095) >> 12;
	}
	else
	{
		return 0;
	}
}

long PHYSICS_FindVFromAAndD(long a, long d)
{
	long vsq; // $a0

	vsq = a * (d * 2);

	if (vsq == 0)
	{
		return 0;
	}
	else
	{
		return MATH3D_FastSqrt0(vsq);
	}
}


// autogenerated function stub: 
// void /*$ra*/ PHYSICS_StopIfCloseToTarget(struct _Instance *instance /*$a0*/, int x /*$a1*/, int y /*$a2*/, int z /*$a3*/)
void PHYSICS_StopIfCloseToTarget(struct _Instance *instance, int x, int y, int z)
{ // line 2876, offset 0x80077a74
	UNIMPLEMENTED();
}

int PHYSICS_CheckForTerrainCollide(struct _Instance* instance, SVECTOR* startVec, SVECTOR* endVec, int segment)
{
	struct _PCollideInfo CInfo;
	MATRIX* pTempMat;

	pTempMat = instance->matrix + segment;

	PHYSICS_GenericLineCheckMask(instance, pTempMat, pTempMat, &CInfo);

	return (CInfo.type ^ 3) < 1;
}


int PHYSICS_CheckForObjectCollide(struct _Instance* instance, SVECTOR* startVec, SVECTOR* endVec, int segment)
{
	struct _PCollideInfo CInfo;
	MATRIX* pTempMat;

	pTempMat = instance->matrix;
	
	CInfo.collideType = 62;

	PHYSICS_GenericLineCheckMask(instance, &pTempMat[segment], &pTempMat[segment], &CInfo);

	return (unsigned)0 < CInfo.type;
}


// autogenerated function stub: 
// int /*$ra*/ PHYSICS_CheckForValidMove(struct _Instance *instance /*$a0*/, SVECTOR *startVec /*$a1*/, SVECTOR *endVec /*$a2*/, int segment /*$a3*/)
int PHYSICS_CheckForValidMove(struct _Instance *instance, SVECTOR *startVec, SVECTOR *endVec, int segment)
{ // line 2938, offset 0x80077be0
	UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PHYSICS_CheckFaceStick(struct _PCollideInfo *CInfo /*$a0*/)
int PHYSICS_CheckFaceStick(struct _PCollideInfo *CInfo)
{ // line 2966, offset 0x80077c4c
	/* begin block 1 */
		// Start line: 2967
		// Start offset: 0x80077C4C
		// Variables:
			int rc; // $a1

		/* begin block 1.1 */
			// Start line: 2973
			// Start offset: 0x80077C60
			// Variables:
				struct _TFace *tface; // $a2
		/* end block 1.1 */
		// End offset: 0x80077C78
		// End Line: 2975

		/* begin block 1.2 */
			// Start line: 2979
			// Start offset: 0x80077CA4
			// Variables:
				struct _HFace *hface; // stack offset -8
		/* end block 1.2 */
		// End offset: 0x80077CA4
		// End Line: 2987
	/* end block 1 */
	// End offset: 0x80077CA4
	// End Line: 2988

	/* begin block 2 */
		// Start line: 6640
	/* end block 2 */
	// End Line: 6641
				UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// int /*$ra*/ PHYSICS_CheckDontGrabEdge(struct _PCollideInfo *CInfo /*$s0*/)
int PHYSICS_CheckDontGrabEdge(struct _PCollideInfo *CInfo)
{ // line 2992, offset 0x80077cb0
	UNIMPLEMENTED();
	return 0;
}

void PHYSICS_GenericLineCheckSetup(short x, short y, short z, SVECTOR* inVec)
{
	inVec->vx = x;
	inVec->vy = y;
	inVec->vz = z;
}

void PHYSICS_GenericLineCheck(struct _Instance* instance, MATRIX* transMat, MATRIX* rotMat, struct _PCollideInfo* cInfo)
{
	cInfo->collideType = 63;
	PHYSICS_GenericLineCheckMask(instance, transMat, rotMat, cInfo);
}


// autogenerated function stub: 
// void /*$ra*/ PHYSICS_GenericLineCheckMask(struct _Instance *instance /*$a0*/, MATRIX *transMat /*$a1*/, MATRIX *rotMat /*$a2*/, struct _PCollideInfo *cInfo /*$a3*/)
void PHYSICS_GenericLineCheckMask(struct _Instance *instance, MATRIX *transMat, MATRIX *rotMat, struct _PCollideInfo *cInfo)
{ // line 3057, offset 0x80077e0c
	UNIMPLEMENTED();
}




