#include "Game/CORE.H"
#include "Game/GAMELOOP.H"
#include "HEALTH.H"
#include "Game/FONT.H"
#include "RAZLIB.H"
#include "Game/G2/ANMCTRLR.H"
#include "RAZIEL.H"
#include "Game/STREAM.H"
#include "Game/RAZIEL/PUPPET.H"
#include "Game/FX.H"
#include "Game/RAZIEL/RAZIEL.H"
#include "Game/MATH3D.H"
#include "Game/RAZIEL/CONTROL.H"
#include "Game/DEBUG.H"
#include "Game/RAZIEL/SWIM.H"
#include "Game/RAZIEL/ATTACK.H"
#include "Game/STATE.H"
#include "Game/G2/TIMERG2.H"
#include "Game/G2/ANMG2ILF.H"
#include "Game/SOUND.H"

struct __Player Raziel;
struct __razController controllerList[] = { 
	{ 0x0000, 0x0026 },
	{ 0x0000, 0x0064 },
	{ 0x0000, 0x0020 },
	{ 0x0000, 0x0022 },
	{ 0x0000, 0x0008 },
	{ 0x0000, 0x000E },
	{ 0x0001, 0x0026 },
	{ 0x0001, 0x000E },
	{ 0x0001, 0x000A },
	{ 0x0011, 0x000E },
	{ 0x0011, 0x0008 },
	{ 0x0010, 0x000E },
	{ 0x000F, 0x000E },
	{ 0x000E, 0x000E },
	{ 0x000E, 0x0008 },
	{ 0x0030, 0x0008 },
	{ 0x0032, 0x004C },
	{ 0x0033, 0x0008 },
	{ 0x0034, 0x0008 },
	{ 0x0035, 0x0008 },
	{ 0x003A, 0x004C },
	{ 0x003B, 0x0008 },
	{ 0x003C, 0x0008 },
	{ 0x003D, 0x0008 },

}; // offset 0x800d1c64

// autogenerated function stub: 
// void /*$ra*/ razAlignYMoveRot(struct _Instance *dest /*$s3*/, short distance /*$a1*/, _Position *position /*$s4*/, struct _Rotation *rotation /*$s2*/, int extraZ /*stack 16*/)
void razAlignYMoveRot(struct _Instance *dest, short distance, _Position *position, struct _Rotation *rotation, int extraZ)
{ // line 12, offset 0x800a51b0
	/* begin block 1 */
		// Start line: 13
		// Start offset: 0x800A51B0
		// Variables:
			SVECTOR d; // stack offset -72
			SVECTOR dd; // stack offset -64
			//MATRIX mat; // stack offset -56
	/* end block 1 */
	// End offset: 0x800A51B0
	// End Line: 13

	/* begin block 2 */
		// Start line: 24
	/* end block 2 */
	// End Line: 25
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ razAlignYRotMove(struct _Instance *dest /*$s1*/, short distance /*$a1*/, _Position *position /*$s2*/, struct _Rotation *rotation /*$s4*/, int extraZ /*stack 16*/)
void razAlignYRotMove(struct _Instance *dest, short distance, _Position *position, struct _Rotation *rotation, int extraZ)
{ // line 54, offset 0x800a5274
	/* begin block 1 */
		// Start line: 55
		// Start offset: 0x800A5274
		// Variables:
			//SVECTORd; // stack offset -88
			//SVECTORdd; // stack offset -80
			//SVECTORrot; // stack offset -72
			//MATRIX mat; // stack offset -64
	/* end block 1 */
	// End offset: 0x800A5274
	// End Line: 55

	/* begin block 2 */
		// Start line: 136
	/* end block 2 */
	// End Line: 137
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ razAlignYRotMoveInterp(struct _Instance *source /*$s1*/, struct _Instance *dest /*$a1*/, short distance /*$a2*/, unsigned char segNumber /*$s0*/, int Frames /*stack 16*/, int extraZ /*stack 20*/)
void razAlignYRotMoveInterp(struct _Instance *source, struct _Instance *dest, short distance, unsigned char segNumber, int Frames, int extraZ)
{ // line 86, offset 0x800a534c
	/* begin block 1 */
		// Start line: 87
		// Start offset: 0x800A534C
		// Variables:
			_Position position; // stack offset -40
			struct _Rotation rotation; // stack offset -32
			struct _G2SVector3_Type v; // stack offset -24
	/* end block 1 */
	// End offset: 0x800A534C
	// End Line: 87

	/* begin block 2 */
		// Start line: 210
	/* end block 2 */
	// End Line: 211
			UNIMPLEMENTED();
}

void razAlignYRotInterp(struct _Instance* source, _Position* dest, unsigned char segNumber, int Frames)
{
	source->rotation.z = MATH3D_AngleFromPosToPos(&source->position, dest);
}


// autogenerated function stub: 
// int /*$ra*/ razConstrictAngle(struct _Instance *instance /*$a0*/)
int razConstrictAngle(struct _Instance *instance)
{ // line 195, offset 0x800a546c
	/* begin block 1 */
		// Start line: 196
		// Start offset: 0x800A546C
		// Variables:
			int i; // $s0
			int j; // $s2
			int k; // $a2
			int Total; // $s1
			int outer; // stack offset -32
			int rc; // $s3
			struct _SVector point; // stack offset -40
	/* end block 1 */
	// End offset: 0x800A5564
	// End Line: 243

	/* begin block 2 */
		// Start line: 390
	/* end block 2 */
	// End Line: 391
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ razRotateUpperBody(struct _Instance *instance /*$s3*/, struct evActionLookAroundData *data /*$a1*/)
void razRotateUpperBody(struct _Instance *instance, struct evActionLookAroundData *data)
{ // line 247, offset 0x800a5580
	/* begin block 1 */
		// Start line: 248
		// Start offset: 0x800A5580
		// Variables:
			int tx; // $s0
			int tz; // $s2
			struct _G2SVector3_Type Rot; // stack offset -32
	/* end block 1 */
	// End offset: 0x800A5608
	// End Line: 268

	/* begin block 2 */
		// Start line: 555
	/* end block 2 */
	// End Line: 556
			UNIMPLEMENTED();
}

void razSetFadeEffect(short source, short dest, int steps)
{
	Raziel.effectsFadeSource = source;

	Raziel.effectsFadeDest = dest;

	Raziel.effectsFadeSteps = 0;

	Raziel.effectsFadeStep = steps;

	Raziel.effectsFlags |= 0x3;
}

int razPlaneShift(struct _Instance *instance)
{
	if (!(gameTrackerX.streamFlags & 0x40000))
	{
		if (Raziel.CurrentPlane == 1)
		{
			razSpectralShift();

			return 1;
		}
		else
		{
			razMaterialShift();

			return 1;
		}
	}

	return 0;
}

void razSpectralShift()
{
	struct _Instance* inst;

	if (!(gameTrackerX.streamFlags & 0x40000))
	{
		if (Raziel.CurrentPlane == 1)
		{
			inst = razGetHeldItem();

			if (inst != NULL)
			{
				INSTANCE_Post(inst, 0x800008, 4);

				razSetFadeEffect(4096, 0, 256);
			}

			gameTrackerX.playerInstance->flags2 |= 0x8000000;

			INSTANCE_Post(gameTrackerX.playerInstance, 0x100014, 0);

			if (Raziel.HitPoints == GetMaxHealth())
			{
				Raziel.HitPoints = 0x186A0;
			}
			else
			{
				Raziel.HitPoints = 0x14586;
			}

			Raziel.CurrentPlane = 2;

			razReaverOn();

			if (gameTrackerX.gameData.asmData.MorphType == 0)
			{
				MORPH_ToggleMorph();

				if (Raziel.State.SectionList[0].Process != StateHandlerGlyphs &&
					Raziel.State.SectionList[0].Process != StateHandlerPuppetShow)
				{
					INSTANCE_Post(gameTrackerX.playerInstance, 0x40005, 0);
				}
			}
		}
	}
}

void razMaterialShift()
{
	if (Raziel.CurrentPlane == 2)
	{
		if (Raziel.HitPoints == 100000)
		{
			Raziel.CurrentPlane = 1;

			gameTrackerX.playerInstance->flags &= 0xF7FFFFFF;

			Raziel.HitPoints = GetMaxHealth();

			Raziel.DamageFrequency = 0;

			razReaverOn();

			if (gameTrackerX.gameData.asmData.MorphType != 0)
			{
				MORPH_ToggleMorph();

				if (Raziel.State.SectionList[0].Process != StateHandlerGlyphs &&
					Raziel.State.SectionList[0].Process != StateHandlerPuppetShow)
				{
					INSTANCE_Post(gameTrackerX.playerInstance, 0x40005, 0);
				}

				if (Raziel.Senses.Portal != NULL)
				{
					FX_EndInstanceParticleEffects(Raziel.Senses.Portal);
				}
			}
		}
	}
}

int RAZIEL_OkToShift()
{
	if (Raziel.CurrentPlane == 2)
	{
		if (GetMaxHealth() == Raziel.HitPoints)
		{
			if ((Raziel.Abilities & 0x40))
			{
				if (!(Raziel.Abilities & 0x10))
				{
					FONT_Print("\nYOU CAN NOT HAVE SHIFT ANYTIME WITHOUT THE SWIM ABILITY");
					FONT_Print("\nBEAT THE ALUKA BOSS THEN WIN THE SECOND KAIN ENCOUNTER");

					return 0;
				}
				else
				{
					return 1;
				}
			}
			else
			{
				return 0 < (Raziel.Senses.Flags & 0x40);
			}
		}
		else
		{
			return 0;
		}
	}

	return 1;
}


// autogenerated function stub: 
// int /*$ra*/ razPickupAndGrab(struct __CharacterState *In /*$s1*/, int CurrentSection /*$s2*/)
int razPickupAndGrab(struct __CharacterState *In, int CurrentSection)
{ // line 409, offset 0x800a5a44
	UNIMPLEMENTED();
	return 0;
}

int razZeroAxis(long* x, long* y, int radius)//Matching - 99.79%
{
	unsigned long distance;

	distance = MATH3D_SquareLength(*x, *y, 0);

	if ((int)distance < radius)
	{
		distance = 0;

		*x = 0;
		*y = 0;
	}

	return distance;
}

int razAdjustSpeed(struct _Instance* instance, int minSpeed)//Matching - 90.51%
{
	long adjustment;
	int data;

	if (Raziel.movementMaxAnalog < Raziel.Magnitude)
	{
		adjustment = Raziel.movementMaxRate;
	}
	else if (Raziel.Magnitude < Raziel.movementMinAnalog)
	{
		adjustment = Raziel.movementMinRate;
	}
	else
	{
		adjustment = Raziel.movementMaxRate - ((Raziel.movementMaxRate - Raziel.movementMinRate) * (Raziel.movementMaxAnalog - Raziel.Magnitude)) / (Raziel.movementMaxAnalog - Raziel.movementMinAnalog);
	}

	G2Anim_SetSpeedAdjustment(&instance->anim, adjustment);

	return adjustment;
}


// autogenerated function stub: 
// void /*$ra*/ razLaunchForce(struct _Instance *instance /*$s0*/)
void razLaunchForce(struct _Instance *instance)
{ // line 558, offset 0x800a5d50
	UNIMPLEMENTED();
}

struct _Instance* razGetHeldItem()
{
	struct _Instance* instance;

	instance = Raziel.State.CharacterInstance->LinkChild;

	if (Raziel.soulReaver && instance == Raziel.soulReaver && instance != NULL)
	{
		instance = instance->LinkSibling;
	}

	return instance;
}

struct _Instance* razGetHeldWeapon()
{
	struct _Instance* instance;

	instance = razGetHeldItem();

	if (instance == NULL)
	{
		if (Raziel.Senses.heldClass != 0)
		{
			return Raziel.soulReaver;
		}
	}
	else
	{
		if ((INSTANCE_Query(instance, 0x1) & 0x20))
		{
			return instance;
		}
	}

	return NULL;
}

void razReaverBladeOff()
{
	if (Raziel.soulReaver != NULL)
	{
		INSTANCE_Post(Raziel.soulReaver, 0x800109, 2);
	}
}

void razReaverBladeOn()
{
	if (Raziel.soulReaver != NULL && razGetHeldItem() == NULL)
	{
		INSTANCE_Post(Raziel.soulReaver, 0x800108, 2);
	}
}

int razReaverOff()//Matching - 95.86%
{
	struct _Instance* HeldWeapon;

	if (Raziel.soulReaver != NULL)
	{
		if (Raziel.Senses.heldClass == 4096)
		{
			HeldWeapon = razGetHeldWeapon();

			if ((INSTANCE_Query(Raziel.soulReaver, 0x28) & 0x1) != 0)
			{
				INSTANCE_Post(Raziel.soulReaver, 0x800101, 0);
			}
			if (HeldWeapon == Raziel.soulReaver)
			{
				Raziel.Senses.heldClass = 0;
			}
			return 1;
		}
	}

	return 0;
}

int razReaverOn()
{
	if (Raziel.soulReaver != NULL)
	{
		if (razGetHeldItem() == NULL)
		{
			if (GetMaxHealth() == Raziel.HitPoints || Raziel.CurrentPlane == 2)
			{
				if (!(INSTANCE_Query(Raziel.soulReaver, 0x28) & 0x1))
				{
					INSTANCE_Post(Raziel.soulReaver, 0x800100, 0);
				}
				
				Raziel.Senses.heldClass = 4096;

				if (Raziel.CurrentPlane == 2 && Raziel.currentSoulReaver != 1)
				{
					razReaverImbue(1);
				}
				
				if (Raziel.CurrentPlane == 1 && Raziel.currentSoulReaver == 1)
				{
					razReaverImbue(2);
				}
				
				return 1;
			}

			return 2;
		}
	}
	
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ razReaverPickup(struct _Instance *instance /*$a2*/, struct _Instance *soulReaver /*$s0*/)
void razReaverPickup(struct _Instance *instance, struct _Instance *soulReaver)
{ // line 691, offset 0x800a6054
	UNIMPLEMENTED();
}

void razReaverImbue(int reaverType)
{
	Raziel.currentSoulReaver = reaverType;

	debugRazielFlags2 = 1 << (reaverType + 9);

	INSTANCE_Post(Raziel.soulReaver, 0x800103, reaverType);
}

int razGetReaverFromMask(int reaverMask)
{
	int rc;

	rc = 0;

	reaverMask <<= 10;
	reaverMask &= 0xFF;

	while (reaverMask)
	{
		reaverMask >>= 1;
		rc++;
	}

	return rc;
}

void razReaverScale(int scale)
{
	struct _Instance* Inst;

	Inst = razGetHeldWeapon();

	if (Raziel.soulReaver != NULL && Inst == Raziel.soulReaver &&
		INSTANCE_Query(Inst, 0x28) & 0x2)
	{
		INSTANCE_Post(Inst, 0x800107, scale);
	}
}


// autogenerated function stub: 
// void /*$ra*/ razGetForwardNormal(struct _Instance *inst /*$a0*/, struct _Instance *target /*$a1*/)
void razGetForwardNormal(struct _Instance *inst, struct _Instance *target)
{ // line 760, offset 0x800a61f4
	UNIMPLEMENTED();
}

void razGetRotFromNormal(struct _SVector* normal, struct _Rotation* rot)//Matching - 99.74%
{
	struct _Position a;
	struct _Position b;

	a.x = normal->x;
	a.y = normal->y;
	a.z = normal->z;
	
	b.z = 0;
	b.y = 0;
	b.x = 0;
	
	MATH3D_RotationFromPosToPos(&a, &b, rot);
}


// autogenerated function stub: 
// void /*$ra*/ razCenterWithBlock(struct _Instance *inst /*$s3*/, struct _Instance *target /*$s1*/, int dist /*$s2*/)
void razCenterWithBlock(struct _Instance *inst, struct _Instance *target, int dist)
{ // line 811, offset 0x800a6324
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ razSetPauseTranslation(struct _Instance *instance /*$a0*/)
void razSetPauseTranslation(struct _Instance *instance)
{ // line 870, offset 0x800a64f4
	UNIMPLEMENTED();
}

void razResetPauseTranslation(struct _Instance* instance)
{
	if (G2Anim_IsControllerActive(&instance->anim, 0, 0x22))
	{
		G2Anim_DisableController(&instance->anim, 0, 0x22);
	}

	ControlFlag &= 0xDFFFFFFF;
}

void razSelectMotionAnim(struct __CharacterState* In, int CurrentSection, int Frames, int* Anim)//Matching - 95.73%
{
	struct _G2SVector3_Type Vec;
	int switchType;
	int frame;
	int adjustment;
	struct _G2AnimSection_Type* animSectionA;
	struct _G2AnimSection_Type* animSectionB;
	struct _G2AnimKeylist_Type* keylist;
	int keylistID;

	switchType = 0;

	frame = 0;

	if (Raziel.Magnitude >= 3769)
	{
		if (Raziel.nothingCounter == 0)
		{
			ControlFlag &= 0xFFFFDFFF;
		}

		if ((ControlFlag & 0x20000000))
		{
			razResetPauseTranslation(In->CharacterInstance);
		}

		if (Anim[0] == 60)
		{
			if ((Raziel.passedMask & 0xF))
			{
				switchType = 3;
			}

			if ((Raziel.passedMask & 0x8))
			{
				frame = 5;
			}

			if ((Raziel.passedMask & 0x1))
			{
				frame = 23;
			}

			if ((Raziel.passedMask & 0x2))
			{
				frame = 17;
			}

			if ((Raziel.passedMask & 0x4))
			{
				frame = 11;
			}
		}
		else if (Anim[0] == 64)
		{
			if ((Raziel.passedMask & 0xF0))
			{
				switchType = 3;
			}

			if ((Raziel.passedMask & 0x80))
			{
				frame = 5;
			}

			if ((Raziel.passedMask & 0x10))
			{
				frame = 23;
			}

			if ((Raziel.passedMask & 0x20))
			{
				frame = 17;
			}

			if ((Raziel.passedMask & 0x40))
			{
				frame = 11;
			}
		}
		else if (Anim[0] != 68)
		{
			switchType = 3;
		}
	}
	else
	{
		if ((unsigned)(Raziel.Magnitude - 2784) < 985)
		{
			ControlFlag &= 0xFFFFDFFF;

			if ((ControlFlag & 0x20000000))
			{
				razResetPauseTranslation(In->CharacterInstance);
			}

			if (Anim[0] == 60)
			{
				if ((Raziel.passedMask & 0xF))
				{
					switchType = 2;
				}

				if ((Raziel.passedMask & 0x8))
				{
					frame = 7;
				}

				if ((Raziel.passedMask & 0x1))
				{
					frame = 13;
				}

				if ((Raziel.passedMask & 0x2))
				{
					frame = 20;
				}

				if ((Raziel.passedMask & 0x4))
				{
					frame = 25;
				}
			}
			else if (Anim[0] == 68)
			{
				if ((Raziel.passedMask & 0xF00))
				{
					switchType = 2;
				}

				if ((Raziel.passedMask & 0x800))
				{
					frame = 7;
				}

				if ((Raziel.passedMask & 0x100))
				{
					frame = 13;
				}

				if ((Raziel.passedMask & 0x200))
				{
					frame = 20;
				}

				if ((Raziel.passedMask & 0x400))
				{
					frame = 25;
				}
			}
			else if (Anim[0] != 64)
			{
				switchType = 2;
			}
		}
		else if (Raziel.Magnitude < 2784)
		{
			ControlFlag |= 0x2000;

			if (Anim[0] == 64)
			{
				if ((Raziel.passedMask & 0xF0))
				{
					switchType = 1;
				}

				if ((Raziel.passedMask & 0x80))
				{
					frame = 12;
				}

				if ((Raziel.passedMask & 0x10))
				{
					frame = 20;
				}

				if ((Raziel.passedMask & 0x20))
				{
					frame = 32;
				}

				if ((Raziel.passedMask & 0x40))
				{
					frame = 0;
				}
			}
			else if (Anim[0] == 68)
			{
				if ((Raziel.passedMask & 0xF00))
				{
					switchType = 1;
				}

				if ((Raziel.passedMask & 0x800))
				{
					frame = 12;
				}

				if ((Raziel.passedMask & 0x100))
				{
					frame = 20;
				}

				if ((Raziel.passedMask & 0x200))
				{
					frame = 32;
				}

				if ((Raziel.passedMask & 0x400))
				{
					frame = 0;
				}
			}
			else if (Anim[0] != 60)
			{
				switchType = 1;
			}
		}
	}

	switch (switchType)
	{
	case 1:
	{
		if (CurrentSection == 2)
		{
			Raziel.passedMask = 0;
		}

		if (razSwitchVAnimGroup(In->CharacterInstance, CurrentSection, 60, frame, Frames) != 0)
		{
			G2EmulationSwitchAnimation(In, CurrentSection, 123, frame, Frames, 2);
		}

		Raziel.movementMinRate = 4096;

		Raziel.movementMaxRate = 7168;

		Raziel.movementMinAnalog = 2300;

		Raziel.movementMaxAnalog = 2783;

		Anim[0] = 60;

		break;
	}
	case 2:
	{
		if (CurrentSection == 2)
		{
			Raziel.passedMask = 0;
		}

		if ((razSwitchVAnimGroup(In->CharacterInstance, CurrentSection, 64, frame, Frames)) != 0)
		{
			G2EmulationSwitchAnimation(In, CurrentSection, 124, frame, Frames, 2);
		}

		Raziel.movementMinRate = 3276;

		Raziel.movementMaxRate = 6144;

		Raziel.movementMinAnalog = 2783;

		Raziel.movementMaxAnalog = 3768;

		Anim[0] = 64;

		break;
	}
	case 3:
	{
		if (CurrentSection == 2)
		{
			Raziel.passedMask = 0;
		}

		if ((razSwitchVAnimGroup(In->CharacterInstance, CurrentSection, 68, frame, Frames) != 0))
		{
			G2EmulationSwitchAnimation(In, CurrentSection, 2, frame, Frames, 2);
		}

		Raziel.movementMinRate = 3547;

		Raziel.movementMaxAnalog = 4096;

		Raziel.movementMinAnalog = 3768;

		Raziel.movementMaxRate = 4096;

		Anim[0] = 68;

		break;
	}
	}

	if (CurrentSection == 0)
	{
		if (!(ControlFlag & 0x20000000))
		{
			Vec.z = 0;
			Vec.x = 0;

			switch (Anim[0])
			{
			case 0x40:
			{
				Vec.y = -35;
				break;
			}
			case 0x3C:
			{
				Vec.y = -16;
				break;
			}
			case 0x44:
			{
				Vec.y = -60;
				break;
			}
			}

			adjustment = razAdjustSpeed(In->CharacterInstance, 1);

			Vec.y = (((Vec.y * (short)G2Timer_GetFrameTime()) * adjustment) >> 12) / 100;

			if (G2Anim_IsControllerActive(&In->CharacterInstance->anim, 0, 0x22) == 0)
			{
				G2Anim_EnableController(&In->CharacterInstance->anim, 0, 0x22);
			}

			G2Anim_SetController_Vector(&In->CharacterInstance->anim, 0, 0x22, &Vec);
		}

		if (CurrentSection != 0)
		{
			Frames = 6;

			if ((void*)In->SectionList[0].Process == (void*)&StateHandlerMove)
			{
				animSectionA = &In->CharacterInstance->anim.section[0];
				animSectionB = &In->CharacterInstance->anim.section[CurrentSection];

				if (G2AnimSection_IsInInterpolation(animSectionA) == 0 && G2AnimSection_IsInInterpolation(animSectionB) == 0)
				{
					if (G2AnimSection_GetKeyframeNumber(animSectionA) != G2AnimSection_GetKeyframeNumber(animSectionB))
					{
						keylist = animSectionA->keylist;
						keylistID = animSectionA->keylistID;

						frame = (G2AnimSection_GetKeyframeNumber(animSectionA) + Frames) % G2AnimKeylist_GetKeyframeCount(keylist);

						if (razSwitchVAnimGroup(In->CharacterInstance, CurrentSection, Anim[0], frame, Frames) != 0)
						{
							G2AnimSection_InterpToKeylistFrame(animSectionB, keylist, keylistID, frame, 600);
						}
					}
				}
			}
		}
	}
	else
	{
		Frames = 6;

		if ((void*)In->SectionList[0].Process == (void*)&StateHandlerMove)
		{
			animSectionA = &In->CharacterInstance->anim.section[0];
			animSectionB = &In->CharacterInstance->anim.section[CurrentSection];

			if (G2AnimSection_IsInInterpolation(animSectionA) == 0 && G2AnimSection_IsInInterpolation(animSectionB) == 0)
			{
				if (G2AnimSection_GetKeyframeNumber(animSectionA) != G2AnimSection_GetKeyframeNumber(animSectionB))
				{
					keylist = animSectionA->keylist;
					keylistID = animSectionA->keylistID;

					frame = (G2AnimSection_GetKeyframeNumber(animSectionA) + Frames) % G2AnimKeylist_GetKeyframeCount(keylist);

					if (razSwitchVAnimGroup(In->CharacterInstance, CurrentSection, Anim[0], frame, Frames) != 0)
					{
						G2AnimSection_InterpToKeylistFrame(animSectionB, keylist, keylistID, frame, 600);
					}
				}
			}
		}
	}
}


// autogenerated function stub: 
// int /*$ra*/ razApplyMotion(struct __CharacterState *In /*$s1*/, int CurrentSection /*$s0*/)
int razApplyMotion(struct __CharacterState *In, int CurrentSection)
{ // line 1199, offset 0x800a6c30
	UNIMPLEMENTED();
	return 0;
}

void razResetMotion(struct _Instance *instance)
{
	if ((G2Anim_IsControllerActive(&instance->anim, 0, 0x22)) != 0)
	{
		G2Anim_DisableController(&instance->anim, 0, 0x22);
	}

	Raziel.passedMask = 0;

	G2Anim_SetSpeedAdjustment(&instance->anim, 4096);
}

void razSetDampingPhysics(struct _Instance* instance)
{
	Raziel.RotationSegment = 0;
	
	Raziel.extraRot.x = 0;

	PhysicsMode = 4;

	SetDampingPhysics(instance, PlayerData->SwimPhysicsFallDamping);
}

void razEnterWater(struct __CharacterState* In, int CurrentSection, struct evPhysicsSwimData* SwimData) // Matching 99.70%
{
	struct _Instance* Inst;
	Inst = razGetHeldWeapon();

	if ((SwimData->rc & 0x10) != NULL)
	{
		if ((Raziel.CurrentPlane == 1) && (Raziel.Abilities & 0x10) == NULL)
		{
			Raziel.HitPoints = 0x10000 | 0x86A0;
			SetPhysics(In->CharacterInstance, -16, NULL, NULL, NULL);
			PhysicsMode = NULL;
		}
		else if (Inst != NULL && INSTANCE_Query(Inst, 4) == 3)
		{
			G2Anim_SetSpeedAdjustment(&In->CharacterInstance->anim, 2048);
		}
		else if (((Raziel.Mode & 0x40000) == NULL) && (Raziel.CurrentPlane == 1))
		{
			if (PhysicsMode != 4)
			{
				razSetDampingPhysics(In->CharacterInstance);
			}

			if (In->CharacterInstance->zVel == NULL || (Raziel.Mode & 0x400004) != NULL)
			{
				razResetMotion(In->CharacterInstance);
				StateSwitchStateCharacterData(In, StateHandlerSwim, NULL);
			}

			TrailWaterFX(In->CharacterInstance, 9, 1, 1);
			TrailWaterFX(In->CharacterInstance, 13, 1, 1);
			TrailWaterFX(In->CharacterInstance, 31, 1, 1);
			TrailWaterFX(In->CharacterInstance, 41, 1, 1);
		}
	}

	if (((SwimData->rc & 0x800) != NULL) && (Raziel.Senses.heldClass == 1))
	{
		if (CurrentSection == 2)
		{
			G2EmulationSwitchAnimation(In, CurrentSection, 61, NULL, 3, 2);
		}
		else
		{
			G2EmulationSwitchAnimation(In, CurrentSection, 63, NULL, 16, 2);
		}
	}

	if (((SwimData->rc & 0x100) != NULL) && (CurrentSection == NULL))
	{
		if (Inst != NULL)
		{
			INSTANCE_Query(Inst, 4);
		}
		else
		{
			razSetDampingPhysics(In->CharacterInstance);
		}

		PurgeMessageQueue(&In->SectionList[CurrentSection].Event);
		TrailWaterFX(In->CharacterInstance, 9, 4, 1);
		TrailWaterFX(In->CharacterInstance, 13, 4, 1);
	}
}

void _razSetSwimVelocity(struct _Instance* instance, int vel, int accl)//Matching - 99.76%
{
	instance->yAccl = 0;
	instance->xAccl = 0;
	instance->yVel = 0;
	instance->xVel = 0;

	Raziel.swimTargetSpeed = (short)(vel * instance->anim.section[0].speedAdjustment / 4096);

	if (vel < instance->zVel)
	{
		instance->zAccl = -accl;
	}
	else
	{
		instance->zAccl = accl;
	}
}


// autogenerated function stub: 
// void /*$ra*/ razSetWallCrawlNodes(struct _Instance *instance /*$s1*/, struct evPhysicsWallCrawlData *data /*$s0*/)
void razSetWallCrawlNodes(struct _Instance *instance, struct evPhysicsWallCrawlData *data)
{ // line 1455, offset 0x800a7144
	UNIMPLEMENTED();
}


int razSwitchVAnimCharacterGroup(struct _Instance* instance, int animGroup, int* frame, int* frames)//Matching - 87.92%
{
	int i;
	int rc;
	int temp[3] = { 255, 255, 255 };

	if (frame == NULL)
	{
		frame = temp;
	}

	if (frames == NULL)
	{
		frames = temp;
	}

	for (i = 0; i < 3; i++)
	{
		rc = razSwitchVAnimGroup(instance, i, animGroup, frame[i], frames[i]);
	}

	return rc;
}

int razSwitchVAnimGroup(struct _Instance* instance, int section, int animGroup, int frame, int frames)//Matching - 99.35%
{
	int index;
	int rc;

	rc = 1;

	if (Raziel.Senses.heldClass != 0)
	{
		index = Raziel.Senses.heldClass - 1;

		if (index >= 3)
		{
			index = 3;
		}

		animGroup += index;

		razSwitchVAnim(instance, section, &PlayerData->virtualAnimations[animGroup], frame, frames);

		rc = 0;
	}
	
	return rc;
}


// autogenerated function stub: 
// void /*$ra*/ razSwitchVAnimCharacterSingle(struct _Instance *instance /*$s3*/, int anim /*$s4*/, int *frame /*$a2*/, int *frames /*$a3*/)
void razSwitchVAnimCharacterSingle(struct _Instance *instance, int anim, int *frame, int *frames)
{ // line 1561, offset 0x800a7348
	/* begin block 1 */
		// Start line: 1562
		// Start offset: 0x800A7348
		// Variables:
			int i; // $s0
			int temp[3]; // stack offset -40
	/* end block 1 */
	// End offset: 0x800A73E0
	// End Line: 1574

	/* begin block 2 */
		// Start line: 3336
	/* end block 2 */
	// End Line: 3337
			UNIMPLEMENTED();
}

void razSwitchVAnimSingle(struct _Instance* instance, int section, int anim, int frame, int frames)//Matching - 99.23%
{
	razSwitchVAnim(instance, section, &PlayerData->virtualAnimSingle[anim], frame, frames);
}

void razSwitchVAnim(struct _Instance* instance, int section, struct __VAnim* vAnim, int frame, int frames)//Matching - 99.90%
{
	if (frame == -1)
	{
		frame = vAnim->frame;
	}

	if (frames == -1)
	{
		frames = vAnim->frames;
	}

	switch (section)
	{
	case 0:
	{
		G2EmulationInstanceSwitchAnimationAlpha(instance, 0, vAnim->anim0, frame, frames, vAnim->mode, vAnim->alpha);
		break;
	}
	case 1:
	{
		G2EmulationInstanceSwitchAnimationAlpha(instance, 1, vAnim->anim1, frame, frames, vAnim->mode, vAnim->alpha);
		break;
	}
	case 2:
	{
		G2EmulationInstanceSwitchAnimationAlpha(instance, 2, vAnim->anim2, frame, frames, vAnim->mode, vAnim->alpha);
		break;
	}
	}
}

int razProcessSAnim(struct _Instance* instance, int mode)
{
	int rc;
	struct __SAnim* nextAnim;
	struct __VAnim* vanim;
	int i;

	rc = 0;

	switch (mode)
	{
	case 0x8000000:
		if (Raziel.currentSAnim->mode == 1)
		{
			rc = 1;
		}
		break;
	case 0x100015:
		if (Raziel.currentSAnim->mode == 2)
		{
			rc = 1;
		}
		break;
	case 0x8000003:
		if (Raziel.currentSAnim->mode == 3)
		{
			rc = 1;
		}
		break;
	}

	if (rc)
	{
		nextAnim = Raziel.currentSAnim->nextAnim;
		if (nextAnim)
		{
			Raziel.currentSAnim = Raziel.currentSAnim->nextAnim;
			vanim = nextAnim->anim;
			if (vanim)
			{
				for (i = 0; i < 3; i++)
				{
					razSwitchVAnim(instance, i, vanim, -1, -1);
					G2Anim_SetSpeedAdjustment(&instance->anim, Raziel.currentSAnim->speedAdjust);
				}
				if (Raziel.currentSAnim->mode == 2)
				{
					SetTimer(Raziel.currentSAnim->data);
				}
			}
		}
		else
		{
			G2Anim_SetSpeedAdjustment(&instance->anim, 4096);
			Raziel.currentSAnim = NULL;
			rc = 0;
		}

	}
	return rc;
}

void razSwitchStringAnimation(struct _Instance* instance, int anim)
{
	struct __VAnim* vanim;
	int i;
	
	Raziel.currentSAnim = PlayerData->stringAnimations[anim];

	vanim = Raziel.currentSAnim->anim;

	if (vanim != NULL)
	{
		for (i = 0; i < 3; i++)
		{
			razSwitchVAnim(instance, i, vanim, -1, -1);
		}

		G2Anim_SetSpeedAdjustment(&instance->anim, Raziel.currentSAnim->speedAdjust);

		if (Raziel.currentSAnim->mode == 2)
		{
			SetTimer(Raziel.currentSAnim->data);
		}
	}
}

int CheckStringAnimation(struct _Instance* instance, int mode)//Matching - 99.17%
{
	int rc;

	rc = 0;
	if (Raziel.currentSAnim == NULL || (rc = razProcessSAnim(instance, mode), Raziel.currentSAnim == NULL))
	{
		INSTANCE_Post(instance, 0x100000, 0);
	}

	return rc;
}


// autogenerated function stub: 
// void /*$ra*/ razLaunchBubbles(int segments /*$s2*/, int count /*$s0*/, int type /*$s1*/)
void razLaunchBubbles(int segments, int count, int type)
{ // line 1752, offset 0x800a77a0
	/* begin block 1 */
		// Start line: 3504
	/* end block 1 */
	// End Line: 3505
	UNIMPLEMENTED();
}

void razSetCowlNoDraw(int mode)
{
#if 0
	sub_800A76C4:
	move    $t0, $a0
		addiu   $a2, $gp, -0x595C
		addiu   $a3, $gp, -0x5936

		loc_800A76D0 :
		beqz    $t0, loc_800A7718
		nop
		lw      $v0, -0x420C($gp)
		lhu     $a1, 0($a2)
		lh      $a0, 0x126($v0)
		lw      $v0, 0x1C($v0)
		sll     $v1, $a1, 1
		lw      $v0, 0xC($v0)
		sll     $a0, 2
		addu    $a0, $v0
		lw      $v0, 0($a0)
		addu    $v1, $a1
		lw      $v0, 0x14($v0)
		sll     $v1, 2
		addu    $v1, $v0
		lbu     $v0, 7($v1)
		j       loc_800A7758
		ori     $v0, 0x10

		loc_800A7718:
	lw      $v0, -0x420C($gp)
		lhu     $a1, 0($a2)
		lh      $a0, 0x126($v0)
		lw      $v0, 0x1C($v0)
		sll     $v1, $a1, 1
		lw      $v0, 0xC($v0)
		sll     $a0, 2
		addu    $a0, $v0
		lw      $v0, 0($a0)
		addu    $v1, $a1
		lw      $v0, 0x14($v0)
		sll     $v1, 2
		addu    $v1, $v0
		lbu     $v0, 7($v1)
		nop
		andi    $v0, 0xEF

		loc_800A7758:
	sb      $v0, 7($v1)
		addiu   $a2, 2
		slt     $v0, $a2, $a3
		bnez    $v0, loc_800A76D0
		nop
		jr      $ra
		nop
#endif
}

void razAttachControllers()
{
	int i;
	
	for (i = 0; i < 24; i++)
	{
		G2Anim_AttachControllerToSeg(&gameTrackerX.playerInstance->anim, controllerList[i].segment, controllerList[i].type);
		G2Anim_DisableController(&gameTrackerX.playerInstance->anim, controllerList[i].segment, controllerList[i].type);
	}
}

void razSetPlayerEvent()
{
	void (*process)(struct __CharacterState*, int, int);
	int message;
	int data;

	process = Raziel.State.SectionList[0].Process;
	
	message = 0;
	
	data = 0;

	if ((Raziel.Senses.EngagedMask & 0x1))
	{
		if (Raziel.Senses.heldClass != 3 && process == &StateHandlerIdle)
		{
			Raziel.playerEvent |= 0x1;
		}
	}

	if ((Raziel.Senses.EngagedMask & 0x4))
	{
		if (Raziel.Senses.heldClass != 3 && process == &StateHandlerCrouch)
		{
			Raziel.playerEvent |= 0x2;
		}
	}

	if ((Raziel.Senses.EngagedMask & 0x8))
	{
		if (Raziel.Senses.heldClass != 3 && process == &StateHandlerIdle)
		{
			if (INSTANCE_Query(Raziel.Senses.EngagedList[3].instance, 0x4) == 9)
			{
				Raziel.playerEvent |= 0x8;
			}
			else
			{
				Raziel.playerEvent |= 0x4;
			}
		}
	}

	if ((Raziel.Senses.EngagedMask & 0x20))
	{
		if (razGetHeldItem() == NULL)
		{
			if (Raziel.CurrentPlane == 1)
			{
				if (process == &StateHandlerIdle ||
					process == &StateHandlerStartMove ||
					process == &StateHandlerMove ||
					process == &StateHandlerJump ||
					process == &StateHandlerFall ||
					process == &StateHandlerSwim ||
					process == &StateHandlerAutoFace)
				{
					Raziel.playerEvent |= 0x10;
				}
			}
		}
	}

	if ((Raziel.Senses.EngagedMask & 0x40))
	{
		if (!(INSTANCE_Query(Raziel.Senses.EngagedList[6].instance, 0xA) & 0x4))
		{
			Raziel.playerEvent |= 0x20;
		}
	}

	if (StateHandlerDecodeHold(&message, &data) != 0 && data != 0)
	{
		if (message == 0x1000002)
		{
			Raziel.playerEvent |= 0x40;
		}

		if (message == 0x100000A)
		{
			Raziel.playerEvent |= 0x80;
		}

		if (message == 0x1000018)
		{
			Raziel.playerEvent |= 0x100;
		}
	}

	if ((Raziel.Mode & 0x20000) && (unsigned int)(Raziel.Senses.heldClass - 1) < 3)
	{
		Raziel.playerEvent |= 0x200;
	}

	if (message == 0x80000)
	{
		Raziel.playerEvent |= 0x400;
	}

	if ((Raziel.Senses.EngagedMask & 0x4000))
	{
		Raziel.playerEvent |= 0x800;
	}

	if ((Raziel.Senses.Flags & 0x40))
	{
		Raziel.playerEvent |= 0x2000;
	}
}

void razClearPlayerEvent()
{ 
	if ((ControlFlag & 0x100000))
	{
		Raziel.playerEvent &= 0x2000;

		return;
	}

	Raziel.playerEvent = 0;
}

void razSetPlayerEventHistory(unsigned long event)
{
	Raziel.playerEventHistory |= event;
}


// autogenerated function stub: 
// int /*$ra*/ razSideMoveSpiderCheck(struct _Instance *instance /*$s2*/, int x /*$a1*/)
int razSideMoveSpiderCheck(struct _Instance *instance, int x)
{ // line 1905, offset 0x800a7cac
	UNIMPLEMENTED();
	return 0;
}

struct _Instance* RAZIEL_QueryEngagedInstance(int index)
{
	if (!(Raziel.Senses.EngagedMask & (1 << index)))
	{
		return NULL;
	}
	else
	{
		return Raziel.Senses.EngagedList[index].instance;
	}
}


// autogenerated function stub: 
// int /*$ra*/ razUpdateSoundRamp(struct _Instance *instance /*$a0*/, struct _SoundRamp *sound /*$s0*/)
int razUpdateSoundRamp(struct _Instance *instance, struct _SoundRamp *sound)
{ // line 1955, offset 0x800a7db0
	UNIMPLEMENTED();
	return 0;
}


void razSetupSoundRamp(struct _Instance* instance, struct _SoundRamp* sound, int sfx, int startPitch, int endPitch, int startVolume, int endVolume, int timer, int distance)  // Matching - 100%
{
	if (sound->soundHandle == 0)
	{
		sound->soundHandle = SOUND_Play3dSound(&instance->position, sfx, startPitch, startVolume, distance);
	}
	if (timer == 0)
	{
		sound->soundHandle = 0;
	}
	sound->soundStartPitch = startPitch;
	sound->soundEndPitch = endPitch;
	sound->soundStartVolume = startVolume;
	sound->soundEndVolume = endVolume;
	sound->soundDistance = distance;
	sound->soundTotalTime = timer;
	sound->soundTimer = 0;
}

void RAZIEL_SetInteractiveMusic(int modifier, int action)
{
	int soundFlag;

	soundFlag = 1 << modifier;

	if (action != 0)
	{
		if (!(Raziel.soundModifier & soundFlag))
		{
			SOUND_SetMusicModifier(modifier);
		}

		Raziel.soundModifier |= soundFlag;
	}
	else
	{
		if ((Raziel.soundModifier & soundFlag))
		{
			SOUND_ResetMusicModifier(modifier);
		}

		Raziel.soundModifier &= ~soundFlag;
	}
}

void RAZIEL_DebugHurtRaziel()
{
	LoseHealth(4096);
}

void RAZIEL_StartNewGame()
{
	memset(&Raziel, 0, sizeof(Raziel));
}

int razInBaseArea(char* name, int length)
{
	char string[9];
	
	if (strcpy(string, gameTrackerX.baseAreaName) != NULL)
	{
		string[length] = 0;
	}
	
	return strcmp(name, string) == 0;
}

void razPrepGlyph()
{
	struct _Instance* heldInst;
	
	razReaverOff();

	heldInst = razGetHeldItem();

	if (heldInst != NULL)
	{
		razSetFadeEffect(0, 4096, 256);

		Raziel.throwInstance = heldInst;
	}

	ControlFlag |= 0x4000;
}
