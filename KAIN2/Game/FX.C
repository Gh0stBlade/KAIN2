#include "CORE.H"
#include "FX.H"
#include "OBTABLE.H"
#include "MATH3D.H"
#include "PIPE3D.H"
#include "PSX/COLLIDES.H"
#include "Game/MEMPACK.H"
#include "Game/LIST.H"
#include "Game/GLYPH.H"
#include "Game/DRAW.H"
#include "Game/LIGHT3D.H"

struct _FXBlastringEffect* fx_blastring;
struct _Instance* FX_reaver_instance;
short fx_going;
struct _FXGeneralEffect* FX_GeneralEffectTracker;
short snow_amount;
short rain_amount;
short current_rain_fade;
struct _FX_PRIM* FX_LastUsedPrim;
short Spiral_Number;
short Spiral_Degrees;
long Spiral_Current;
long Spiral_Max = 100000;
DVECTOR Spiral_Array[65]; // offset 0x800d3968
DVECTOR Spiral_OffsetP[64]; // offset 0x800d3a78
DVECTOR Spiral_OffsetM[64];
int Spiral_Glow_X; // offset 0x800d3c78
int Spiral_Glow_Y; // offset 0x800d3c7c
int Spiral_Glow_Size; // offset 0x800d3c80
int Spiral_Mod;
struct _FXTracker* gFXT;
struct _FXTracker* fxTracker;
struct _Position FX_ConstrictPosition; // offset 0x800d3948
struct _Position* FX_ConstrictPositionPtr;
short FX_Frames; // offset 0x800d3958
short FX_TimeCount;

void FX_Init(struct _FXTracker* fxTracker)
{
	struct _FX_MATRIX* fxMatrix;
	struct _FX_MATRIX* endFXMatrix;
	struct _FX_PRIM* fxPrim;
	struct _FX_PRIM* endFXPrim;

	fxMatrix = fxTracker->matrixPool;

	endFXMatrix = (struct _FX_MATRIX*)&fxTracker->usedMatrixList;

	fxTracker->usedMatrixList.next = 0;
	fxTracker->usedMatrixList.prev = 0;

	fxTracker->freeMatrixList.next = 0;
	fxTracker->freeMatrixList.prev = 0;

	fxTracker->usedPrimList.next = 0;
	fxTracker->usedPrimList.prev = 0;

	fxTracker->usedPrimListSprite.next = 0;
	fxTracker->usedPrimListSprite.prev = 0;

	fxTracker->freePrimList.next = 0;
	fxTracker->freePrimList.prev = 0;

	while (fxMatrix++ < endFXMatrix)
	{
		LIST_InsertFunc(&fxTracker->freeMatrixList, &fxMatrix->node);
	}

	fxPrim = fxTracker->primPool;

	endFXPrim = (struct _FX_PRIM*)fxTracker->usedPrimList.prev;

	while (fxPrim++ < endFXPrim)
	{
		LIST_InsertFunc(&fxTracker->freePrimList, &fxPrim->node);
	}

	FX_ConstrictPositionPtr = &FX_ConstrictPosition;

	FX_LastUsedPrim = NULL;

	FX_Spiral_Init();

	snow_amount = 0;

	rain_amount = 0;

	current_rain_fade = 0;

	FX_reaver_instance = NULL;

	FX_Frames = 1;

	FX_TimeCount = 0;
}


// autogenerated function stub: 
// void /*$ra*/ FX_Die(struct _FX_PRIM *fxPrim /*$s0*/, struct _FXTracker *fxTracker /*$s1*/)
void FX_Die(struct _FX_PRIM *fxPrim, struct _FXTracker *fxTracker)
{ // line 191, offset 0x80042034
#if defined(PC_VERSION)
	if (dword_C54BE8 == fxPrim)
	{
		dword_C54BE8 = (struct _FX_PRIM*)fxPrim->node.prev;
		if (!dword_C54BE8->node.prev)
			dword_C54BE8 = 0;
	}
	fxPrim->flags |= 0x10u;
	LIST_DeleteFunc(fxPrim);
	LIST_InsertFunc(&fxTracker->freePrimList, &fxPrim->node);
#else
	UNIMPLEMENTED();
#endif
}

struct _FX_MATRIX* FX_GetMatrix(struct _FXTracker* fxTracker)//Matching - 99.25%
{
#if defined(PSX_VERSION)
	struct _FX_MATRIX* fxMatrix;

	fxMatrix = (struct _FX_MATRIX*)LIST_GetFunc(&fxTracker->freeMatrixList);

	if (fxMatrix)
	{
		fxMatrix->flags = 0x1;

		LIST_InsertFunc(&fxTracker->usedMatrixList, &fxMatrix->node);
	}

	return fxMatrix;

#elif defined(PC_VERSION)
	struct NodeType* Func; // eax
	struct _FX_MATRIX* v2; // esi

	Func = LIST_GetFunc(&fxTracker->freeMatrixList);
	v2 = (struct _FX_MATRIX*)Func;
	if (Func)
	{
		Func[1].prev = (struct NodeType*)1;
		LIST_InsertFunc(&fxTracker->usedMatrixList, Func);
	}
	return v2;
#else
	UNIMPLEMENTED();
	return NULL;
#endif
}


// autogenerated function stub: 
// struct _FX_PRIM * /*$ra*/ FX_GetPrim(struct _FXTracker *fxTracker /*$a0*/)
struct _FX_PRIM * FX_GetPrim(struct _FXTracker *fxTracker)
{ // line 222, offset 0x800420f4
#if defined(PC_VERSION)
	struct _FX_PRIM* result; // eax

	result = (struct _FX_PRIM*)LIST_GetFunc(&fxTracker->freePrimList);
	if (result)
		goto LABEL_6;
	if (dword_C54BE8)
	{
		result = dword_C54BE8;
		dword_C54BE8 = (struct _FX_PRIM*)dword_C54BE8->node.prev;
		dword_C54BE8->node.next = 0;
		if (!dword_C54BE8->node.prev)
			dword_C54BE8 = 0;
	}
	if (result)
	{
	LABEL_6:
		result->process = 0;
		result->flags = 0;
		result->matrix = 0;
	}
	return result;
#else
	UNIMPLEMENTED();
	return NULL;
#endif
}


// autogenerated function stub: 
// struct _FXParticle * /*$ra*/ FX_GetParticle(struct _Instance *instance /*$s1*/, short startSegment /*$s0*/)
struct _FXParticle * FX_GetParticle(struct _Instance *instance, short startSegment)
{ // line 247, offset 0x80042164
#if defined(PC_VERSION)
	struct _FXParticle* result; // eax

	result = (struct _FXParticle*)MEMPACK_Malloc(0x4Cu, 0xDu);
	if (result)
	{
		result->effectType = 1;
		result->instance = instance;
		result->type = 0;
		result->startSegment = startSegment;
		result->texture = 0;
		result->continue_process = FX_ContinueParticle;
		result->fxprim_process = 0;
		result->fxprim_modify_process = 0;
		result->startScale = 4096;
		result->scaleSpeed = 0;
		result->offset.z = 0;
		result->offset.y = 0;
		result->offset.x = 0;
		result->acceleration.z = 0;
		result->acceleration.y = 0;
		result->acceleration.x = 0;
		result->flag_bits = 0;
		result->z_undulate = 0;
	}
	return result;
#else
	UNIMPLEMENTED();
	return NULL;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ FX_AniTexSetup(struct _FX_PRIM *fxPrim /*$a2*/, struct _MFace *mface /*$a1*/, struct _Model *model /*$a2*/, struct _FXTracker *fxTracker /*$a3*/)
void FX_AniTexSetup(struct _FX_PRIM *fxPrim, struct _MFace *mface, struct _Model *model, struct _FXTracker *fxTracker)
{ // line 271, offset 0x80042200
#if defined(PC_VERSION)
	int flags; // edx
	struct TextureMT3* color; // ecx

	flags = fxPrim->flags;
	if ((mface->flags & 2) != 0)
	{
		fxPrim->flags = flags | 1;
		color = (struct TextureMT3*)mface->color;
		fxPrim->texture = color;
		fxPrim->color = color->color & 0x3FFFFFF | 0x24000000;
	}
	else
	{
		fxPrim->flags = flags & 0xFFFFFFFA;
		fxPrim->color = mface->color & 0x3FFFFFF | 0x20000000;
	}
#else
	UNIMPLEMENTED();
#endif
}

void FX_StandardProcess(struct _FX_PRIM* fxPrim, struct _FXTracker* fxTracker)
{
#if defined(PSX_VERSION)
	FX_StandardFXPrimProcess(fxPrim, fxTracker);
#elif defined(PC_VERSION)
	__int16 timeToLive; // ax
	__int16 v4; // ax
	int v5; // ebx
	int endColor; // edx
	__int16 fadeStep; // cx
	int v8; // eax
	int y; // eax
	int v10; // ecx
	int segment; // edx
	MATRIX* matrix; // eax
	__int16 v13; // cx
	MATRIX* v14; // eax
	__int16 xAccl; // bp
	__int16 yAccl; // bx
	__int16 zAccl; // dx
	__int16 xVel; // ax
	__int16 yVel; // cx
	__int16 zVel; // dx
	__int16 work0; // ax
	int flags; // eax
	struct _FX_MATRIX* v23; // ecx
	int v24; // eax
	__int16 v25; // di
	__int16 v26; // bx
	int startColor; // [esp+10h] [ebp-8h] BYREF
	int v28; // [esp+14h] [ebp-4h] BYREF
	int node; // [esp+1Ch] [ebp+4h]
	struct _FXTracker* fxTrackera; // [esp+20h] [ebp+8h]

	timeToLive = fxPrim->timeToLive;
	if (timeToLive > 0)
	{
		v4 = timeToLive - FX_Frames;
		fxPrim->timeToLive = v4;
		if (v4 < 0)
			fxPrim->timeToLive = 0;
	}
	if (!fxPrim->timeToLive)
	{
		if (dword_C54BE8 == fxPrim)
		{
			dword_C54BE8 = (struct _FX_PRIM*)fxPrim->node.prev;
			if (!dword_C54BE8->node.prev)
			{
				dword_C54BE8 = 0;
				fxPrim->flags |= 0x10u;
				LIST_DeleteFunc(fxPrim);
				LIST_InsertFunc(&fxTracker->freePrimList, &fxPrim->node);
				return;
			}
		}
		goto LABEL_26;
	}
	node = fxPrim->flags;
	v5 = node;
	if ((node & 0x40000) != 0)
	{
		endColor = fxPrim->endColor;
		startColor = fxPrim->startColor;
		v28 = endColor;
		if (FX_Frames)
		{
			fadeStep = fxPrim->fadeStep;
			v8 = FX_Frames;
			do
			{
				fxPrim->fadeValue[0] += fadeStep;
				--v8;
			} while (v8);
		}
		if (fxPrim->fadeValue[0] > 4096)
			fxPrim->fadeValue[0] = 4096;
		if (fxPrim->fadeValue[0] < 0)
			fxPrim->fadeValue[0] = 0;
		gte_lddp(4096 - fxPrim->fadeValue[0]);
		gte_ldcv(&startColor);
		gte_GPF(1);
		gte_lddp(fxPrim->fadeValue[0]);
		gte_ldcv(&v28);
		gte_GPL(1);
		gte_stcv(&fxPrim->color);
		if ((node & 1) != 0)
			fxPrim->color = fxPrim->color & 0x3FFFFFF | 0x2C000000;
	}
	if ((node & 0x2000) != 0)
	{
		y = fxPrim->v0.y;
		if (FX_Frames)
		{
			v10 = FX_Frames;
			do
			{
				y -= fxPrim->work3;
				--v10;
			} while (v10);
		}
		if (y <= 0)
		{
			if (dword_C54BE8 == fxPrim)
			{
				dword_C54BE8 = (struct _FX_PRIM*)fxPrim->node.prev;
				if (!dword_C54BE8->node.prev)
					dword_C54BE8 = 0;
			}
		LABEL_26:
			fxPrim->flags |= 0x10u;
			LIST_DeleteFunc(fxPrim);
			LIST_InsertFunc(&fxTracker->freePrimList, &fxPrim->node);
			return;
		}
		fxPrim->v0.y = y;
	}
	if ((node & 0x20) != 0)
	{
		segment = fxPrim->duo.flame.segment;
		matrix = fxPrim->duo.flame.parent->matrix;
		v13 = matrix[segment].t[0];
		v14 = &matrix[segment];
		fxPrim->position.x = v13;
		fxPrim->position.y = v14->t[1];
		fxPrim->position.z = v14->t[2];
	}
	else if ((node & 2) == 0)
	{
		if (FX_Frames)
		{
			xAccl = fxPrim->duo.phys.xAccl;
			yAccl = fxPrim->duo.phys.yAccl;
			fxTrackera = (struct _FXTracker*)FX_Frames;
			do
			{
				zAccl = fxPrim->duo.phys.zAccl;
				fxPrim->duo.phys.xVel += xAccl;
				fxPrim->duo.phys.yVel += yAccl;
				fxPrim->duo.phys.zVel += zAccl;
				xVel = fxPrim->duo.phys.xVel;
				yVel = fxPrim->duo.phys.yVel;
				zVel = fxPrim->duo.phys.zVel;
				if ((node & 0x1000000) != 0)
				{
					fxPrim->v0.x += xVel;
					fxPrim->v1.x += xVel;
					fxPrim->v0.y += yVel;
					fxPrim->v1.y += yVel;
					fxPrim->v0.z += zVel;
					fxPrim->v1.z += zVel;
				}
				else
				{
					fxPrim->position.x += xVel;
					fxPrim->position.y += yVel;
					fxPrim->position.z += zVel;
				}
				fxTrackera = (struct _FXTracker*)((char*)fxTrackera - 1);
			} while (fxTrackera);
			v5 = node;
		}
		if ((v5 & 0x100) != 0)
		{
			work0 = fxPrim->work0;
			if (fxPrim->position.z <= work0)
			{
				fxPrim->position.z = work0;
				flags = fxPrim->flags;
				flags = flags | 2;
				fxPrim->flags = flags;
			}
		}
	}
	if ((v5 & 0x8000000) == 0)
	{
		v23 = fxPrim->matrix;
		if (v23)
		{
			v24 = v23->flags;
			if ((v24 & 2) == 0)
			{
				v24 = v24 | 2;
				v23->flags = v24;
				if ((v5 & 0x80u) != 0)
				{
					RotMatrixX(4 * (fxPrim->work2 >> 8),   &fxPrim->matrix->lwTransform);
					RotMatrixY(4 * (fxPrim->work3 & 0xff), &fxPrim->matrix->lwTransform);
					RotMatrixZ(4 * (fxPrim->work3 >> 8),   &fxPrim->matrix->lwTransform);
				}
			}
		}
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ FX_ShatterProcess(struct _FX_PRIM *fxPrim /*$s0*/, struct _FXTracker *fxTracker /*$s1*/)
void FX_ShatterProcess(struct _FX_PRIM *fxPrim, struct _FXTracker *fxTracker)
{ // line 396, offset 0x8004229c
#if defined(PC_VERSION)
	__int16 timeToLive; // ax
	int flags; // ebx
	int timeMult_low; // eax
	int v5; // edx
	int v6; // edi
	__int16 xVel; // cx
	int v8; // ebp
	int v9; // ecx
	int zVel; // edx
	__int16 work0; // ax
	__int16 work3; // dx
	struct _FX_MATRIX* matrix; // eax
	SVECTOR v14; // [esp+10h] [ebp-28h] BYREF
	MATRIX v15; // [esp+18h] [ebp-20h] BYREF

	timeToLive = fxPrim->timeToLive;
	v14.pad = 0;
	if (timeToLive > 0)
		fxPrim->timeToLive = timeToLive - 1;
	if (fxPrim->timeToLive)
	{
		flags = fxPrim->flags;
		if ((flags & 2) == 0)
		{
			timeMult_low = gameTrackerX.timeMult;
			v5 = gameTrackerX.timeMult * fxPrim->duo.phys.yAccl;
			v6 = gameTrackerX.timeMult * fxPrim->duo.phys.zAccl;
			fxPrim->duo.phys.xVel += (gameTrackerX.timeMult * fxPrim->duo.phys.xAccl) >> 12;
			xVel = fxPrim->duo.phys.xVel;
			fxPrim->duo.phys.yVel += v5 >> 12;
			v5 = fxPrim->duo.phys.yVel;
			v8 = xVel * timeMult_low;
			fxPrim->duo.phys.zVel += v6 >> 12;
			v9 = (__int16)v5 * timeMult_low;
			zVel = fxPrim->duo.phys.zVel;
			fxPrim->position.y += v9 >> 12;
			fxPrim->position.z += (zVel * timeMult_low) >> 12;
			v9 = fxPrim->position.z;
			work0 = fxPrim->work0;
			fxPrim->position.x += v8 >> 12;
			if ((__int16)v9 < work0)
			{
				fxPrim->position.z = work0;
				fxPrim->flags = flags | 2;
				fxPrim->timeToLive = 6;
			}
			work3 = fxPrim->work3;
			if (work3)
			{
				matrix = fxPrim->matrix;
				v14.vx = (work3 * matrix->lwTransform.m[0][0]) >> 12;
				v14.vy = (work3 * matrix->lwTransform.m[1][0]) >> 12;
				v14.vz = (work3 * matrix->lwTransform.m[2][0]) >> 12;
				RotMatrix(&v14, &v15);
				MulMatrix2(&v15, &fxPrim->matrix->lwTransform);
			}
		}
	}
	else
	{
		if (dword_C54BE8 == fxPrim)
		{
			dword_C54BE8 = (struct _FX_PRIM*)fxPrim->node.prev;
			if (!dword_C54BE8->node.prev)
				dword_C54BE8 = 0;
		}
		fxPrim->flags |= 0x10u;
		LIST_DeleteFunc(fxPrim);
		LIST_InsertFunc(&fxTracker->freePrimList, &fxPrim->node);
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ FX_DFacadeProcess(struct _FX_PRIM *fxPrim /*$s0*/, struct _FXTracker *fxTracker /*$a1*/)
void FX_DFacadeProcess(struct _FX_PRIM *fxPrim, struct _FXTracker *fxTracker)
{ // line 583, offset 0x80042544
	/* begin block 1 */
		// Start line: 584
		// Start offset: 0x80042544

		/* begin block 1.1 */
			// Start line: 596
			// Start offset: 0x8004259C
			// Variables:
				//MATRIX *swTransform; // $v1
		/* end block 1.1 */
		// End offset: 0x8004259C
		// End Line: 597

		/* begin block 1.2 */
			// Start line: 756
			// Start offset: 0x800426A8
			// Variables:
				struct _Rotation rot; // stack offset -16
		/* end block 1.2 */
		// End offset: 0x80042708
		// End Line: 764
	/* end block 1 */
	// End offset: 0x80042708
	// End Line: 773

	/* begin block 2 */
		// Start line: 1166
	/* end block 2 */
	// End Line: 1167
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _FX_PRIM * /*$ra*/ _FX_BuildSingleFaceWithModel(struct _Model *model /*$a0*/, struct _MFace *mface /*$s6*/, SVECTOR*center /*$s7*/, SVECTOR*vel /*$fp*/, SVECTOR*accl /*stack 16*/, struct _FXTracker *fxTracker /*stack 20*/, TDRFuncPtr__FX_BuildSingleFaceWithModel6fxSetup fxSetup /*stack 24*/, TDRFuncPtr__FX_BuildSingleFaceWithModel7fxProcess fxProcess /*stack 28*/, struct _FX_MATRIX *fxMatrix /*stack 32*/, int timeToLive /*stack 36*/)
struct _FX_PRIM * _FX_BuildSingleFaceWithModel(struct _Model *model, struct _MFace *mface, SVECTOR*center, SVECTOR*vel, SVECTOR*accl, struct _FXTracker *fxTracker, TDRFuncPtr__FX_BuildSingleFaceWithModel6fxSetup fxSetup, TDRFuncPtr__FX_BuildSingleFaceWithModel7fxProcess fxProcess, struct _FX_MATRIX *fxMatrix, int timeToLive)
{ // line 856, offset 0x80042718
	/* begin block 1 */
		// Start line: 857
		// Start offset: 0x80042718
		// Variables:
			struct _FX_PRIM *fxPrim; // $s1
			struct _MVertex *vertexList; // $s3
	/* end block 1 */
	// End offset: 0x800427E0
	// End Line: 885

	/* begin block 2 */
		// Start line: 1677
	/* end block 2 */
	// End Line: 1678
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// struct _FX_PRIM * /*$ra*/ FX_BuildSingleFaceWithModel(struct _Model *model /*$a0*/, struct _MFace *mface /*$a1*/, SVECTOR*center /*$a2*/, SVECTOR*vel /*$a3*/, SVECTOR*accl /*stack 16*/, struct _FXTracker *fxTracker /*stack 20*/, TDRFuncPtr_FX_BuildSingleFaceWithModel6fxSetup fxSetup /*stack 24*/, TDRFuncPtr_FX_BuildSingleFaceWithModel7fxProcess fxProcess /*stack 28*/, int timeToLive /*stack 32*/)
struct _FX_PRIM * FX_BuildSingleFaceWithModel(struct _Model *model, struct _MFace *mface, SVECTOR*center, SVECTOR*vel, SVECTOR*accl, struct _FXTracker *fxTracker, TDRFuncPtr_FX_BuildSingleFaceWithModel6fxSetup fxSetup, TDRFuncPtr_FX_BuildSingleFaceWithModel7fxProcess fxProcess, int timeToLive)
{ // line 890, offset 0x80042814
	/* begin block 1 */
		// Start line: 1745
	/* end block 1 */
	// End Line: 1746
	UNIMPLEMENTED();
	return null;
}

void FX_SetupLighting(struct _Instance* instance)//Matching - 99.25%
{
	MATRIX lm;

	LIGHT_PresetInstanceLight(instance, 2048, &lm);

	MulMatrix0(&lm, &instance->matrix[instance->lightMatrix], &lm);
	
	SetLightMatrix(&lm);
}


// autogenerated function stub: 
// long /*$ra*/ _FX_DoLighting(struct _MFace *mface /*$a0*/)
long _FX_DoLighting(struct _MFace *mface)
{ // line 928, offset 0x800428b4
	/* begin block 1 */
		// Start line: 929
		// Start offset: 0x800428B4
		// Variables:
			long modelDQP; // $a2
			long color; // stack offset -8
			struct TextureMT3 *texture; // $a1
	/* end block 1 */
	// End offset: 0x800429C0
	// End Line: 961

	/* begin block 2 */
		// Start line: 1797
	/* end block 2 */
	// End Line: 1798
			UNIMPLEMENTED();
	return 0;
}


// autogenerated function stub: 
// void /*$ra*/ _FX_BuildSegmentedSplinters(struct _Instance *instance /*stack 0*/, SVECTOR*center /*stack 4*/, SVECTOR*vel /*stack 8*/, SVECTOR*accl /*stack 12*/, struct FXSplinter *splintDef /*stack 16*/, struct _FXTracker *fxTracker /*stack 20*/, TDRFuncPtr__FX_BuildSegmentedSplinters6fxSetup fxSetup /*stack 24*/, TDRFuncPtr__FX_BuildSegmentedSplinters7fxProcess fxProcess /*stack 28*/, int shardFlags /*stack 32*/)
void _FX_BuildSegmentedSplinters(struct _Instance *instance, SVECTOR*center, SVECTOR*vel, SVECTOR*accl, struct FXSplinter *splintDef, struct _FXTracker *fxTracker, TDRFuncPtr__FX_BuildSegmentedSplinters6fxSetup fxSetup, TDRFuncPtr__FX_BuildSegmentedSplinters7fxProcess fxProcess, int shardFlags)
{ // line 976, offset 0x800429cc
	/* begin block 1 */
		// Start line: 977
		// Start offset: 0x800429CC
		// Variables:
			long j; // $s4
			long maxTimeToLive; // stack offset -80
			long faceSkip; // stack offset -76
			long numFaces; // $v0
			struct _MFace *mface; // $s5
			struct _MFace *endMFace; // stack offset -72
			struct _Model *model; // stack offset -68
			struct _MVertex *vertexList; // stack offset -64
			struct _MFace *faceList; // $s0
			struct _FX_MATRIX *fxMatrix; // $s3
			struct _FX_MATRIX (*fxMatList[60]); // stack offset -960
			struct _SVector veloc[60]; // stack offset -720
			struct _SVector *curVel; // $s7
			int lastFxMat; // $fp
			unsigned char matIdx[128]; // stack offset -240
			struct _FX_PRIM *fxPrim; // $s2
			struct _SVector *vertex0; // $s0
			struct _SVector *vertex1; // $s1
			struct _SVector *vertex2; // $s4
			struct _SVector *poolOfVertices; // stack offset -60
			long *vtxSegment; // stack offset -56
			struct _Vector Center; // stack offset -112
			int seg0; // $s6
			int seg1; // $a0
			struct _SVector offset; // stack offset -96

		/* begin block 1.1 */
			// Start line: 1059
			// Start offset: 0x80042BBC
			// Variables:
				short _y0; // $v0
				short _z0; // $v1
				short _x1; // $a1
				short _y1; // $a3
				short _z1; // $a2
				struct _SVector *_v; // stack offset -48
				struct _Vector *_v1; // $a2
		/* end block 1.1 */
		// End offset: 0x80042BBC
		// End Line: 1059

		/* begin block 1.2 */
			// Start line: 1072
			// Start offset: 0x80042C50
		/* end block 1.2 */
		// End offset: 0x80042D10
		// End Line: 1083

		/* begin block 1.3 */
			// Start line: 1136
			// Start offset: 0x80043008
			// Variables:
				//short _x0; // $a1
				//short _y0; // $v1
				//short _z0; // $v0
				//short _x1; // $a0
				//short _y1; // $a3
				//short _z1; // $a2
				//_Position *_v0; // $v0
				//struct _Vector *_v1; // $a2
		/* end block 1.3 */
		// End offset: 0x80043008
		// End Line: 1136

		/* begin block 1.4 */
			// Start line: 1165
			// Start offset: 0x80043144
			// Variables:
				struct TextureMT3 *texture; // $v1
		/* end block 1.4 */
		// End offset: 0x80043144
		// End Line: 1165

		/* begin block 1.5 */
			// Start line: 1195
			// Start offset: 0x80043210
		/* end block 1.5 */
		// End offset: 0x80043270
		// End Line: 1200

		/* begin block 1.6 */
			// Start line: 1217
			// Start offset: 0x800432E4
		/* end block 1.6 */
		// End offset: 0x8004332C
		// End Line: 1223
	/* end block 1 */
	// End offset: 0x80043420
	// End Line: 1243

	/* begin block 2 */
		// Start line: 1895
	/* end block 2 */
	// End Line: 1896

	/* begin block 3 */
		// Start line: 1925
	/* end block 3 */
	// End Line: 1926
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ _FX_BuildNonSegmentedSplinters(struct _Instance *instance /*stack 0*/, SVECTOR*center /*stack 4*/, SVECTOR*vel /*stack 8*/, SVECTOR*accl /*stack 12*/, struct FXSplinter *splintDef /*stack 16*/, struct _FXTracker *fxTracker /*stack 20*/, TDRFuncPtr__FX_BuildNonSegmentedSplinters6fxSetup fxSetup /*stack 24*/, TDRFuncPtr__FX_BuildNonSegmentedSplinters7fxProcess fxProcess /*stack 28*/, int shardFlags /*stack 32*/)
void _FX_BuildNonSegmentedSplinters(struct _Instance *instance, SVECTOR*center, SVECTOR*vel, SVECTOR*accl, struct FXSplinter *splintDef, struct _FXTracker *fxTracker, TDRFuncPtr__FX_BuildNonSegmentedSplinters6fxSetup fxSetup, TDRFuncPtr__FX_BuildNonSegmentedSplinters7fxProcess fxProcess, int shardFlags)
{ // line 1254, offset 0x80043450
	/* begin block 1 */
		// Start line: 1255
		// Start offset: 0x80043450
		// Variables:
			long j; // $s2
			long maxTimeToLive; // stack offset -72
			long faceSkip; // stack offset -68
			long numFaces; // $v0
			struct _MFace *mface; // $s5
			struct _MFace *endMFace; // stack offset -64
			short whichMatrix; // $v0
			struct _Model *model; // stack offset -60
			struct _MVertex *vertexList; // stack offset -56
			struct _MFace *faceList; // $s4
			struct _FX_MATRIX *fxMatrix; // $s0
			struct _FX_MATRIX (*fxMatList[4]); // stack offset -200
			struct _SVector *curVel; // $s6
			struct _FX_PRIM *fxPrim; // $s2
			struct _SVector *vertex0; // $s1
			struct _SVector *vertex1; // $s3
			struct _SVector *vertex2; // $s4
			struct _SVector *poolOfVertices; // $fp
			//MATRIX *swTransform; // $s1
			//MATRIX ourM; // stack offset -184
			struct _Vector Center; // stack offset -152
			struct _SVector offset; // stack offset -136
			struct _Normal faceNorm; // stack offset -128
			struct _SVector sv_temp; // stack offset -120
			struct _SVector sv_vels[4]; // stack offset -112

		/* begin block 1.1 */
			// Start line: 1296
			// Start offset: 0x80043564
			// Variables:
				short start; // $v0
		/* end block 1.1 */
		// End offset: 0x8004368C
		// End Line: 1322

		/* begin block 1.2 */
			// Start line: 1352
			// Start offset: 0x800437F8
			// Variables:
				short _x1; // $v0
				short _y1; // $v1
				short _z1; // $a0
				struct _SVector *_v0; // $s3
				struct _SVector *_v1; // $a1
		/* end block 1.2 */
		// End offset: 0x800437F8
		// End Line: 1352

		/* begin block 1.3 */
			// Start line: 1414
			// Start offset: 0x80043BAC
			// Variables:
				//short _x0; // $a1
				//short _y0; // $v1
				//short _z0; // $v0
				//short _x1; // $a0
				//short _y1; // $a3
				//short _z1; // $a2
				//struct _SVector *_v; // stack offset -48
				//_Position *_v0; // $v0
				//struct _Vector *_v1; // $a2
		/* end block 1.3 */
		// End offset: 0x80043BAC
		// End Line: 1414

		/* begin block 1.4 */
			// Start line: 1443
			// Start offset: 0x80043CE8
			// Variables:
				struct TextureMT3 *texture; // $v1
		/* end block 1.4 */
		// End offset: 0x80043CE8
		// End Line: 1443

		/* begin block 1.5 */
			// Start line: 1473
			// Start offset: 0x80043DA4
		/* end block 1.5 */
		// End offset: 0x80043DA4
		// End Line: 1473

		/* begin block 1.6 */
			// Start line: 1499
			// Start offset: 0x80043EF0
		/* end block 1.6 */
		// End offset: 0x80043F38
		// End Line: 1505
	/* end block 1 */
	// End offset: 0x8004400C
	// End Line: 1530

	/* begin block 2 */
		// Start line: 2797
	/* end block 2 */
	// End Line: 2798
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ _FX_BuildSplinters(struct _Instance *instance /*$s2*/, SVECTOR*center /*$s4*/, SVECTOR*vel /*$s5*/, SVECTOR*accl /*$s6*/, struct FXSplinter *splintDef /*stack 16*/, struct _FXTracker *fxTracker /*stack 20*/, TDRFuncPtr__FX_BuildSplinters6fxSetup fxSetup /*stack 24*/, TDRFuncPtr__FX_BuildSplinters7fxProcess fxProcess /*stack 28*/, int shardFlags /*stack 32*/)
void _FX_BuildSplinters(struct _Instance *instance, SVECTOR*center, SVECTOR*vel, SVECTOR*accl, struct FXSplinter *splintDef, struct _FXTracker *fxTracker, TDRFuncPtr__FX_BuildSplinters6fxSetup fxSetup, TDRFuncPtr__FX_BuildSplinters7fxProcess fxProcess, int shardFlags)
{ // line 1541, offset 0x8004403c
#if defined(PC_VERSION)
	int v9; // ecx
	__int16 soundFx; // ax
	int v11; // ebx

	if (MEMPACK_MemoryValidFunc((char*)instance->object))
	{
		if (splintDef)
		{
			v9 = splintDef->flags;
			soundFx = splintDef->soundFx;
			v11 = v9 | shardFlags;
			if (soundFx)
				SndPlay(soundFx);
		}
		else
		{
			v11 = shardFlags;
		}
		if (instance->object->modelList[instance->currentModel]->numSegments < 4 || (v11 & 0x20) != 0)
			FX_BuildNonSegmentedSplinters(instance, center, vel, accl, splintDef, fxTracker, fxSetup, fxProcess, v11);
		else
			FX_BuildSegmentedSplinters(instance, center, vel, accl, splintDef, fxTracker, fxSetup, fxProcess, v11);
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ _FX_Build(struct _Instance *instance /*$s0*/, SVECTOR*center /*$s2*/, SVECTOR*vel /*$s3*/, SVECTOR*accl /*$s4*/, struct _FXTracker *fxTracker /*stack 16*/, TDRFuncPtr__FX_Build5fxSetup fxSetup /*stack 20*/, TDRFuncPtr__FX_Build6fxProcess fxProcess /*stack 24*/, int shardFlags /*stack 28*/)
void _FX_Build(struct _Instance *instance, SVECTOR*center, SVECTOR*vel, SVECTOR*accl, struct _FXTracker *fxTracker, TDRFuncPtr__FX_Build5fxSetup fxSetup, TDRFuncPtr__FX_Build6fxProcess fxProcess, int shardFlags)
{
#if defined(PSX_VERSION)
	if (MEMPACK_MemoryValidFunc((char*)instance->object) != 0)
	{
		if (instance->object->modelList[instance->currentModel]->numSegments < 4)
		{
			_FX_BuildNonSegmentedSplinters(instance, center, vel, accl, NULL, fxTracker, fxSetup, fxProcess, shardFlags);
		}
		else
		{
			_FX_BuildSegmentedSplinters(instance, center, vel, accl, NULL, fxTracker, fxSetup, fxProcess, shardFlags);
		}
	}
#elif defined(PC_VERSION)
	int shardFlags; // [esp+24h] [ebp+20h]

	if (MEMPACK_MemoryValidFunc((char*)instance->object))
	{
		if (instance->object->modelList[instance->currentModel]->numSegments >= 4)
			FX_BuildSegmentedSplinters(instance, center, vel, accl, 0, fxTracker, fxSetup, fxProcess, shardFlags);
		else
			FX_BuildNonSegmentedSplinters(instance, center, vel, accl, 0, fxTracker, fxSetup, fxProcess, shardFlags);
	}
#endif
}

void FX_Build(struct _Instance* instance, SVECTOR* center, SVECTOR* vel, SVECTOR* accl, struct _FXTracker* fxTracker, TDRFuncPtr_FX_Build5fxSetup fxSetup, TDRFuncPtr_FX_Build6fxProcess fxProcess)
{
#if defined(PSX_VERSION)
	_FX_Build(instance, center, vel, accl, fxTracker, fxSetup, fxProcess, 0);
#elif defined(PC_VERSION)
	if (MEMPACK_MemoryValidFunc((char*)instance->object))
	{
		if (instance->object->modelList[instance->currentModel]->numSegments >= 4)
			_FX_BuildSegmentedSplinters(instance, center, vel, accl, 0, fxTracker, fxSetup, fxProcess, 0);
		else
			_FX_BuildNonSegmentedSplinters(instance, center, vel, accl, 0, fxTracker, fxSetup, fxProcess, 0);
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ FX_UpdatePos(struct _FX_PRIM *fxPrim /*$t2*/, struct _SVector *offset /*$t3*/, int spriteflag /*$a2*/)
void FX_UpdatePos(struct _FX_PRIM *fxPrim, struct _SVector *offset, int spriteflag)
{ // line 1747, offset 0x800442dc
#if defined(PC_VERSION)
	int flags; // edx

	fxPrim->position.x += offset->x;
	fxPrim->position.y += offset->y;
	fxPrim->position.z += offset->z;
	if (!spriteflag)
	{
		flags = fxPrim->flags;
		if ((flags & 0x10000) != 0)
		{
			fxPrim->v0.x += offset->x;
			fxPrim->v0.y += offset->y;
			fxPrim->v0.z += offset->z;
			fxPrim->v1.x += offset->x;
			fxPrim->v1.y += offset->y;
			fxPrim->v1.z += offset->z;
			fxPrim->v2.x += offset->x;
			fxPrim->v2.y += offset->y;
			fxPrim->v2.z += offset->z;
			if ((flags & 8) != 0)
			{
				fxPrim->v3.x += offset->x;
				fxPrim->v3.y += offset->y;
				fxPrim->v3.z += offset->z;
			}
		}
	}
#else
	UNIMPLEMENTED();
#endif
}

void FX_Relocate(struct _SVector* offset)//Matching - 99.72%
{
#if defined(PSX_VERSION)
	struct _FX_PRIM* fxPrim;
	struct _FXTracker* fxTracker;
	struct _FXGeneralEffect* currentEffect;
	int i;
	int end;
	struct _FXRibbon* currentRibbon;

	fxTracker = gFXT;

	fxPrim = (struct _FX_PRIM*)fxTracker->usedPrimList.next;

	while (fxPrim != NULL)
	{
		FX_UpdatePos(fxPrim, offset, 0);

		fxPrim = (struct _FX_PRIM*)fxPrim->node.next;
	}

	fxPrim = (struct _FX_PRIM*)fxTracker->usedPrimListSprite.next;

	while (fxPrim != NULL)
	{
		FX_UpdatePos(fxPrim, offset, 1);

		if (fxPrim->process == &FX_WaterBubbleProcess)
		{
			fxPrim->timeToLive += offset->z;
		}

		fxPrim = (struct _FX_PRIM*)fxPrim->node.next;
	}

	currentEffect = FX_GeneralEffectTracker;

	while (currentEffect != NULL)
	{
		if (currentEffect->effectType == 0)
		{
			end = ((short*)currentEffect)[8];

			currentRibbon = (struct _FXRibbon*)currentEffect;

			for (i = 0; i < end; i++)
			{
				currentRibbon->vertexPool[i].vx += offset->x;
				currentRibbon->vertexPool[i].vy += offset->y;
				currentRibbon->vertexPool[i].vz += offset->z;
			}
		}
		else if (currentEffect->effectType == 0x84)
		{
			((struct _GenericLightningParams*)currentEffect)->end_offset.x += offset->x;
			((struct _GenericLightningParams*)currentEffect)->end_offset.y += offset->y;
			((struct _GenericLightningParams*)currentEffect)->end_offset.z += offset->z;
		}

		currentEffect = (struct _FXGeneralEffect*)currentEffect->next;
	}

#elif defined(PC_VERSION)
	struct _FXTracker* v1; // ebx
	struct _FX_PRIM* fxPrim; // edi
	struct _FX_PRIM* currentEffect; // edi
	struct _FXTracker* fxTracker; // eax
	unsigned __int8 effectType; // cl
	int numberVerts; // edi
	int i; // ecx

	v1 = gFXT;
	for (fxPrim = (struct _FX_PRIM*)gFXT->usedPrimList.next; fxPrim; fxPrim = (struct _FX_PRIM*)fxPrim->node.next)
		FX_UpdatePos(fxPrim, offset, 0);
	for (currentEffect = (struct _FX_PRIM*)v1->usedPrimListSprite.next;
		currentEffect;
		currentEffect = (struct _FX_PRIM*)currentEffect->node.next)
	{
		FX_UpdatePos(currentEffect, offset, 1);
		if (currentEffect->process == FX_WaterBubbleProcess)
			currentEffect->timeToLive += offset->z;
	}
	fxTracker = (struct _FXTracker*)ring;
	if (ring)
	{
		do
		{
			effectType = fxTracker->matrixPool[0].lwTransform.m[0][0];
			if (effectType)
			{
				if (effectType == 0x84)
				{
					fxTracker->matrixPool[0].lwTransform.m[0][2] += offset->x;
					fxTracker->matrixPool[0].lwTransform.m[1][0] += offset->y;
					fxTracker->matrixPool[0].lwTransform.m[1][1] += offset->z;
				}
			}
			else
			{
				numberVerts = fxTracker->matrixPool[0].lwTransform.m[0][2];
				for (i = 0; i < numberVerts; ++i)
				{
					*(_WORD*)(*(_DWORD*)&fxTracker->matrixPool[0].lwTransform.m[1][1] + 8 * i) += offset->x;
					*(_WORD*)(*(_DWORD*)&fxTracker->matrixPool[0].lwTransform.m[1][1] + 8 * i + 2) += offset->y;
					*(_WORD*)(*(_DWORD*)&fxTracker->matrixPool[0].lwTransform.m[1][1] + 8 * i + 4) += offset->z;
				}
			}
			fxTracker = (struct _FXTracker*)fxTracker->matrixPool[0].node.prev;
		} while (fxTracker);
	}
	return fxTracker;
#else
	UNIMPLEMENTED();
	return;
#endif
}

void FX_UpdateTexturePointers(struct _FX_PRIM* fxPrim, struct Object* oldObject, int sizeOfObject, int offset)//Matching - 100%
{
#if defined(PSX_VERSION)
	while (fxPrim)
	{
		if ((fxPrim->flags & 0x1))
		{
			if (fxPrim->texture >= (struct TextureMT3*)oldObject && (char*)oldObject + sizeOfObject >= (char*)fxPrim->texture)

			{
				fxPrim->texture = fxPrim->texture != NULL ? (struct TextureMT3*)((char*)fxPrim->texture + offset) : NULL;

			}
		}

		fxPrim = (struct _FX_PRIM*)fxPrim->node.next;
	}
#elif defined(PC_VERSION)
	struct _FX_PRIM* i; // ecx
	unsigned int texture; // eax

	for (i = fxPrim; i; i = (struct _FX_PRIM*)i->node.next)
	{
		if ((i->flags & 1) != 0)
		{
			texture = (unsigned int)i->texture;
			if (texture >= (unsigned int)oldObject && texture <= (unsigned int)oldObject + sizeOfObject)
			{
				if (texture)
					texture += offset;
				i->texture = (struct TextureMT3*)texture;
			}
		}
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ FX_RelocateFXPointers(struct Object *oldObject /*$s3*/, struct Object *newObject /*$a1*/, long sizeOfObject /*$s2*/)
void FX_RelocateFXPointers(struct Object *oldObject, struct Object *newObject, long sizeOfObject)
{ // line 1842, offset 0x80044640
#if defined(PC_VERSION)
	struct _FXTracker* v3; // esi
	struct _FXGeneralEffect* next; // ecx
	int i; // edi
	struct _FXGeneralEffect* prev; // eax
	struct _FXGeneralEffect* j; // ecx
	struct _Instance* v8; // eax
	struct _FXGlowEffect* k; // ecx
	unsigned int diffTime; // eax
	extern struct _FXGlowEffect* ring;

	v3 = gFXT;
	next = (struct _FXGeneralEffect*)gFXT->usedPrimList.next;
	for (i = (char*)newObject - (char*)oldObject; next; next = (struct _FXGeneralEffect*)next->continue_process)
	{
		if ((next->effectType & 1) != 0)
		{
			prev = (struct _FXGeneralEffect*)next->instance;
			if (prev >= (struct _FXGeneralEffect*)oldObject
				&& prev <= (struct _FXGeneralEffect*)((char*)oldObject + sizeOfObject))
			{
				if (prev)
					prev = (struct _FXGeneralEffect*)((char*)prev + i);
				next->instance = (struct _Instance*)prev;
			}
		}
	}
	for (j = (struct _FXGeneralEffect*)v3->usedPrimListSprite.next; j; j = (struct _FXGeneralEffect*)j->continue_process)
	{
		if ((j->effectType & 1) != 0)
		{
			v8 = j->instance;
			if (v8 >= (struct _Instance*)oldObject && v8 <= (struct _Instance*)((char*)oldObject + sizeOfObject))
			{
				if (v8)
					v8 = (struct _Instance*)((char*)v8 + i);
				j->instance = v8;
			}
		}
	}
	for (k = ring; k; k = (struct _FXGlowEffect*)k->next)
	{
		if (k->effectType == 1)
		{
			diffTime = k->diffTime;
			if (diffTime)
			{
				if (diffTime >= (unsigned int)oldObject && diffTime <= (unsigned int)oldObject + sizeOfObject)
					k->diffTime = i + diffTime;
			}
		}
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ FX_ProcessList(struct _FXTracker *fxTracker /*$s2*/)
void FX_ProcessList(struct _FXTracker *fxTracker)
{ // line 1872, offset 0x80044710
	/* begin block 1 */
		// Start line: 1873
		// Start offset: 0x80044710
		// Variables:
			struct _FX_PRIM *fxPrim; // $a0
			struct _FX_PRIM *nextFXPrim; // $s0
			struct _FX_MATRIX *fxMatrix; // $s0
			struct _FX_MATRIX *nextFXMatrix; // $s1

		/* begin block 1.1 */
			// Start line: 1943
			// Start offset: 0x80044884
			// Variables:
				struct _FXGeneralEffect *currentEffect; // $a0
				struct _FXGeneralEffect *nextEffect; // $s0
		/* end block 1.1 */
		// End offset: 0x800448A8
		// End Line: 1953
	/* end block 1 */
	// End offset: 0x800448EC
	// End Line: 1960

	/* begin block 2 */
		// Start line: 4463
	/* end block 2 */
	// End Line: 4464

	/* begin block 3 */
		// Start line: 4476
	/* end block 3 */
	// End Line: 4477
				UNIMPLEMENTED();
}

extern struct _Instance* inst_Reaver;

void FX_DrawReaver(struct _PrimPool *primPool, unsigned long **ot, MATRIX *wcTransform)
{
#if defined(PSX_VERSION)

	if (FX_reaver_instance != NULL)
	{
		FX_SoulReaverWinding(FX_reaver_instance, primPool, ot, wcTransform);

		FX_SoulReaverBlade(FX_reaver_instance, ot);
	}

	FX_reaver_instance = NULL;

#elif defined(PC_VERSION)
	struct _Instance* v3; // eax
	struct __ReaverData* rv; // esi
	__int16 v6; // di
	int v7; // ebx
	__int64 v8; // rax
	MATRIX* v10; // [esp+4h] [ebp-34h]
	struct _SVector end; // [esp+8h] [ebp-30h] BYREF
	struct _SVector start; // [esp+10h] [ebp-28h] BYREF
	MATRIX mat; // [esp+18h] [ebp-20h] BYREF
	MATRIX* wcTransforma; // [esp+44h] [ebp+Ch]

	if (inst_Reaver)
	{
		rv = (struct __ReaverData*)inst_Reaver->extraData;
		if (rv->ReaverPickedUp && rv->ReaverOn)
		{
			v6 = -rv->ReaverDeg;
			CompMatrix(wcTransform, &gameTrackerX.playerInstance->matrix[40], &mat);
			start.z = 0;
			start.y = 0;
			start.x = 0;
			end.y = 0;
			end.x = 0;
			end.z = -128;
			v7 = rv->ReaverBladeColor;
			long glow = rv->ReaverBladeGlowColor;
			FX_Lightning(wcTransform, ot, &mat, v6, &start, &end, 30, 10, 16, 32, 0, v7, glow);
			CompMatrix(wcTransform, &gameTrackerX.playerInstance->matrix[39], &mat);
			end.z = -96;
			FX_Lightning(wcTransform, ot, &mat, v6, &start, &end, 30, 10, 16, 32, 0, v7, glow);
			v10 = &inst_Reaver->matrix[1];
			v8 = rv->ReaverScale * rv->ReaverSize;
			end.z = -380 * (((WORD2(v8) & 0xFFF) + (int)v8) >> 12) / 4096;
			if (rv->CurrentReaver == 1)
				v7 = 0xFCFFD3;
			CompMatrix(wcTransform, v10, &mat);
			FX_Lightning(wcTransform, ot, &mat, v6, &start, &end, 0, 25, 4, 8, 0, v7, glow);
		}
		FX_SoulReaverBlade(v3, ot);
	}
	inst_Reaver = 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ FX_DrawList(struct _FXTracker *fxTracker /*stack 0*/, struct GameTracker *gameTracker /*$a1*/, unsigned long **ot /*$s5*/, MATRIX *wcTransform /*$s7*/)
void FX_DrawList(struct _FXTracker *fxTracker, struct GameTracker *gameTracker, unsigned long **ot, MATRIX *wcTransform)
{ // line 1985, offset 0x80044958
	/* begin block 1 */
		// Start line: 1986
		// Start offset: 0x80044958
		// Variables:
			struct TextureMT3 *texture; // $a1
			struct _PrimPool *primPool; // $fp
			long *prim; // $s1
			struct _FX_PRIM *fxPrim; // $s0
			struct _FX_PRIM *nextFXPrim; // $s6
			//SVECTORsv0; // stack offset -104
			//SVECTORsv1; // stack offset -96
			//SVECTORsv2; // stack offset -88
			long otz; // stack offset -52
			long sz0; // stack offset -64
			long sz1; // stack offset -60
			long sz2; // stack offset -56
			char whitec[4]; // stack offset -80
			int sizex; // stack offset -48
			int sizey; // $t4
			int matrix_wc; // $t2

		/* begin block 1.1 */
			// Start line: 2007
			// Start offset: 0x800449DC
			// Variables:
				long flags; // $s3

			/* begin block 1.1.1 */
				// Start line: 2095
				// Start offset: 0x80044CC8
				// Variables:
					struct _POLY_NG4 *ng4; // $a2

				/* begin block 1.1.1.1 */
					// Start line: 2097
					// Start offset: 0x80044CC8
					// Variables:
						int n; // $a0
						long *ptr; // $a1
				/* end block 1.1.1.1 */
				// End offset: 0x80044D88
				// End Line: 2122
			/* end block 1.1.1 */
			// End offset: 0x80044D88
			// End Line: 2144

			/* begin block 1.1.2 */
				// Start line: 2161
				// Start offset: 0x80044DC0
			/* end block 1.1.2 */
			// End offset: 0x80044DC0
			// End Line: 2163

			/* begin block 1.1.3 */
				// Start line: 2251
				// Start offset: 0x80044F40
				// Variables:
					//struct POLY_FT4 *ft4; // $a2
					unsigned short uMin; // $t1
					unsigned short uMax; // $t0
					unsigned short vMin; // $a3
					unsigned short vMax; // $v1
			/* end block 1.1.3 */
			// End offset: 0x8004518C
			// End Line: 2282

			/* begin block 1.1.4 */
				// Start line: 2289
				// Start offset: 0x800451C8
				// Variables:
					//struct POLY_FT3 *ft3; // $t0

				/* begin block 1.1.4.1 */
					// Start line: 2302
					// Start offset: 0x80045214
					// Variables:
						//short uMin; // $a3
						//short uMax; // $a2
				/* end block 1.1.4.1 */
				// End offset: 0x80045318
				// End Line: 2310
			/* end block 1.1.4 */
			// End offset: 0x80045354
			// End Line: 2316
		/* end block 1.1 */
		// End offset: 0x80045354
		// End Line: 2320

		/* begin block 1.2 */
			// Start line: 2331
			// Start offset: 0x80045394
			// Variables:
				//struct DVECTOR xy_pos; // stack offset -72
				//long flags; // $t2

			/* begin block 1.2.1 */
				// Start line: 2400
				// Start offset: 0x800455D0
				// Variables:
					struct _POLY_SG4 *sg4; // $a1

				/* begin block 1.2.1.1 */
					// Start line: 2402
					// Start offset: 0x800455D0
					// Variables:
						//int n; // $a3
						long *src; // $t2
						long *dst; // $t1
						//long *ptr; // $t3
				/* end block 1.2.1.1 */
				// End offset: 0x800456C8
				// End Line: 2433
			/* end block 1.2.1 */
			// End offset: 0x800456C8
			// End Line: 2455

			/* begin block 1.2.2 */
				// Start line: 2467
				// Start offset: 0x8004575C
			/* end block 1.2.2 */
			// End offset: 0x8004575C
			// End Line: 2471

			/* begin block 1.2.3 */
				// Start line: 2499
				// Start offset: 0x80045834
				// Variables:
					//unsigned short uMin; // $t3
					//unsigned short uMax; // $t1
					//unsigned short vMin; // $a3
					//unsigned short vMax; // $v1
					//struct POLY_FT4 *ft4; // $a2
			/* end block 1.2.3 */
			// End offset: 0x80045AA0
			// End Line: 2537
		/* end block 1.2 */
		// End offset: 0x80045B0C
		// End Line: 2556
	/* end block 1 */
	// End offset: 0x80045B18
	// End Line: 2560

	/* begin block 2 */
		// Start line: 4713
	/* end block 2 */
	// End Line: 4714
						UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_SimpleQuadSetup(struct _FX_PRIM *fxPrim /*$s5*/, TDRFuncPtr_FX_SimpleQuadSetup1fxProcess fxProcess /*stack 4*/, struct _FX_MATRIX *fxMatrix /*stack 8*/, struct _Instance *instance /*$a3*/, struct _MFace *mface /*stack 16*/, struct _MVertex *vertexList /*stack 20*/, SVECTOR*center /*stack 24*/, SVECTOR*vel /*stack 28*/, SVECTOR*accl /*stack 32*/, struct _FXTracker *fxTracker /*stack 36*/, int timeToLive /*stack 40*/)
void FX_SimpleQuadSetup(struct _FX_PRIM *fxPrim, TDRFuncPtr_FX_SimpleQuadSetup1fxProcess fxProcess, struct _FX_MATRIX *fxMatrix, struct _Instance *instance, struct _MFace *mface, struct _MVertex *vertexList, SVECTOR*center, SVECTOR*vel, SVECTOR*accl, struct _FXTracker *fxTracker, int timeToLive)
{ // line 2727, offset 0x80045b60
	/* begin block 1 */
		// Start line: 2728
		// Start offset: 0x80045B60
		// Variables:
			struct _MVertex *vertex1; // $s2
			struct _MVertex *vertex2; // $s3
			struct _MVertex *vertex3; // $s4

		/* begin block 1.1 */
			// Start line: 2728
			// Start offset: 0x80045B60
			// Variables:
				short _x1; // $v0
				short _y1; // $v1
				short _z1; // $a0
				_Position *_v0; // $v0
		/* end block 1.1 */
		// End offset: 0x80045B60
		// End Line: 2728

		/* begin block 1.2 */
			// Start line: 2728
			// Start offset: 0x80045B60
			// Variables:
				//short _x1; // $v0
				//short _y1; // $v1
				//short _z1; // $a0
				//struct _SVector *_v0; // $v0
		/* end block 1.2 */
		// End offset: 0x80045B60
		// End Line: 2728

		/* begin block 1.3 */
			// Start line: 2728
			// Start offset: 0x80045B60
			// Variables:
				//short _x1; // $v0
				//short _y1; // $v1
				//short _z1; // $a0
				//struct _SVector *_v0; // $v0
		/* end block 1.3 */
		// End offset: 0x80045B60
		// End Line: 2728

		/* begin block 1.4 */
			// Start line: 2728
			// Start offset: 0x80045B60
			// Variables:
				//short _x1; // $v0
				//short _y1; // $v1
				//short _z1; // $a0
				//struct _SVector *_v0; // $v0
		/* end block 1.4 */
		// End offset: 0x80045B60
		// End Line: 2728

		/* begin block 1.5 */
			// Start line: 2728
			// Start offset: 0x80045B60
			// Variables:
				//short _x1; // $v0
				//short _y1; // $v1
				//short _z1; // $a0
				//struct _SVector *_v0; // $v0
		/* end block 1.5 */
		// End offset: 0x80045B60
		// End Line: 2728
	/* end block 1 */
	// End offset: 0x80045D58
	// End Line: 2792

	/* begin block 2 */
		// Start line: 5454
	/* end block 2 */
	// End Line: 5455
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_WaterRingProcess(struct _FX_PRIM *fxPrim /*$a0*/, struct _FXTracker *fxTracker /*$a1*/)
void FX_WaterRingProcess(struct _FX_PRIM *fxPrim, struct _FXTracker *fxTracker)
{ // line 2796, offset 0x80045d9c
	/* begin block 1 */
		// Start line: 6929
	/* end block 1 */
	// End Line: 6930
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_WaterBubbleProcess(struct _FX_PRIM *fxPrim /*$s0*/, struct _FXTracker *fxTracker /*$s2*/)
void FX_WaterBubbleProcess(struct _FX_PRIM *fxPrim, struct _FXTracker *fxTracker)
{ // line 2806, offset 0x80045e18
	/* begin block 1 */
		// Start line: 2807
		// Start offset: 0x80045E18
		// Variables:
			struct _FX_PRIM *temp; // $a1

		/* begin block 1.1 */
			// Start line: 2833
			// Start offset: 0x80045EFC
			// Variables:
				//struct Object *waterfx; // $v1
				//struct _Model *wxring; // $s1
		/* end block 1.1 */
		// End offset: 0x80046018
		// End Line: 2863
	/* end block 1 */
	// End offset: 0x80046018
	// End Line: 2864

	/* begin block 2 */
		// Start line: 6952
	/* end block 2 */
	// End Line: 6953
				UNIMPLEMENTED();
}

void FX_Sprite_Insert(struct NodeType* list, struct _FX_PRIM* fxPrim)
{
	LIST_InsertFunc(list, &fxPrim->node);
	
	if (FX_LastUsedPrim == NULL)
	{
		FX_LastUsedPrim = fxPrim;
	}
}

struct TextureMT3* FX_GetTextureObject(struct Object *object, int modelnum, int texnum)
{
	struct _Model* model;
	struct TextureMT3* texture;
	
	object->oflags2 |= 0x20000000;

	model = object->modelList[modelnum];
	texture = (struct TextureMT3*)&((char*)((((struct _FX_PRIM*)model->faceList)->process)))[texnum * 16 + 16];

	return texture;
}


// autogenerated function stub: 
// void /*$ra*/ FX_MakeWaterBubble(struct _SVector *position /*$s0*/, struct _SVector *vel /*$s4*/, struct _SVector *accl /*$s5*/, long splashZ /*$s6*/, struct __BubbleParams *BP /*stack 16*/)
void FX_MakeWaterBubble(struct _SVector *position, struct _SVector *vel, struct _SVector *accl, long splashZ, struct __BubbleParams *BP)
{ // line 2887, offset 0x800460a4
	/* begin block 1 */
		// Start line: 2888
		// Start offset: 0x800460A4
		// Variables:
			struct Object *waterfx; // $s3
			struct _FX_PRIM *fxPrim; // $s1
	/* end block 1 */
	// End offset: 0x8004622C
	// End Line: 2919

	/* begin block 2 */
		// Start line: 7189
	/* end block 2 */
	// End Line: 7190
			UNIMPLEMENTED();
}

void FX_DrawScreenPoly(int transtype, unsigned long color, int zdepth)
{
	unsigned long** drawot;
	_POLY_TF4* poly;

	drawot = gameTrackerX.drawOT;

	poly = (_POLY_TF4*)gameTrackerX.primPool->nextPrim;

	if ((unsigned long*)(poly + 1) < gameTrackerX.primPool->lastPrim)
	{
		poly->p1.y2 = SCREEN_HEIGHT;
		poly->p1.y3 = SCREEN_HEIGHT;

		poly->drawTPage = (transtype << 5) | 0xE1000600;

		poly->p1.x0 = 0;
		poly->p1.y0 = 0;

		poly->p1.x1 = SCREEN_WIDTH;
		poly->p1.y1 = 0;

		poly->p1.x2 = 0;
		poly->p1.x3 = SCREEN_WIDTH;

		((unsigned int*)&poly->p1.r0)[0] = color;

		poly->p1.code = 0x2A;
		poly->len = 0x6;

#if defined(PSXPC_VERSION)
		addPrim(drawot[zdepth * 2], poly);
#else
		addPrim(drawot[zdepth], poly);
#endif

		gameTrackerX.primPool->nextPrim = (unsigned long*)(poly + 1);
	}
}

POLY_GT4* FX_SetupPolyGT4(int x1, int y1, int x2, int y2, int otz, struct TextureMT3 *texture, long color0, long color1, long color2, long color3)
{
	POLY_GT4* poly;
	unsigned long** drawot;

	poly = (POLY_GT4*)gameTrackerX.primPool->nextPrim;
	drawot = gameTrackerX.drawOT;
	
	if ((char*)(poly + 1) < (char*)(gameTrackerX.primPool->lastPrim))
	{
		poly->u0 = texture->u2;
		poly->v0 = texture->v2;

		poly->u1 = texture->u1;
		poly->v1 = texture->v1;

		poly->x2 = x1;
		poly->x0 = x1;

		poly->x1 = x2;
		poly->x3 = x2;

		poly->y1 = y1;
		poly->y0 = y1;

		poly->y2 = y2;
		poly->y3 = y2;

		poly->u2 = texture->u0;
		poly->v2 = texture->v0;

		*(int*)&poly->r0 = color0 | 0x3C000000;
		*(int*)&poly->r1 = color1;
		*(int*)&poly->r2 = color2;
		
		poly->u3 = poly->u1;
		poly->v3 = poly->v2;

		*(int*)&poly->r3 = color3;

		poly->tpage = texture->tpage;
		poly->clut = texture->clut;

		if (otz <= 0)
		{
			otz = 1;
		}
		
#if defined(USE_32_BIT_ADDR)
		setlen(poly, 12);
		addPrim(drawot[otz * 2], poly);
#else
		setlen(poly, 12);
		addPrim(drawot[otz], poly);
#endif

		gameTrackerX.primPool->nextPrim = (unsigned long*)(poly + 1);

		return poly;
	}

	return NULL;
}


// autogenerated function stub: 
// void /*$ra*/ FX_MakeWarpArrow(int x /*$s1*/, int y /*$s3*/, int xsize /*$s2*/, int ysize /*$s4*/, int fade /*stack 16*/)
void FX_MakeWarpArrow(int x, int y, int xsize, int ysize, int fade)
{
	struct Object* particle;
	long color;
	POLY_GT4* poly;

	particle = (struct Object*)objectAccess[10].object;

	if (particle != NULL)
	{
		color = fade >> 5;

		if (fade < 0)
		{
			fade = 0;

			color = fade >> 5;

			if (fade < 0)
			{
				fade += 31;
				color = fade >> 5;
			}
		}

		color = color | color << 8 | color << 16;

		poly = FX_SetupPolyGT4(x + xsize, y, x, y + ysize, 3, FX_GetTextureObject(particle, 0, 9), color, color, color, color);

		if (poly != NULL)
		{
			poly->code |= 0x2;
		}
	}
}

void FX_MakeMannaIcon(int x, int y, int xsize, int ysize)
{ 
	struct Object* manna;
	struct TextureMT3* texture;
	POLY_GT4* poly;
	int n;
	int newx;
	int newy;
	int sizex;
	int sizey;
	unsigned long color;

	if (objectAccess[20].object != NULL)
	{
		texture = FX_GetTextureObject((struct Object*)objectAccess[20].object, 0, 7);

		poly = FX_SetupPolyGT4(x, y, x + xsize, y + ysize, 3, texture, 0x2962828, 0x2962828, 0x2962828, 0x2962828);
	
		if (poly != NULL)
		{
			poly->tpage |= 0x20;
		}

		if (objectAccess[10].object != NULL)
		{
			texture = FX_GetTextureObject((struct Object*)objectAccess[10].object, 0, 2);

			for (n = 0; n < 5; n++)
			{
				switch (n)
				{
				default:
				case 0:
				{
					newx = x + 33;
					newy = y - 1;

					sizex = 14;
					sizey = 12;

					color = 0x24B3232;

					break;
				}
				case 1:
				{
					newx = x + 3;
					newy = y + 5;

					sizex = 14;
					sizey = 12;

					color = 0x2704B4B;
					
					break;
				}
				case 2:
				{
					newx = x + 13;
					newy = y + 4;

					sizex = 19;
					sizey = 16;

					color = 0x2966464;

					break;
				}
				case 3:
				{
					newx = x + 3;
					newy = y + 16;

					sizex = 19;
					sizey = 16;

					color = 0x24B3232;

					break;
				}
				case 4:
				{
					newx = x + 32;
					newy = y + 13;

					sizex = 19;
					sizey = 16;

					color = 0x2966464;

					break;
				}
				}

				FX_SetupPolyGT4(newx, newy, newx + sizex, newy + sizey, 3, texture, color, color, color, color);
			}
		}
	}
}

void FX_MakeGlyphIcon(struct _Position* position, struct Object* glyphObject, int size, int glyphnum, int enabled)
{
	int sizex;
	POLY_GT4* poly;
	struct TextureMT3* texture;
	DVECTOR xy_pos;
	int otz;
	long* color_array;
	struct _GlyphTuneData* glyphtunedata;
	struct Object* object;

	if (glyphObject != NULL)
	{
		if (glyphnum == 7)
		{
			object = (struct Object*)objectAccess[10].object;

			if (object != NULL)
			{
				texture = FX_GetTextureObject(object, 0, 0);

				size = (size + (size >> 31)) >> 1;

				xy_pos.vx = position->x;
				xy_pos.vy = position->y;

				sizex = ((size << 9) / 320);

				glyphtunedata = (struct _GlyphTuneData*)glyphObject->data;

				otz = (24 - size) < 0 ? (((24 - size) + 3) >> 2) + 1 : ((24 - size) >> 2) + 1;

				color_array = glyphtunedata->color_array;

				if (enabled != 0)
				{
					poly = FX_SetupPolyGT4(position->x - sizex, position->y - size, position->x + sizex + 1, position->y + size + 1, otz, texture, color_array[glyphnum], color_array[glyphnum + 1], color_array[glyphnum + 2], color_array[glyphnum + 3]);
				}
				else
				{
					poly = FX_SetupPolyGT4(position->x - sizex, position->y - size, position->x + sizex + 1, position->y + size + 1, otz, texture, 0x202020, 0x202020, 0x202020, 0x202020);
				}

				if (poly != NULL)
				{
					poly->code = (((char*)&texture->color)[3] & 0x3) | 0x3C;
				}
			}
		}
		else
		{
			texture = FX_GetTextureObject(glyphObject, 0, glyphnum);

			xy_pos.vx = position->x;
			xy_pos.vy = position->y;

			sizex = ((size << 9) / 320);

			glyphtunedata = (struct _GlyphTuneData*)glyphObject->data;

			otz = (24 - size) < 0 ? (((24 - size) + 3) >> 2) + 1: ((24 - size) >> 2) + 1;

			color_array = &glyphtunedata->color_array[glyphnum * 4];

			if (enabled != 0)
			{
				poly = FX_SetupPolyGT4(position->x - sizex, position->y - size, position->x + sizex + 1, position->y + size + 1, otz, texture, color_array[0], color_array[1], color_array[2], color_array[3]);
			}
			else
			{
				poly = FX_SetupPolyGT4(position->x - sizex, position->y - size, position->x + sizex + 1, position->y + size + 1, otz, texture, 0x202020, 0x202020, 0x202020, 0x202020);
			}

			if (poly != NULL)
			{
				poly->code = (((char*)&texture->color)[3] & 0x3) | 0x3C;
			}
		}
	}
}


// autogenerated function stub: 
// void /*$ra*/ FX_SoulDustProcess(struct _FX_PRIM *fxPrim /*$s0*/, struct _FXTracker *fxTracker /*$a1*/)
void FX_SoulDustProcess(struct _FX_PRIM *fxPrim, struct _FXTracker *fxTracker)
{ // line 3253, offset 0x80046854
	/* begin block 1 */
		// Start line: 3254
		// Start offset: 0x80046854
		// Variables:
			//MATRIX *swTransform; // $v1
			_Position position; // stack offset -24
			long color; // stack offset -16
			long black; // stack offset -12
			int fade; // $a3
	/* end block 1 */
	// End offset: 0x800469F8
	// End Line: 3291

	/* begin block 2 */
		// Start line: 7956
	/* end block 2 */
	// End Line: 7957
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_MakeSoulDust(struct _Instance *instance /*$s4*/, short segment /*$a1*/)
void FX_MakeSoulDust(struct _Instance *instance, short segment)
{ // line 3292, offset 0x80046a08
	/* begin block 1 */
		// Start line: 3293
		// Start offset: 0x80046A08
		// Variables:
			struct _FX_PRIM *fxPrim; // $s1
			//SVECTORlocation; // stack offset -32
			struct Object *particle; // $s2
	/* end block 1 */
	// End offset: 0x80046C28
	// End Line: 3344

	/* begin block 2 */
		// Start line: 8084
	/* end block 2 */
	// End Line: 8085
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_WaterTrailProcess(struct _FX_PRIM *fxPrim /*$s0*/, struct _FXTracker *fxTracker /*$a1*/)
void FX_WaterTrailProcess(struct _FX_PRIM *fxPrim, struct _FXTracker *fxTracker)
{ // line 3367, offset 0x80046c48
	/* begin block 1 */
		// Start line: 6734
	/* end block 1 */
	// End Line: 6735
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_MakeWaterTrail(struct _Instance *instance /*$a0*/, int depth /*$a1*/)
void FX_MakeWaterTrail(struct _Instance *instance, int depth)
{ // line 3386, offset 0x80046d60
	/* begin block 1 */
		// Start line: 3387
		// Start offset: 0x80046D60
		// Variables:
			struct Object *waterfx; // $a1
			struct _Model *wxtrail; // $a0
			struct _SVector position; // stack offset -48
			int zvel; // $s0

		/* begin block 1.1 */
			// Start line: 3423
			// Start offset: 0x80046E6C
			// Variables:
				int n; // $s2
				int deg; // $s0
				struct _SVector vel; // stack offset -40
				struct _SVector accel; // stack offset -32
				struct _SVector startpos; // stack offset -24

			/* begin block 1.1.1 */
				// Start line: 3431
				// Start offset: 0x80046E84
				// Variables:
					int sinVal; // $s1
					int cosVal; // $s0
					int spd; // $v1
			/* end block 1.1.1 */
			// End offset: 0x80046F18
			// End Line: 3439
		/* end block 1.1 */
		// End offset: 0x80046F7C
		// End Line: 3444
	/* end block 1 */
	// End offset: 0x80046F7C
	// End Line: 3445

	/* begin block 2 */
		// Start line: 8277
	/* end block 2 */
	// End Line: 8278
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _FXRibbon * /*$ra*/ FX_StartRibbon(struct _Instance *instance /*$s7*/, short startSegment /*$s3*/, short endSegment /*stack -48*/, short type /*$fp*/, int ribbonLifeTime /*stack 16*/, int faceLifeTime /*stack 20*/, int startFadeValue /*stack 24*/, long startColor /*stack 28*/, long endColor /*stack 32*/)
struct _FXRibbon * FX_StartRibbon(struct _Instance *instance, short startSegment, short endSegment, short type, int ribbonLifeTime, int faceLifeTime, int startFadeValue, long startColor, long endColor)
{ // line 3480, offset 0x80046f94
	/* begin block 1 */
		// Start line: 3481
		// Start offset: 0x80046F94
		// Variables:
			//MATRIX *swTransform; // $a0
			struct _FXRibbon *ribbon; // $s0
			int i; // $a2
			int number; // $s1
	/* end block 1 */
	// End offset: 0x80047234
	// End Line: 3563

	/* begin block 2 */
		// Start line: 6960
	/* end block 2 */
	// End Line: 6961
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ FX_RibbonProcess(struct _FX_PRIM *fxPrim /*$a2*/, struct _FXTracker *fxTracker /*$a1*/)
void FX_RibbonProcess(struct _FX_PRIM *fxPrim, struct _FXTracker *fxTracker)
{ // line 3584, offset 0x80047264
	/* begin block 1 */
		// Start line: 3585
		// Start offset: 0x80047264
		// Variables:
			int d; // $a1
			long fade; // $a3
	/* end block 1 */
	// End offset: 0x80047348
	// End Line: 3624

	/* begin block 2 */
		// Start line: 7168
	/* end block 2 */
	// End Line: 7169
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_ConstrictProcess(struct _FX_PRIM *fxPrim /*$s1*/, struct _FXTracker *fxTracker /*$s2*/)
void FX_ConstrictProcess(struct _FX_PRIM *fxPrim, struct _FXTracker *fxTracker)
{ // line 3627, offset 0x80047358
	/* begin block 1 */
		// Start line: 8805
	/* end block 1 */
	// End Line: 8806
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_StartConstrict(struct _Instance *instance /*$a0*/, struct _SVector *constrict_point /*$a1*/, short startSegment /*$a2*/, short endSegment /*$a3*/)
void FX_StartConstrict(struct _Instance *instance, struct _SVector *constrict_point, short startSegment, short endSegment)
{ // line 3696, offset 0x800475fc
	/* begin block 1 */
		// Start line: 8988
	/* end block 1 */
	// End Line: 8989

	/* begin block 2 */
		// Start line: 8989
	/* end block 2 */
	// End Line: 8990
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_EndConstrict(int ConstrictEnemyFlag /*$a0*/, struct _Instance *instance /*$a1*/)
void FX_EndConstrict(int ConstrictEnemyFlag, struct _Instance *instance)
{ // line 3713, offset 0x8004768c
	/* begin block 1 */
		// Start line: 3714
		// Start offset: 0x8004768C

		/* begin block 1.1 */
			// Start line: 3721
			// Start offset: 0x800476AC
			// Variables:
				short _x1; // $v1
				short _y1; // $a0
				short _z1; // $a1
				_Position *_v0; // $v0
				_Position *_v1; // $v0
		/* end block 1.1 */
		// End offset: 0x800476AC
		// End Line: 3721

		/* begin block 1.2 */
			// Start line: 3725
			// Start offset: 0x800476B8
			// Variables:
				//short _x1; // $v1
				//short _y1; // $a0
				//short _z1; // $a1
				//_Position *_v0; // $v0
				//_Position *_v1; // $v0
		/* end block 1.2 */
		// End offset: 0x800476DC
		// End Line: 3725
	/* end block 1 */
	// End offset: 0x800476DC
	// End Line: 3729

	/* begin block 2 */
		// Start line: 9026
	/* end block 2 */
	// End Line: 9027
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_SubDividePrim(struct _FX_PRIM *fxPrim1 /*$s0*/, struct _FX_PRIM *fxPrim2 /*$s1*/)
void FX_SubDividePrim(struct _FX_PRIM *fxPrim1, struct _FX_PRIM *fxPrim2)
{ // line 3733, offset 0x800476f8
	/* begin block 1 */
		// Start line: 3734
		// Start offset: 0x800476F8
		// Variables:
			//SVECTORmp0; // stack offset -32
			//SVECTORmp1; // stack offset -24
	/* end block 1 */
	// End offset: 0x800476F8
	// End Line: 3734

	/* begin block 2 */
		// Start line: 9067
	/* end block 2 */
	// End Line: 9068
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_ContinueRibbon(struct _FXRibbon *ribbon /*$s2*/, struct _FXTracker *fxTracker /*$fp*/)
void FX_ContinueRibbon(struct _FXRibbon *ribbon, struct _FXTracker *fxTracker)
{ // line 3781, offset 0x800477bc
	/* begin block 1 */
		// Start line: 3782
		// Start offset: 0x800477BC
		// Variables:
			//MATRIX *swTransform; // $a1
			int i; // $s3
			int i2; // $s7
			int i3; // $v1
			int startIndex; // $a2
			int period; // stack offset -48
			int d; // $s5
			struct _FX_PRIM *fxPrim; // $s0
			struct _FX_PRIM *fxPrim2; // $s1
			//SVECTORQuad[4]; // stack offset -80

		/* begin block 1.1 */
			// Start line: 3909
			// Start offset: 0x80047C38
			// Variables:
				int fade; // $v1
		/* end block 1.1 */
		// End offset: 0x80047CD4
		// End Line: 3933
	/* end block 1 */
	// End offset: 0x80047D5C
	// End Line: 3948

	/* begin block 2 */
		// Start line: 9166
	/* end block 2 */
	// End Line: 9167
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_StandardFXPrimProcess(struct _FX_PRIM *fxPrim /*$s0*/, struct _FXTracker *fxTracker /*$a3*/)
void FX_StandardFXPrimProcess(struct _FX_PRIM *fxPrim, struct _FXTracker *fxTracker)
{ // line 3953, offset 0x80047d8c
	/* begin block 1 */
		// Start line: 3954
		// Start offset: 0x80047D8C
		// Variables:
			long flags; // $a2

		/* begin block 1.1 */
			// Start line: 3969
			// Start offset: 0x80047DD8
			// Variables:
				long start; // stack offset -16
				long end; // stack offset -12
		/* end block 1.1 */
		// End offset: 0x80047EBC
		// End Line: 3984

		/* begin block 1.2 */
			// Start line: 3988
			// Start offset: 0x80047EC8
			// Variables:
				int current_scale; // $v1
		/* end block 1.2 */
		// End offset: 0x80047EF8
		// End Line: 3998

		/* begin block 1.3 */
			// Start line: 4003
			// Start offset: 0x80047F00
			// Variables:
				//MATRIX *swTransform; // $v1
		/* end block 1.3 */
		// End offset: 0x80047F00
		// End Line: 4004

		/* begin block 1.4 */
			// Start line: 4173
			// Start offset: 0x8004808C
			// Variables:
				struct _Rotation rot; // stack offset -24
		/* end block 1.4 */
		// End offset: 0x800480EC
		// End Line: 4181
	/* end block 1 */
	// End offset: 0x800480EC
	// End Line: 4190

	/* begin block 2 */
		// Start line: 9745
	/* end block 2 */
	// End Line: 9746
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_AttachedParticlePrimProcess(struct _FX_PRIM *fxPrim /*$a2*/, struct _FXTracker *fxTracker /*$a1*/)
void FX_AttachedParticlePrimProcess(struct _FX_PRIM *fxPrim, struct _FXTracker *fxTracker)
{ // line 4192, offset 0x800480fc
	/* begin block 1 */
		// Start line: 4193
		// Start offset: 0x800480FC
		// Variables:
			//MATRIX *swTransform; // $a3
			//MATRIX *swTransformOld; // $t0
			struct _Instance *instance; // $v1
	/* end block 1 */
	// End offset: 0x80048178
	// End Line: 4207

	/* begin block 2 */
		// Start line: 10243
	/* end block 2 */
	// End Line: 10244
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_FlamePrimProcess(struct _FX_PRIM *fxPrim /*$a3*/, struct _FXTracker *fxTracker /*$a1*/)
void FX_FlamePrimProcess(struct _FX_PRIM *fxPrim, struct _FXTracker *fxTracker)
{ // line 4210, offset 0x80048190
	/* begin block 1 */
		// Start line: 4211
		// Start offset: 0x80048190
		// Variables:
			//MATRIX *swTransform; // $a0
			//MATRIX *swTransformOld; // $a2
			struct _Instance *instance; // $v0
			struct _SVector movement; // stack offset -16
			int total; // $a0
	/* end block 1 */
	// End offset: 0x80048354
	// End Line: 4244

	/* begin block 2 */
		// Start line: 10282
	/* end block 2 */
	// End Line: 10283
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_DFacadeParticleSetup(struct _FX_PRIM *fxPrim /*$t1*/, SVECTOR*center /*$a1*/, short halveWidth /*$a2*/, short halveHeight /*$a3*/, long color /*stack 16*/, SVECTOR*vel /*stack 20*/, SVECTOR*accl /*stack 24*/, struct _FXTracker *fxTracker /*stack 28*/, int timeToLive /*stack 32*/)
void FX_DFacadeParticleSetup(struct _FX_PRIM *fxPrim, SVECTOR*center, short halveWidth, short halveHeight, long color, SVECTOR*vel, SVECTOR*accl, struct _FXTracker *fxTracker, int timeToLive)
{ // line 4256, offset 0x80048364
	/* begin block 1 */
		// Start line: 4257
		// Start offset: 0x80048364

		/* begin block 1.1 */
			// Start line: 4257
			// Start offset: 0x80048364
			// Variables:
				short _x1; // $v0
				short _y1; // $v1
				short _z1; // $a0
				_Position *_v0; // $v0
		/* end block 1.1 */
		// End offset: 0x80048364
		// End Line: 4257
	/* end block 1 */
	// End offset: 0x80048444
	// End Line: 4298

	/* begin block 2 */
		// Start line: 10375
	/* end block 2 */
	// End Line: 10376
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _FX_PRIM * /*$ra*/ FX_Dot(struct _SVector *location /*$s4*/, struct _SVector *vel /*$s6*/, struct _SVector *accel /*$s7*/, int scale_speed /*$fp*/, long color /*stack 16*/, long size /*stack 20*/, int lifetime /*stack 24*/, int texture_num /*stack 28*/)
struct _FX_PRIM * FX_Dot(struct _SVector *location, struct _SVector *vel, struct _SVector *accel, int scale_speed, long color, long size, int lifetime, int texture_num)
{ // line 4302, offset 0x8004844c
	/* begin block 1 */
		// Start line: 4303
		// Start offset: 0x8004844C
		// Variables:
			struct _FX_PRIM *fxPrim; // $s0
	/* end block 1 */
	// End offset: 0x80048584
	// End Line: 4333

	/* begin block 2 */
		// Start line: 10514
	/* end block 2 */
	// End Line: 10515
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ FX_Blood(struct _SVector *location /*$s4*/, struct _SVector *input_vel /*$s1*/, struct _SVector *accel /*$s5*/, int amount /*$a3*/, long color /*stack 16*/, long size /*stack 20*/)
void FX_Blood(struct _SVector *location, struct _SVector *input_vel, struct _SVector *accel, int amount, long color, long size)
{ // line 4336, offset 0x800485b8
#if defined(PC_VERSION)
	int i; // esi
	struct _SVector vel; // [esp+4h] [ebp-8h] BYREF

	for (i = amount; i; --i)
	{
		vel.x = (rand() & 7) + input_vel->x * i / 128 - 4;
		vel.y = (rand() & 7) + input_vel->y * i / 128 - 4;
		vel.z = (rand() & 7) + input_vel->z * i / 128 - 4;
		FX_Dot(location, &vel, accel, 0, color, 2 * size, 16, 1);
	}
#else
	UNIMPLEMENTED();
#endif
}

void FX_Blood2(struct _SVector* location, struct _SVector* input_vel, struct _SVector* accel, int amount, long color, long dummyCrapShouldRemove)
{
#if defined(PSX_VERSION)
	FX_Blood(location, input_vel, accel, amount, color, 4);
#elif defined(PC_VERSION)
	int i; // esi
	struct _SVector vel; // [esp+4h] [ebp-8h] BYREF

	for (i = amount; i; --i)
	{
		vel.x = (rand() & 7) + input_vel->x * i / 128 - 4;
		vel.y = (rand() & 7) + input_vel->y * i / 128 - 4;
		vel.z = (rand() & 7) + input_vel->z * i / 128 - 4;
		FX_Dot(location, &vel, accel, 0, color, 8, 16, 1);
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ FX_Blood_Impale(struct _Instance *locinst /*$a0*/, short locseg /*$a1*/, struct _Instance *instance /*$a2*/, short segment /*$a3*/)
void FX_Blood_Impale(struct _Instance *locinst, short locseg, struct _Instance *instance, short segment)
{ // line 4383, offset 0x80048720
	/* begin block 1 */
		// Start line: 4384
		// Start offset: 0x80048720
		// Variables:
			struct _SVector location; // stack offset -40
			struct _SVector accel; // stack offset -32
			struct _SVector vel; // stack offset -24
			struct _SVector input_vel; // stack offset -16
			int i; // $s0
	/* end block 1 */
	// End offset: 0x800488DC
	// End Line: 4409

	/* begin block 2 */
		// Start line: 8766
	/* end block 2 */
	// End Line: 8767
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _FXParticle * /*$ra*/ FX_BloodCone(struct _Instance *instance /*$a0*/, short startSegment /*$a1*/, long time /*$s2*/)
struct _FXParticle * FX_BloodCone(struct _Instance *instance, short startSegment, long time)
{ // line 4415, offset 0x800488ec
	/* begin block 1 */
		// Start line: 4416
		// Start offset: 0x800488EC
		// Variables:
			struct _FXParticle *currentParticle; // $s0
			struct Object *particle; // $s1
	/* end block 1 */
	// End offset: 0x800489A0
	// End Line: 4444

	/* begin block 2 */
		// Start line: 10745
	/* end block 2 */
	// End Line: 10746
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// struct _FXParticle * /*$ra*/ FX_GetTorchParticle(struct _Instance *instance /*$s1*/, short startSegment /*$a1*/, int tex /*$s2*/, int birthRadius /*$s3*/, int num /*stack 16*/)
struct _FXParticle * FX_GetTorchParticle(struct _Instance *instance, short startSegment, int tex, int birthRadius, int num)
{ // line 4447, offset 0x800489b8
#if defined(PC_VERSION)
	struct _FXParticle* result; // eax
	struct Object* object; // edx
	int v7; // edx

	result = (struct _FXParticle*)MEMPACK_Malloc(sizeof(_FXParticle), 0xDu);
	if (result)
	{
		result->effectType = 1;
		result->type = 0;
		result->instance = instance;
		result->startSegment = startSegment;
		result->texture = 0;
		result->continue_process = FX_ContinueParticle;
		result->fxprim_process = 0;
		result->fxprim_modify_process = 0;
		result->startScale = 4096;
		result->scaleSpeed = 0;
		result->offset.z = 0;
		result->offset.y = 0;
		result->offset.x = 0;
		result->acceleration.z = 0;
		result->acceleration.y = 0;
		result->acceleration.x = 0;
		result->flag_bits = 0;
		result->z_undulate = 0;
	}
	if (result)
	{
		result->type = 1;
		result->fxprim_process = FX_FlamePrimProcess;
		object = instance->object;
		object->oflags2 |= 0x20000000u;
		v7 = *(DWORD*)(*(DWORD*)(*((DWORD*)object->modelList + 1) + 20) + 20);
		result->endColor = 0;
		result->flag_bits |= 1u;
		result->texture = (struct TextureMT3*)(16 * (tex + 1) + v7);
		result->startFadeValue = 5;
		result->fadeStep = 5;
		result->primLifeTime = 16;
		result->acceleration.z = 1;
		result->lifeTime = -1;
		result->startColor = 33571056;
		result->size = 48;
		result->scaleSpeed = 100;
		result->birthRadius = birthRadius;
		result->numberBirthParticles = num;
		result->next = ring;
		ring = (_FXParticle*)result;
	}
	return result;
#else
	UNIMPLEMENTED();
	return NULL;
#endif
}


// autogenerated function stub: 
// struct _FXParticle * /*$ra*/ FX_TorchFlame(struct _Instance *instance /*$s2*/, short startSegment /*$a1*/)
struct _FXParticle * FX_TorchFlame(struct _Instance *instance, short startSegment)
{ // line 4475, offset 0x80048a9c
	/* begin block 1 */
		// Start line: 4476
		// Start offset: 0x80048A9C
		// Variables:
			struct _FXParticle *currentParticle; // $s0
			struct Object *particle; // $s3
	/* end block 1 */
	// End offset: 0x80048BD8
	// End Line: 4524

	/* begin block 2 */
		// Start line: 10917
	/* end block 2 */
	// End Line: 10918
			UNIMPLEMENTED();
	return null;
}

int FX_GetMorphFadeVal()
{
#if defined(PSX_VERSION)
	int fade;
	
	fade = (gameTrackerX.gameData.asmData.MorphTime * 4096) / 1000;
	
	if (gameTrackerX.gameData.asmData.MorphType == 1) 
	{
		fade = 4096 - fade;
	}

	return fade;
#elif defined(PC_VERSION)
	int result = (gameTrackerX.gameData.asmData.MorphTime << 12) / 1000;
	if (gameTrackerX.gameData.asmData.MorphType == 1)
		return 4096 - result;
	return result;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ FX_ConvertCamPersToWorld(SVECTOR*campos /*$s0*/, SVECTOR*worldpos /*$s1*/)
void FX_ConvertCamPersToWorld(SVECTOR*campos, SVECTOR*worldpos)
{ // line 4550, offset 0x80048c38
	int vz; // esi
#if defined(PC_VERSION)
	SetRotMatrix(theCamera.cwTransform2);
	SetTransMatrix(theCamera.cwTransform2);
	campos->vx += D3D_XRes / -2;
	campos->vy += D3D_YRes / -2;
	vz = campos->vz;
	campos->vx = (__int16)(vz * (320 * campos->vx / 512)) / 320;
	campos->vy = vz * campos->vy / 320;
	gte_ldv0(campos);
	gte_MVMVA(1, 0, 0, 0, 0);
	gte_stsv(worldpos);
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ FX_GetRandomScreenPt(SVECTOR*point /*$s0*/)
void FX_GetRandomScreenPt(SVECTOR*point)
{ // line 4570, offset 0x80048d50
#if defined(PC_VERSION)
	point->vx = rand() % D3D_XRes;
	point->vy = rand() % D3D_YRes;
	point->vz = (rand() & 0xFFF) + 384;
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ FX_ProcessSnow(struct _FX_PRIM *fxPrim /*$s0*/, struct _FXTracker *fxTracker /*$s1*/)
void FX_ProcessSnow(struct _FX_PRIM *fxPrim, struct _FXTracker *fxTracker)
{ // line 4577, offset 0x80048ddc
	/* begin block 1 */
		// Start line: 4578
		// Start offset: 0x80048DDC

		/* begin block 1.1 */
			// Start line: 4581
			// Start offset: 0x80048E00
			// Variables:
				//SVECTORposition; // stack offset -24
		/* end block 1.1 */
		// End offset: 0x80048E48
		// End Line: 4597
	/* end block 1 */
	// End offset: 0x80048EFC
	// End Line: 4611

	/* begin block 2 */
		// Start line: 11162
	/* end block 2 */
	// End Line: 11163
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_ContinueSnow(struct _FXTracker *fxTracker /*$s1*/)
void FX_ContinueSnow(struct _FXTracker *fxTracker)
{ // line 4613, offset 0x80048f10
	/* begin block 1 */
		// Start line: 4614
		// Start offset: 0x80048F10
		// Variables:
			struct _FX_PRIM *fxPrim; // $s0
			//SVECTORposition; // stack offset -40
			//SVECTORvel; // stack offset -32

		/* begin block 1.1 */
			// Start line: 4631
			// Start offset: 0x80048F8C
			// Variables:
				//SVECTORcampos; // stack offset -24
		/* end block 1.1 */
		// End offset: 0x80049054
		// End Line: 4653
	/* end block 1 */
	// End offset: 0x80049054
	// End Line: 4655

	/* begin block 2 */
		// Start line: 11236
	/* end block 2 */
	// End Line: 11237
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_UpdateWind(struct _FXTracker *fxTracker /*$a0*/)
void FX_UpdateWind(struct _FXTracker *fxTracker)
{ // line 4657, offset 0x80049068
	/* begin block 1 */
		// Start line: 4658
		// Start offset: 0x80049068
		// Variables:
			short change; // $s0
	/* end block 1 */
	// End offset: 0x800491C4
	// End Line: 4675

	/* begin block 2 */
		// Start line: 11335
	/* end block 2 */
	// End Line: 11336
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_ProcessRain(struct _FX_PRIM *fxPrim /*$a2*/, struct _FXTracker *fxTracker /*$a1*/)
void FX_ProcessRain(struct _FX_PRIM *fxPrim, struct _FXTracker *fxTracker)
{ // line 4682, offset 0x800491e0
	/* begin block 1 */
		// Start line: 4683
		// Start offset: 0x800491E0
		// Variables:
			int zvel; // $a3
	/* end block 1 */
	// End offset: 0x800492A0
	// End Line: 4705

	/* begin block 2 */
		// Start line: 11389
	/* end block 2 */
	// End Line: 11390
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_ContinueRain(struct _FXTracker *fxTracker /*$s7*/)
void FX_ContinueRain(struct _FXTracker *fxTracker)
{ // line 4707, offset 0x800492b0
	/* begin block 1 */
		// Start line: 4708
		// Start offset: 0x800492B0
		// Variables:
			struct _FX_PRIM *fxPrim; // $s0
			//SVECTORcampos; // stack offset -56
			int n; // $s4
			int rain_pct; // $s6
			long waterZLevel; // $s2
			int slack; // $s1
			int fade; // $v0

		/* begin block 1.1 */
			// Start line: 4753
			// Start offset: 0x800493F8
			// Variables:
				struct _SVector worldpos; // stack offset -48
				int zvel; // $s3
		/* end block 1.1 */
		// End offset: 0x800495AC
		// End Line: 4796
	/* end block 1 */
	// End offset: 0x800495BC
	// End Line: 4798

	/* begin block 2 */
		// Start line: 11452
	/* end block 2 */
	// End Line: 11453
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_MakeSpark(struct _Instance *instance /*$a0*/, struct _Model *model /*$a1*/, int segment /*$a2*/)
void FX_MakeSpark(struct _Instance *instance, struct _Model *model, int segment)
{ // line 4803, offset 0x800495e8
	/* begin block 1 */
		// Start line: 4804
		// Start offset: 0x800495E8
		// Variables:
			struct _FXParticle *currentParticle; // $s0
			struct Object *particle; // $s1
	/* end block 1 */
	// End offset: 0x80049690
	// End Line: 4833

	/* begin block 2 */
		// Start line: 11768
	/* end block 2 */
	// End Line: 11769
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_ContinueParticle(struct _FXParticle *currentParticle /*$s2*/, struct _FXTracker *fxTracker /*stack 4*/)
void FX_ContinueParticle(struct _FXParticle *currentParticle, struct _FXTracker *fxTracker)
{ // line 4835, offset 0x800496a4
	/* begin block 1 */
		// Start line: 4836
		// Start offset: 0x800496A4
		// Variables:
			struct _FX_PRIM *fxPrim; // $s1
			//struct VECTOR movement; // stack offset -64
			int i; // $fp
			int num; // stack offset -44
			//MATRIX *swTransform; // $s4
			//MATRIX *swOldTransform; // $a1
			long birthRadius; // $s5
			struct _Instance *instance; // $s6
			int InstanceFade; // $s3
			unsigned long black; // stack offset -48

		/* begin block 1.1 */
			// Start line: 4956
			// Start offset: 0x80049C20
			// Variables:
				int tmp_blue; // $v1
				//struct CVECTOR *ptr; // $s0

			/* begin block 1.1.1 */
				// Start line: 4963
				// Start offset: 0x80049C44
				// Variables:
					int fade; // $v0
			/* end block 1.1.1 */
			// End offset: 0x80049C68
			// End Line: 4969
		/* end block 1.1 */
		// End offset: 0x80049C68
		// End Line: 4970
	/* end block 1 */
	// End offset: 0x80049EB4
	// End Line: 5035

	/* begin block 2 */
		// Start line: 11864
	/* end block 2 */
	// End Line: 11865
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_UpdraftPrimModify(struct _FX_PRIM *fxPrim /*$s3*/, struct _Instance *instance /*$a1*/, struct _FXParticle *particle /*$s1*/, struct _FXTracker *fxTracker /*$a3*/)
void FX_UpdraftPrimModify(struct _FX_PRIM *fxPrim, struct _Instance *instance, struct _FXParticle *particle, struct _FXTracker *fxTracker)
{ // line 5037, offset 0x80049ee4
	/* begin block 1 */
		// Start line: 5038
		// Start offset: 0x80049EE4
		// Variables:
			int deg; // $s2
	/* end block 1 */
	// End offset: 0x80049FF8
	// End Line: 5044

	/* begin block 2 */
		// Start line: 12443
	/* end block 2 */
	// End Line: 12444
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_MakeParticleTexFX(struct _FX_PRIM *fxPrim /*$s0*/, struct _SVector *position /*$a1*/, struct Object *object /*$s1*/, int modelnum /*$s4*/, int texnum /*stack 16*/, struct _SVector *vel /*stack 20*/, struct _SVector *accl /*stack 24*/, long color /*stack 28*/, int size /*stack 32*/, int life /*stack 36*/)
void FX_MakeParticleTexFX(struct _FX_PRIM *fxPrim, struct _SVector *position, struct Object *object, int modelnum, int texnum, struct _SVector *vel, struct _SVector *accl, long color, int size, int life)
{ // line 5047, offset 0x8004a028
	/* begin block 1 */
		// Start line: 12463
	/* end block 1 */
	// End Line: 12464
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_MakeHitFX(struct _SVector *position /*$s1*/)
void FX_MakeHitFX(struct _SVector *position)
{ // line 5070, offset 0x8004a130
	/* begin block 1 */
		// Start line: 5071
		// Start offset: 0x8004A130
		// Variables:
			struct _FX_PRIM *fxPrim; // $s0
	/* end block 1 */
	// End offset: 0x8004A1B0
	// End Line: 5082

	/* begin block 2 */
		// Start line: 12529
	/* end block 2 */
	// End Line: 12530
			UNIMPLEMENTED();
}

void FX_ContinueLightning(struct _FXLightning* zap, struct _FXTracker* fxTracker)//Matching - 99.58%
{
	zap->deg += zap->deg_inc;

	if (zap->lifeTime > 0)
	{
		zap->lifeTime = zap->lifeTime - FX_Frames;

		if (zap->lifeTime <= 0)
		{
			FX_DeleteGeneralEffect((struct _FXGeneralEffect*)zap);
		}
	}
}

void FX_SetReaverInstance(struct _Instance* instance)
{
	FX_reaver_instance = instance;
}

// autogenerated function stub: 
// void /*$ra*/ FX_SoulReaverBlade(struct _Instance *instance /*$a0*/, unsigned long **drawot /*stack 4*/)
void FX_SoulReaverBlade(struct _Instance *instance, unsigned long **drawot)
{ // line 5128, offset 0x8004a230
	/* begin block 1 */
		// Start line: 5129
		// Start offset: 0x8004A230
		// Variables:
			//SVECTORlocation; // stack offset -136
			int i; // $s3
			int size; // $s2
			int reaverScale; // $s7
			struct Object *sreaver; // $s2
			struct __ReaverData *data; // $s1
			short deg; // $s4
			long color; // $fp
			struct TextureMT3 *texture; // $v0
			//MATRIX mat; // stack offset -128
			//struct DVECTOR xy_pos; // stack offset -96
			long sizex; // stack offset -48
			long sizey; // $a0
			long otz; // stack offset -44
			//struct POLY_FT4 *poly; // $s5
			//struct POLY_FT4 poly2; // stack offset -88

		/* begin block 1.1 */
			// Start line: 5186
			// Start offset: 0x8004A398
			// Variables:
				int scale1; // $s0
		/* end block 1.1 */
		// End offset: 0x8004A5C4
		// End Line: 5252
	/* end block 1 */
	// End offset: 0x8004A5F0
	// End Line: 5256

	/* begin block 2 */
		// Start line: 12648
	/* end block 2 */
	// End Line: 12649
				UNIMPLEMENTED();
}

void FX_ReaverBladeInit()
{
}


// autogenerated function stub: 
// void /*$ra*/ FX_SoulReaverWinding(struct _Instance *instance /*stack 0*/, struct _PrimPool *primPool /*$a1*/, unsigned long **ot /*stack 8*/, MATRIX *wcTransform /*stack 12*/)
void FX_SoulReaverWinding(struct _Instance *instance, struct _PrimPool *primPool, unsigned long **ot, MATRIX *wcTransform)
{ // line 5275, offset 0x8004a628
	/* begin block 1 */
		// Start line: 5276
		// Start offset: 0x8004A628
		// Variables:
			//MATRIX mat; // stack offset -96
			//MATRIX *swTransform; // $a1
			struct _SVector start; // stack offset -64
			struct _SVector end; // stack offset -56
			struct __ReaverData *data; // $s4
			long color; // $s5
			long glow_color; // stack offset -48
	/* end block 1 */
	// End offset: 0x8004A848
	// End Line: 5350

	/* begin block 2 */
		// Start line: 13213
	/* end block 2 */
	// End Line: 13214
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_UpdateInstanceWaterSplit(struct _Instance *instance /*$s0*/)
void FX_UpdateInstanceWaterSplit(struct _Instance *instance)
{ // line 5356, offset 0x8004a878
	/* begin block 1 */
		// Start line: 5357
		// Start offset: 0x8004A878
		// Variables:
			struct _SVector normal; // stack offset -16
	/* end block 1 */
	// End offset: 0x8004A938
	// End Line: 5391

	/* begin block 2 */
		// Start line: 13407
	/* end block 2 */
	// End Line: 13408
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_GetPlaneEquation(struct _SVector *normal /*$a0*/, struct _SVector *poPlane /*$a1*/, struct _PlaneConstants *plane /*$a2*/)
void FX_GetPlaneEquation(struct _SVector *normal, struct _SVector *poPlane, struct _PlaneConstants *plane)
{ // line 5393, offset 0x8004a948
	/* begin block 1 */
		// Start line: 13486
	/* end block 1 */
	// End Line: 13487

	/* begin block 2 */
		// Start line: 13488
	/* end block 2 */
	// End Line: 13489
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_DoInstancePowerRing(struct _Instance *instance /*$s4*/, long atuTime /*$s1*/, long *color /*$s3*/, long numColors /*$s2*/, int follow_halveplane /*stack 16*/)
void FX_DoInstancePowerRing(struct _Instance *instance, long atuTime, long *color, long numColors, int follow_halveplane)
{ // line 5436, offset 0x8004a9bc
	/* begin block 1 */
		// Start line: 5437
		// Start offset: 0x8004A9BC
		// Variables:
			struct _FXHalvePlane *ring; // $s0
			struct _SVector normal; // stack offset -40
			struct _SVector point; // stack offset -32
			long i; // $a1
	/* end block 1 */
	// End offset: 0x8004AB1C
	// End Line: 5484

	/* begin block 2 */
		// Start line: 10872
	/* end block 2 */
	// End Line: 10873
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_UpdatePowerRing(struct _FXHalvePlane *ring /*$s2*/)
void FX_UpdatePowerRing(struct _FXHalvePlane *ring)
{ // line 5488, offset 0x8004ab3c
	/* begin block 1 */
		// Start line: 5489
		// Start offset: 0x8004AB3C
		// Variables:
			struct _Instance *instance; // $v1
			struct _PlaneConstants *cPlane; // $s1
			long offset; // $s5
			long offset2; // $s4
			long cutX; // $s6
			long cutY; // $s7
			long cutZ; // $s3
			long colorIndex; // $a2
			long percent; // $a1
	/* end block 1 */
	// End offset: 0x8004AD80
	// End Line: 5548

	/* begin block 2 */
		// Start line: 13665
	/* end block 2 */
	// End Line: 13666
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_UpdateInstanceSplitRing(struct _FXHalvePlane *ring /*$s0*/, struct _FXTracker *fxTracker /*$a1*/)
void FX_UpdateInstanceSplitRing(struct _FXHalvePlane *ring, struct _FXTracker *fxTracker)
{ // line 5633, offset 0x8004adc0
	/* begin block 1 */
		// Start line: 13978
	/* end block 1 */
	// End Line: 13979
	UNIMPLEMENTED();
}

void FX_UpdateGlowEffect(struct _FXGlowEffect* effect, struct _FXTracker* fxTracker)
{
	if (effect->lifeTime == 0)
	{
		FX_DeleteGeneralEffect((struct _FXGeneralEffect*)effect);
	}
}

void FX_InsertGeneralEffect(void* ptr)
{
	FX_GeneralEffectTracker->next = FX_GeneralEffectTracker;
	FX_GeneralEffectTracker = (struct _FXGeneralEffect*)ptr;
}


// autogenerated function stub: 
// void /*$ra*/ FX_DeleteGeneralEffect(struct _FXGeneralEffect *effect /*$s0*/)
void FX_DeleteGeneralEffect(struct _FXGeneralEffect *effect)
{ // line 5672, offset 0x8004ae90
	/* begin block 1 */
		// Start line: 5673
		// Start offset: 0x8004AE90
		// Variables:
			struct _FXGeneralEffect *currentEffect; // $v0
			struct _FXGeneralEffect *previousEffect; // $v1
	/* end block 1 */
	// End offset: 0x8004AF1C
	// End Line: 5705

	/* begin block 2 */
		// Start line: 14058
	/* end block 2 */
	// End Line: 14059
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _FXGlowEffect * /*$ra*/ FX_DoInstanceOneSegmentGlow(struct _Instance *instance /*$s3*/, long segment /*$s4*/, long *color /*$s2*/, long numColors /*$s1*/, long atuColorCycleRate /*stack 16*/, long width /*stack 20*/, long height /*stack 24*/)
struct _FXGlowEffect * FX_DoInstanceOneSegmentGlow(struct _Instance *instance, long segment, long *color, long numColors, long atuColorCycleRate, long width, long height)
{ // line 5710, offset 0x8004af2c
	/* begin block 1 */
		// Start line: 5711
		// Start offset: 0x8004AF2C
		// Variables:
			struct _FXGlowEffect *glowEffect; // $a2

		/* begin block 1.1 */
			// Start line: 5743
			// Start offset: 0x8004AFF4
			// Variables:
				int i; // $a1
		/* end block 1.1 */
		// End offset: 0x8004B04C
		// End Line: 5756
	/* end block 1 */
	// End offset: 0x8004B058
	// End Line: 5762

	/* begin block 2 */
		// Start line: 14134
	/* end block 2 */
	// End Line: 14135
				UNIMPLEMENTED();
	return null;
}

void FX_SetGlowFades(struct _FXGlowEffect* glowEffect, int fadein, int fadeout) //Matching - 100%
{
	glowEffect->fadein_time = (fadein * 32) + fadein;

	glowEffect->fadeout_time = (fadeout * 32) + fadeout;
}

struct _FXGlowEffect* FX_DoInstanceTwoSegmentGlow(struct _Instance* instance, long segment, long segmentEnd, long* color, long numColors, long atuColorCycleRate, long height)//Mathing - 99.77%
{
	int inc;
	struct _FXGlowEffect* glowEffect;

	inc = segmentEnd - segment;
	
	if (segmentEnd - segment < 0)
	{
		segment = segmentEnd;
	
		inc = -inc;
	}
	
	glowEffect = FX_DoInstanceOneSegmentGlow(instance, segment, color, numColors, atuColorCycleRate, height, height);
	
	glowEffect->numSegments = 2;
	
	glowEffect->SegmentInc = inc;
	
	return glowEffect;
}

struct _FXGlowEffect* FX_DoInstanceManySegmentGlow(struct _Instance* instance, long segment, long numSegments, long *color, long numColors, long atuColorCycleRate, long height)
{
	struct _FXGlowEffect* glowEffect;
	
	glowEffect = FX_DoInstanceOneSegmentGlow(instance, segment, color, numColors, atuColorCycleRate, height, height);
	
	glowEffect->numSegments = numSegments;

	return glowEffect;
}

struct _FXGlowEffect* FX_DoInstanceOneSegmentGlowWithTime(struct _Instance* instance, long segment, long* color, long numColors, long atuColorCycleRate, long width, long height, long ATULifeTime)
{
	struct _FXGlowEffect* glowEffect;
	
	glowEffect = FX_DoInstanceOneSegmentGlow(instance, segment, color, numColors, atuColorCycleRate, width, height);

	glowEffect->lifeTime = ATULifeTime * 33;

	return glowEffect;
}


// autogenerated function stub: 
// void /*$ra*/ FX_StopAllGlowEffects(struct _Instance *instance /*$s3*/, int fadeout_time /*$s0*/)
void FX_StopAllGlowEffects(struct _Instance *instance, int fadeout_time)
{ // line 5812, offset 0x8004b190
	/* begin block 1 */
		// Start line: 5813
		// Start offset: 0x8004B190
		// Variables:
			struct _FXGlowEffect *currentEffect; // $a0
			struct _FXGlowEffect *previousEffect; // $s1

		/* begin block 1.1 */
			// Start line: 5828
			// Start offset: 0x8004B1E8
		/* end block 1.1 */
		// End offset: 0x8004B1E8
		// End Line: 5829
	/* end block 1 */
	// End offset: 0x8004B208
	// End Line: 5837

	/* begin block 2 */
		// Start line: 14367
	/* end block 2 */
	// End Line: 14368
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_StopGlowEffect(struct _FXGlowEffect *glowEffect /*$s1*/, int fadeout_time /*$a1*/)
void FX_StopGlowEffect(struct _FXGlowEffect *glowEffect, int fadeout_time)
{ // line 5839, offset 0x8004b224
	/* begin block 1 */
		// Start line: 5840
		// Start offset: 0x8004B224

		/* begin block 1.1 */
			// Start line: 5849
			// Start offset: 0x8004B268
			// Variables:
				struct _FXGeneralEffect *currentEffect; // $a0
				struct _FXGeneralEffect *previousEffect; // $s0
		/* end block 1.1 */
		// End offset: 0x8004B294
		// End Line: 5862
	/* end block 1 */
	// End offset: 0x8004B294
	// End Line: 5863

	/* begin block 2 */
		// Start line: 14433
	/* end block 2 */
	// End Line: 14434
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_DrawLightning(struct _FXLightning *zap /*$s1*/, MATRIX *wcTransform /*$s2*/, unsigned long **ot /*$s3*/)
void FX_DrawLightning(struct _FXLightning *zap, MATRIX *wcTransform, unsigned long **ot)
{ // line 5865, offset 0x8004b2ac
	/* begin block 1 */
		// Start line: 5866
		// Start offset: 0x8004B2AC
		// Variables:
			struct _SVector start; // stack offset -80
			struct _SVector end; // stack offset -72
			struct _SVector offset; // stack offset -64
			//MATRIX *swtransform; // $s0
			//MATRIX mat; // stack offset -56
	/* end block 1 */
	// End offset: 0x8004B4D8
	// End Line: 5928

	/* begin block 2 */
		// Start line: 14487
	/* end block 2 */
	// End Line: 14488
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_DrawAllGeneralEffects(MATRIX *wcTransform /*$s1*/, struct _VertexPool *vertexPool /*$s3*/, struct _PrimPool *primPool /*$s4*/, unsigned long **ot /*$s2*/)
void FX_DrawAllGeneralEffects(MATRIX *wcTransform, struct _VertexPool *vertexPool, struct _PrimPool *primPool, unsigned long **ot)
{ // line 5935, offset 0x8004b560
	/* begin block 1 */
		// Start line: 5936
		// Start offset: 0x8004B560
		// Variables:
			struct _Instance *instance; // $a0
			struct _FXGeneralEffect *currentEffect; // $s0

		/* begin block 1.1 */
			// Start line: 5949
			// Start offset: 0x8004B5EC
			// Variables:
				struct _FXGlowEffect *currentGlow; // $t0
		/* end block 1.1 */
		// End offset: 0x8004B61C
		// End Line: 5957

		/* begin block 1.2 */
			// Start line: 5961
			// Start offset: 0x8004B644
		/* end block 1.2 */
		// End offset: 0x8004B644
		// End Line: 5962

		/* begin block 1.3 */
			// Start line: 5971
			// Start offset: 0x8004B688
		/* end block 1.3 */
		// End offset: 0x8004B688
		// End Line: 5973

		/* begin block 1.4 */
			// Start line: 5981
			// Start offset: 0x8004B6E0
		/* end block 1.4 */
		// End offset: 0x8004B6E0
		// End Line: 5983
	/* end block 1 */
	// End offset: 0x8004B718
	// End Line: 5993

	/* begin block 2 */
		// Start line: 14629
	/* end block 2 */
	// End Line: 14630
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_ContinueBlastRing(struct _FXBlastringEffect *blast /*$s0*/, struct _FXTracker *fxTracker /*$a1*/)
void FX_ContinueBlastRing(struct _FXBlastringEffect *blast, struct _FXTracker *fxTracker)
{ // line 6003, offset 0x8004b738
	/* begin block 1 */
		// Start line: 6004
		// Start offset: 0x8004B738
		// Variables:
			int fade; // $a2
			int tm; // $v0

		/* begin block 1.1 */
			// Start line: 6015
			// Start offset: 0x8004B7A8
			// Variables:
				int rad; // $v0
				int crad; // $a0
				int endrad; // $v1
		/* end block 1.1 */
		// End offset: 0x8004B850
		// End Line: 6047

		/* begin block 1.2 */
			// Start line: 6051
			// Start offset: 0x8004B860
			// Variables:
				unsigned long *colorPtr; // $a0
				unsigned long black; // stack offset -16
				//int fade; // $a3
		/* end block 1.2 */
		// End offset: 0x8004B8A8
		// End Line: 6059
	/* end block 1 */
	// End offset: 0x8004B93C
	// End Line: 6080

	/* begin block 2 */
		// Start line: 14770
	/* end block 2 */
	// End Line: 14771

	/* begin block 3 */
		// Start line: 14775
	/* end block 3 */
	// End Line: 14776
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _FXBlastringEffect * /*$ra*/ FX_DoBlastRing(struct _Instance *instance /*$s2*/, struct _SVector *position /*$s5*/, MATRIX *mat /*$s3*/, int segment /*$s6*/, int radius /*stack 16*/, int endRadius /*stack 20*/, int colorChangeRadius /*stack 24*/, int size1 /*stack 28*/, int size2 /*stack 32*/, int vel /*stack 36*/, int accl /*stack 40*/, int height1 /*stack 44*/, int height2 /*stack 48*/, int height3 /*stack 52*/, long startColor /*stack 56*/, long endColor /*stack 60*/, int pred_offset /*stack 64*/, int lifeTime /*stack 68*/, int sortInWorld /*stack 72*/)
struct _FXBlastringEffect * FX_DoBlastRing(struct _Instance *instance, struct _SVector *position, MATRIX *mat, int segment, int radius, int endRadius, int colorChangeRadius, int size1, int size2, int vel, int accl, int height1, int height2, int height3, long startColor, long endColor, int pred_offset, int lifeTime, int sortInWorld)
{ // line 6110, offset 0x8004b94c
	/* begin block 1 */
		// Start line: 6111
		// Start offset: 0x8004B94C
		// Variables:
			struct _FXBlastringEffect *blast; // $s0
	/* end block 1 */
	// End offset: 0x8004BAF4
	// End Line: 6151

	/* begin block 2 */
		// Start line: 14998
	/* end block 2 */
	// End Line: 14999
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ FX_DrawBlastring(MATRIX *wcTransform /*$s3*/, struct _FXBlastringEffect *blast /*$s1*/)
void FX_DrawBlastring(MATRIX *wcTransform, struct _FXBlastringEffect *blast)
{ // line 6154, offset 0x8004bb20
	/* begin block 1 */
		// Start line: 6155
		// Start offset: 0x8004BB20
		// Variables:
			int radius; // $s2
			struct _SVector position; // stack offset -64
			//MATRIX mat; // stack offset -56

		/* begin block 1.1 */
			// Start line: 6162
			// Start offset: 0x8004BB60
			// Variables:
				//MATRIX *swtransform; // $s0
		/* end block 1.1 */
		// End offset: 0x8004BB9C
		// End Line: 6175
	/* end block 1 */
	// End offset: 0x8004BCD0
	// End Line: 6197

	/* begin block 2 */
		// Start line: 15098
	/* end block 2 */
	// End Line: 15099
			UNIMPLEMENTED();
}

void FX_ContinueFlash(struct _FXFlash* flash, struct _FXTracker* fxTracker)//Matching - 99.50%
{
	flash->currentTime = flash->currentTime + gameTrackerX.timeMult;

	if (flash->currentTime / 16 >= flash->timeFromColor)
	{
		FX_DeleteGeneralEffect((struct _FXGeneralEffect*)flash);
	}
}


// autogenerated function stub: 
// void /*$ra*/ FX_DrawFlash(struct _FXFlash *flash /*$a0*/)
void FX_DrawFlash(struct _FXFlash *flash)
{ // line 6210, offset 0x8004bd3c
	/* begin block 1 */
		// Start line: 6211
		// Start offset: 0x8004BD3C
		// Variables:
			int time; // $a1
			int div; // $a2
			int transtype; // $s0
			int interp; // $a3
			unsigned long color; // stack offset -16
			unsigned long black; // stack offset -12
	/* end block 1 */
	// End offset: 0x8004BE30
	// End Line: 6241

	/* begin block 2 */
		// Start line: 15210
	/* end block 2 */
	// End Line: 15211
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_RelocateGeneric(struct Object *object /*$a0*/, long offset /*$a1*/)
void FX_RelocateGeneric(struct Object *object, long offset)
{ // line 6244, offset 0x8004be50
	/* begin block 1 */
		// Start line: 6246
		// Start offset: 0x8004BE50
		// Variables:
			struct GenericFXObject *GFXO; // $v0
	/* end block 1 */
	// End offset: 0x8004BEE4
	// End Line: 6255

	/* begin block 2 */
		// Start line: 15281
	/* end block 2 */
	// End Line: 15282

	/* begin block 3 */
		// Start line: 15282
	/* end block 3 */
	// End Line: 15283

	/* begin block 4 */
		// Start line: 15284
	/* end block 4 */
	// End Line: 15285
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _FXParticle * /*$ra*/ FX_StartGenericParticle(struct _Instance *instance /*$a0*/, int num /*$a1*/, int segOverride /*$s3*/, int lifeOverride /*$s4*/, int InitFlag /*stack 16*/)
struct _FXParticle * FX_StartGenericParticle(struct _Instance *instance, int num, int segOverride, int lifeOverride, int InitFlag)
{ // line 6258, offset 0x8004beec
	/* begin block 1 */
		// Start line: 6259
		// Start offset: 0x8004BEEC
		// Variables:
			struct _FXParticle *currentParticle; // $s0
			struct GenericFXObject *GFXO; // $v1
			struct _GenericParticleParams *GPP; // $s1
			struct Object *texture_obj; // $s2
			struct Object *particle; // $a2

		/* begin block 1.1 */
			// Start line: 6324
			// Start offset: 0x8004C14C
			// Variables:
				struct TextureMT3 *texture; // $v0
		/* end block 1.1 */
		// End offset: 0x8004C174
		// End Line: 6328

		/* begin block 1.2 */
			// Start line: 6338
			// Start offset: 0x8004C1EC
			// Variables:
				int tmp_blue; // $a0
				//struct CVECTOR *ptr; // $v1
		/* end block 1.2 */
		// End offset: 0x8004C210
		// End Line: 6347
	/* end block 1 */
	// End offset: 0x8004C21C
	// End Line: 6352

	/* begin block 2 */
		// Start line: 15309
	/* end block 2 */
	// End Line: 15310
				UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ FX_StartGenericRibbon(struct _Instance *instance /*$a0*/, int num /*$a1*/, int segOverride /*$a2*/, int endOverride /*$a3*/, int InitFlag /*stack 16*/)
void FX_StartGenericRibbon(struct _Instance *instance, int num, int segOverride, int endOverride, int InitFlag)
{ // line 6354, offset 0x8004c23c
	/* begin block 1 */
		// Start line: 6355
		// Start offset: 0x8004C23C
		// Variables:
			struct Object *particle; // $v1
			struct GenericFXObject *GFXO; // $v1
			struct _GenericRibbonParams *GRP; // $v1
	/* end block 1 */
	// End offset: 0x8004C2E8
	// End Line: 6390

	/* begin block 2 */
		// Start line: 15519
	/* end block 2 */
	// End Line: 15520
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_StartGenericGlow(struct _Instance *instance /*$a0*/, int num /*$a1*/, int segOverride /*$t0*/, int seg2Override /*$a3*/, int InitFlag /*stack 16*/)
void FX_StartGenericGlow(struct _Instance *instance, int num, int segOverride, int seg2Override, int InitFlag)
{ // line 6392, offset 0x8004c2f8
	/* begin block 1 */
		// Start line: 6393
		// Start offset: 0x8004C2F8
		// Variables:
			struct Object *particle; // $v1
			struct GenericFXObject *GFXO; // $t1
			struct _GenericGlowParams *GGP; // $s0
			struct _FXGlowEffect *glowEffect; // $a0
			long *color; // $v1

		/* begin block 1.1 */
			// Start line: 6420
			// Start offset: 0x8004C384
			// Variables:
				int seg; // $a1
		/* end block 1.1 */
		// End offset: 0x8004C390
		// End Line: 6422

		/* begin block 1.2 */
			// Start line: 6426
			// Start offset: 0x8004C3C8
			// Variables:
				//int seg; // $a1
				int segEnd; // $a2
		/* end block 1.2 */
		// End offset: 0x8004C3E8
		// End Line: 6437

		/* begin block 1.3 */
			// Start line: 6441
			// Start offset: 0x8004C418
			// Variables:
				//int seg; // $a1
				int numSeg; // $a2
		/* end block 1.3 */
		// End offset: 0x8004C460
		// End Line: 6460
	/* end block 1 */
	// End offset: 0x8004C490
	// End Line: 6467

	/* begin block 2 */
		// Start line: 15602
	/* end block 2 */
	// End Line: 15603
				UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _FXLightning * /*$ra*/ FX_CreateLightning(struct _Instance *instance /*$s1*/, int lifeTime /*$s2*/, int deg /*$s3*/, int deg_inc /*$s4*/, int width /*stack 16*/, int small_width /*stack 20*/, int segs /*stack 24*/, int sine_size /*stack 28*/, int variation /*stack 32*/, unsigned long color /*stack 36*/, unsigned long glow_color /*stack 40*/)
struct _FXLightning * FX_CreateLightning(struct _Instance *instance, int lifeTime, int deg, int deg_inc, int width, int small_width, int segs, int sine_size, int variation, unsigned long color, unsigned long glow_color)
{ // line 6487, offset 0x8004c4a0
	/* begin block 1 */
		// Start line: 6488
		// Start offset: 0x8004C4A0
		// Variables:
			struct _FXLightning *zap; // $s0
	/* end block 1 */
	// End offset: 0x8004C584
	// End Line: 6523

	/* begin block 2 */
		// Start line: 15802
	/* end block 2 */
	// End Line: 15803
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// void /*$ra*/ FX_SetLightingPos(struct _FXLightning *zap /*$a0*/, struct _Instance *startInstance /*$a1*/, int startSeg /*$a2*/, _Position *startOffset /*$a3*/, struct _Instance *endInstance /*stack 16*/, int endSeg /*stack 20*/, _Position *endOffset /*stack 24*/, int matrixSeg /*stack 28*/)
void FX_SetLightingPos(struct _FXLightning *zap, struct _Instance *startInstance, int startSeg, _Position *startOffset, struct _Instance *endInstance, int endSeg, _Position *endOffset, int matrixSeg)
{ // line 6544, offset 0x8004c5a8
	/* begin block 1 */
		// Start line: 15928
	/* end block 1 */
	// End Line: 15929
	UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _FXLightning * /*$ra*/ FX_StartGenericLightning(struct _Instance *instance /*$s2*/, int num /*$a1*/, int segOverride /*$s3*/, int endSegOverride /*$s4*/)
struct _FXLightning * FX_StartGenericLightning(struct _Instance *instance, int num, int segOverride, int endSegOverride)
{ // line 6573, offset 0x8004c658
	/* begin block 1 */
		// Start line: 6574
		// Start offset: 0x8004C658
		// Variables:
			struct _FXLightning *zap; // $s1
			struct GenericFXObject *GFXO; // $v1
			struct _GenericLightningParams *GLP; // $s0
			struct Object *particle; // $v1

		/* begin block 1.1 */
			// Start line: 6600
			// Start offset: 0x8004C74C
			// Variables:
				int startSeg; // $a2
				int endSeg; // $a3

			/* begin block 1.1.1 */
				// Start line: 6626
				// Start offset: 0x8004C7B4
				// Variables:
					int tmp_blue; // $a0
					//struct CVECTOR *ptr; // $v1
			/* end block 1.1.1 */
			// End offset: 0x8004C7D8
			// End Line: 6635
		/* end block 1.1 */
		// End offset: 0x8004C7D8
		// End Line: 6636
	/* end block 1 */
	// End offset: 0x8004C7DC
	// End Line: 6639

	/* begin block 2 */
		// Start line: 15986
	/* end block 2 */
	// End Line: 15987

	/* begin block 3 */
		// Start line: 15992
	/* end block 3 */
	// End Line: 15993
					UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// struct _FXBlastringEffect * /*$ra*/ FX_StartGenericBlastring(struct _Instance *instance /*$s1*/, int num /*$a1*/, int segOverride /*$a2*/, int matrixSegOverride /*$a3*/)
struct _FXBlastringEffect * FX_StartGenericBlastring(struct _Instance *instance, int num, int segOverride, int matrixSegOverride)
{ // line 6642, offset 0x8004c7fc
	/* begin block 1 */
		// Start line: 6643
		// Start offset: 0x8004C7FC
		// Variables:
			struct _FXBlastringEffect *blast; // $v0
			struct GenericFXObject *GFXO; // $v1
			struct _GenericBlastringParams *GBP; // $s0
			struct Object *particle; // $v1
			struct _SVector position; // stack offset -64
			int segment; // $s2
			int matrix_segment; // $s3
			//MATRIX mat; // stack offset -56
			//MATRIX *swTransform; // $v0
	/* end block 1 */
	// End offset: 0x8004C9E8
	// End Line: 6706

	/* begin block 2 */
		// Start line: 16135
	/* end block 2 */
	// End Line: 16136

	/* begin block 3 */
		// Start line: 16146
	/* end block 3 */
	// End Line: 16147
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// struct _FXFlash * /*$ra*/ FX_StartGenericFlash(struct _Instance *instance /*$s2*/, int num /*$a1*/)
struct _FXFlash * FX_StartGenericFlash(struct _Instance *instance, int num)
{ // line 6708, offset 0x8004ca04
	/* begin block 1 */
		// Start line: 6709
		// Start offset: 0x8004CA04
		// Variables:
			struct GenericFXObject *GFXO; // $v1
			struct _GenericFlashParams *GFP; // $s1
			struct Object *particle; // $v1
			struct _FXFlash *flash; // $s0
	/* end block 1 */
	// End offset: 0x8004CACC
	// End Line: 6740

	/* begin block 2 */
		// Start line: 16279
	/* end block 2 */
	// End Line: 16280

	/* begin block 3 */
		// Start line: 16285
	/* end block 3 */
	// End Line: 16286
			UNIMPLEMENTED();
	return null;
}


// autogenerated function stub: 
// long /*$ra*/ FX_GetHealthColor(int currentHealth /*$a0*/)
long FX_GetHealthColor(int currentHealth)
{ // line 6742, offset 0x8004cae4
	/* begin block 1 */
		// Start line: 6763
		// Start offset: 0x8004CAE4
		// Variables:
			static long HealthColors[6]; // offset 0x0
			long color; // $v1
	/* end block 1 */
	// End offset: 0x8004CB28
	// End Line: 6780

	/* begin block 2 */
		// Start line: 16362
	/* end block 2 */
	// End Line: 16363

	/* begin block 3 */
		// Start line: 16382
	/* end block 3 */
	// End Line: 16383

	/* begin block 4 */
		// Start line: 16393
	/* end block 4 */
	// End Line: 16394
			UNIMPLEMENTED();
	return 0;
}

void FX_Start_Snow(int percent)//Matching - 99.62%
{
	snow_amount = (percent * 768) / 100;
}

void FX_Start_Rain(int percent) //Matching - 99.33%
{
	rain_amount = (percent * 1024) / 100;

	if (rain_amount == 0) 
	{
		current_rain_fade = 0;
	}
}


// autogenerated function stub: 
// void /*$ra*/ FX_StartLightbeam(struct _Instance *instance /*$s1*/, int startSeg /*$s2*/, int endSeg /*$s3*/, int color_num /*$a3*/)
void FX_StartLightbeam(struct _Instance *instance, int startSeg, int endSeg, int color_num)
{ // line 6796, offset 0x8004cba8
	/* begin block 1 */
		// Start line: 6797
		// Start offset: 0x8004CBA8
		// Variables:
			struct Object *particle; // $v0
			struct _FXLightBeam *beam; // $v0
			struct GenericFXObject *GFXO; // $v0
			long color; // $s0
	/* end block 1 */
	// End offset: 0x8004CC30
	// End Line: 6821

	/* begin block 2 */
		// Start line: 16470
	/* end block 2 */
	// End Line: 16471

	/* begin block 3 */
		// Start line: 16476
	/* end block 3 */
	// End Line: 16477
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_StartInstanceEffect(struct _Instance *instance /*$s2*/, struct ObjectEffect *effect /*$s0*/, int InitFlag /*$s3*/)
void FX_StartInstanceEffect(struct _Instance *instance, struct ObjectEffect *effect, int InitFlag)
{ // line 6835, offset 0x8004cc4c
	/* begin block 1 */
		// Start line: 6836
		// Start offset: 0x8004CC4C
		// Variables:
			long color; // stack offset -32

		/* begin block 1.1 */
			// Start line: 6869
			// Start offset: 0x8004CD20
			// Variables:
				long numberOfSegments; // $a2
		/* end block 1.1 */
		// End offset: 0x8004CD68
		// End Line: 6889

		/* begin block 1.2 */
			// Start line: 6954
			// Start offset: 0x8004CE2C
			// Variables:
				struct _FXParticle *currentParticle; // $a0
				struct evObjectDraftData *draft; // $s1
		/* end block 1.2 */
		// End offset: 0x8004CE64
		// End Line: 6963

		/* begin block 1.3 */
			// Start line: 6990
			// Start offset: 0x8004CF14
			// Variables:
				struct FXSplinter *splinterData; // $s0
				struct GenericTune *tune; // $a0
				short shardFlags; // $s1

			/* begin block 1.3.1 */
				// Start line: 6996
				// Start offset: 0x8004CF34
				// Variables:
					struct PhysObSplinter *splintDef; // $v0
			/* end block 1.3.1 */
			// End offset: 0x8004CF44
			// End Line: 6999
		/* end block 1.3 */
		// End offset: 0x8004CF70
		// End Line: 7010

		/* begin block 1.4 */
			// Start line: 7024
			// Start offset: 0x8004CFF0
			// Variables:
				int shock; // $a0
				int amt; // $a1
		/* end block 1.4 */
		// End offset: 0x8004D050
		// End Line: 7034
	/* end block 1 */
	// End offset: 0x8004D050
	// End Line: 7040

	/* begin block 2 */
		// Start line: 16561
	/* end block 2 */
	// End Line: 16562
				UNIMPLEMENTED();
}

void FX_EndInstanceEffects(struct _Instance* instance)// Matching - 99.52%
{
	struct _FXGeneralEffect* currentEffect;
	struct _FXGeneralEffect* nextEffect;

	currentEffect = FX_GeneralEffectTracker;

	while (currentEffect != NULL)
	{
		nextEffect = (struct _FXGeneralEffect*)currentEffect->next;

		if (currentEffect->instance == instance)
		{
			FX_DeleteGeneralEffect(currentEffect);
		}

		currentEffect = nextEffect;
	}
}


// autogenerated function stub: 
// void /*$ra*/ FX_EndInstanceParticleEffects(struct _Instance *instance /*$s2*/)
void FX_EndInstanceParticleEffects(struct _Instance *instance)
{ // line 7061, offset 0x8004d0c0
	/* begin block 1 */
		// Start line: 7062
		// Start offset: 0x8004D0C0
		// Variables:
			struct _FXGeneralEffect *currentEffect; // $a0
			struct _FXGeneralEffect *nextEffect; // $s0
	/* end block 1 */
	// End offset: 0x8004D118
	// End Line: 7075

	/* begin block 2 */
		// Start line: 17040
	/* end block 2 */
	// End Line: 17041
			UNIMPLEMENTED();
}

void FX_GetSpiralPoint(int radius, int deg, int* x, int* y)//Matching - 96.67%
{
	int prevx;
	int prevy;

	prevx = (((-radius * rcos(deg)) >> 12) / 240) << 9;

	if (prevx < 0)
	{
		prevx -= 2048;
	}
	else
	{
		prevx += 2048;
	}

	x[0] = (prevx >> 12) + 438;

	prevy = (radius * rsin(deg)) >> 12;

	if (prevy < 0)
	{
		prevy -= 2048;
	}
	else
	{
		prevy += 2048;
	}

	y[0] = (prevy >> 12) + 201;
}

void FX_GetLinePoint(int radius, int next_radius, int deg, int next_deg, int* pntx, int* pnty, int part)//Matching - 99.80%
{
	int x1;
	int y1;
	int x2;
	int y2;

	FX_GetSpiralPoint(radius, deg, &x1, &y1);
	FX_GetSpiralPoint(next_radius, next_deg, &x2, &y2);

	pntx[0] = x1 + (x2 - x1) * part / 4096;
	pnty[0] = y1 + (y2 - y1) * part / 4096;
}

void FX_CalcSpiral(int degchange)//Matching - 88.37%
{
	int radius;
	int deg;
	int n;
	int pntx;
	int pnty;
	int px;
	int py;
	int mx;
	int my;
	int mod;
	int next_deg;
	int next_radius;
	int minx;
	int maxx;
	int miny;
	int maxy;

	minx = 32767;
	maxx = -32767;
	miny = 32767;
	maxy = -32767;
	radius = 8192;
	next_radius = 8192;
	deg = 0;
	next_deg = 0;

	FX_GetSpiralPoint(8192, 0, &pntx, &pnty);

	Spiral_Array[64].vx = pntx;
	Spiral_Array[64].vy = pnty;

	for (n = 0; n < 64; n++)
	{
		if (Spiral_Number == 0)
		{
			mod = (n % Spiral_Mod);

			if (!mod)
			{
				deg = next_deg;

				radius = next_radius;

				next_radius += 1088 * Spiral_Mod;

				next_deg += degchange * Spiral_Mod;
			}

			mod = (mod << 12) / Spiral_Mod;

			FX_GetLinePoint(radius, next_radius, deg, next_deg, &pntx, &pnty, mod);

			FX_GetLinePoint(radius + 7168, next_radius + 7168, deg, next_deg, &px, &py, mod);

			FX_GetLinePoint(radius - 7168, next_radius - 7168, deg, next_deg, &mx, &my, mod);
		}
		else
		{
			radius += 1088;

			deg += degchange;

			FX_GetSpiralPoint(radius, deg, &pntx, &pnty);

			FX_GetSpiralPoint(radius + 7168, deg, &px, &py);

			FX_GetSpiralPoint(radius - 7168, deg, &mx, &my);
		}

		Spiral_Array[n].vx = pntx;
		Spiral_Array[n].vy = pnty;

		if (n == 63)
		{
			px = pntx;
			py = pnty;
			mx = pntx;
			my = pnty;
		}

		Spiral_OffsetP[n].vx = px;
		Spiral_OffsetP[n].vy = py;

		if (px < minx)
		{
			minx = px;
		}

		if (maxx < px)
		{
			maxx = px;
		}

		if (py < miny)
		{
			miny = py;
		}

		if (maxy < py)
		{
			maxy = py;
		}

		Spiral_OffsetM[n].vx = mx;
		Spiral_OffsetM[n].vy = my;
	}

	Spiral_Glow_Size = 320 * ((maxx - minx) / 2) / 512 + 2;
	Spiral_Glow_X = (minx + maxx) / 2;
	Spiral_Glow_Y = (miny + maxy) / 2;
}

void FX_Spiral(struct _PrimPool* primPool, unsigned long** ot)//Matching - 65.16%
{
	struct _POLY_2G4* poly; // $s2
	long prev; // $s3
	long offp; // $s7
	long offm; // $s4
	int n; // $s1
	DR_TPAGE* drtpage; // $v0
	int health; // $fp
	int health_mod; // $t1
	long no_color; // stack offset -76
	long color; // stack offset -80
	static short cnt; // offset 0x6c
	int current_cnt; // stack offset -72
	int max64; // $a0
	long SPIRAL_COLOR; // $t3
	long SPIRAL_COLOR2; // $t2
	long SPIRAL_COLOR3; // stack offset -68
	long SPIRAL_COLOR_END; // $s5
	long SPIRAL_NOCOLOR; // $a2
	int tmp; // $v1
	static short deg; // offset 0x6e
	struct _Vector f1; // stack offset -96

	if (gameTrackerX.gameData.asmData.MorphTime != 1000 && gameTrackerX.gameData.asmData.MorphType == 0)
	{
		if (Spiral_Number != 0)
		{
			FX_Health_Spiral(1, Spiral_Current, Spiral_Max);
		}
	}

	SPIRAL_COLOR = 0x3AFCFFD3;

	SPIRAL_COLOR2 = 0x3ADCE0BA;

	SPIRAL_COLOR3 = 0x3ABBC09D;

	SPIRAL_COLOR_END = 0x3A483017;

	SPIRAL_NOCOLOR = 0x3A002A15;

	if (Spiral_Number == 0)
	{
		if (Spiral_Current == Spiral_Max)
		{
			if (++cnt >= 0x51)
			{
				cnt = 0;
			}
		}
		else
		{
			SPIRAL_COLOR = 0x3A00FF00;
			SPIRAL_COLOR2 = 0x3A00E000;
			SPIRAL_COLOR3 = 0x3A00BF00;
			SPIRAL_COLOR_END = 0x3A004500;
		}

		SPIRAL_NOCOLOR = 0x3A00150B;
	}
	else
	{
		if (++cnt >= 0x51)
		{
			cnt = 0;
		}
	}

	max64 = Spiral_Max < 0 ? Spiral_Max + 63 : Spiral_Max;

	health = Spiral_Current / (max64 >> 6);

	prev = ((unsigned long*)&Spiral_Array[64])[0];

	offm = ((unsigned long*)&Spiral_Array[64])[0];

	offp = ((unsigned long*)&Spiral_Array[64])[0];

	poly = (struct _POLY_2G4*)primPool->nextPrim;

	health_mod = ((Spiral_Current - (health * max64)) << 12) / max64;

	if ((unsigned long*)(poly + 65) < primPool->lastPrim)
	{
		color = SPIRAL_NOCOLOR;
		no_color = SPIRAL_NOCOLOR;
		current_cnt = cnt;

		for (n = 0; n < 64; n++)
		{
			((unsigned long*)&poly->p1.r2)[0] = color;
			((unsigned long*)&poly->p2.r0)[0] = color;

			if (health < n)
			{
				color = no_color;
			}
			else
			{
				tmp = (((n + current_cnt) & 0xF) < 0 ? ((((n + current_cnt) & 0xF) + 3) >> 2) : (((n + current_cnt) & 0xF) >> 2));

				switch (tmp)
				{
				case 0:
				{
					color = SPIRAL_COLOR;
					break;
				}
				case 1:
				case 3:
				{
					color = SPIRAL_COLOR2;

					break;
				}
				case 2:
				{
					color = SPIRAL_COLOR3;
					break;
				}

				}

				if (n == health)
				{
					LoadAverageCol((unsigned char*)&color, (unsigned char*)&no_color, health_mod, 4096 - health_mod, (unsigned char*)&color);

					color = color & 0xFFFFFF;
					color |= (SPIRAL_COLOR & 0xFF000000);
				}
			}

			((unsigned long*)(&poly->p1.r0))[0] = SPIRAL_COLOR_END;//
			((unsigned long*)(&poly->p1.r1))[0] = SPIRAL_COLOR_END;//

			((unsigned long*)(&poly->p2.r2))[0] = SPIRAL_COLOR_END;//
			((unsigned long*)(&poly->p2.r3))[0] = SPIRAL_COLOR_END;//

			((unsigned long*)&poly->p2.x0)[0] = prev;
			((unsigned long*)&poly->p1.x2)[0] = prev;

			((unsigned long*)&poly->p1.x0)[0] = offp;
			((unsigned long*)&poly->p2.x2)[0] = offm;

			((unsigned long*)(&poly->p1.r3))[0] = color;
			((unsigned long*)(&poly->p2.r1))[0] = color;

			prev = ((unsigned long*)&Spiral_Array[n])[0];

			offp = ((unsigned long*)&Spiral_OffsetP[n])[0];

			offm = ((unsigned long*)&Spiral_OffsetM[n])[0];

			((unsigned long*)&poly->p2.x1)[0] = prev;

			((unsigned long*)&poly->p1.x3)[0] = prev;

			((unsigned long*)&poly->p1.x1)[0] = offp;

			((unsigned long*)&poly->p2.x3)[0] = offm;

			setlen(poly, 16);

#if defined(PSXPC_VERSION)
			addPrim(ot[1 * 2], poly);
#else
			addPrim(ot[1], poly);
#endif
			poly++;
		}

		setDrawTPage(poly, TRUE, TRUE, 32);

#if defined(PSXPC_VERSION)
		addPrim(ot[1 * 2], poly);
#else
		addPrim(ot[1], poly);
#endif

#if defined(PSXPC_VERSION)
		poly = (struct _POLY_2G4*)(((char*)poly) + 12);
#else
		poly = (struct _POLY_2G4*)(((char*)poly) + 8);
#endif

		primPool->nextPrim = (unsigned long*)poly;

		if (Spiral_Number != 0 || Spiral_Current == Spiral_Max)
		{
			f1.x = Spiral_Glow_X;
			f1.y = Spiral_Glow_Y;

			deg = (deg - 32) & 0xFFF;

			DRAW_CreateAGlowingCircle(&f1, 0x140, gameTrackerX.primPool, ot, 5, 0x8000, Spiral_Glow_Size, Spiral_Glow_Size, deg);
		}
	}
}

// autogenerated function stub: 
// void /*$ra*/ FX_Health_Spiral(int number /*$a0*/, int current_health /*$s0*/, int max_health /*$s1*/)
void FX_Health_Spiral(int number, int current_health, int max_health)
{ // line 7481, offset 0x8004d9e8
	/* begin block 1 */
		// Start line: 7482
		// Start offset: 0x8004D9E8
		// Variables:
			int degchange; // $v1
	/* end block 1 */
	// End offset: 0x8004DB20
	// End Line: 7529

	/* begin block 2 */
		// Start line: 18280
	/* end block 2 */
	// End Line: 18281
			UNIMPLEMENTED();
}

void FX_Spiral_Init() //Matching - 98.44%
{
	Spiral_Max = 100000;

	Spiral_Current = 100000;

	Spiral_Number = 1;

	Spiral_Degrees = 128;

	FX_CalcSpiral(128);
}

void FX_DrawModel(struct Object* object, int model_num, struct _SVector* rotation, struct _SVector* position, struct _SVector* offset, int transflag)
{
	struct _Model* model;
	struct _MFace* mface;
	struct _MVertex* vertexList;
	struct TextureMT3* texture;
	MATRIX matrix;
	int i;
	POLY_GT3* poly;
	unsigned long** drawot;
	struct _SVector output;
	long color;
	long clip;

	drawot = gameTrackerX.drawOT;
	
	poly = (POLY_GT3*)gameTrackerX.primPool->nextPrim;

	PushMatrix();

	MATH3D_SetUnityMatrix(&matrix);

	RotMatrixX(rotation->x, &matrix);
	RotMatrixY(rotation->y, &matrix);
	RotMatrixZ(rotation->z, &matrix);

	PIPE3D_AspectAdjustMatrix(&matrix);

	ApplyMatrixSV(&matrix, (SVECTOR*)offset, (SVECTOR*)&output);

	matrix.t[0] = position->x + output.x;
	matrix.t[1] = position->y + output.y;
	matrix.t[2] = position->z + output.z;

	SetRotMatrix(&matrix);

	SetTransMatrix(&matrix);

	color = 0x34808080;

	if (transflag != 0)
	{
		color = 0x36909090;
	}

	if (object != NULL)
	{
		model = object->modelList[model_num];

		i = model->numFaces - 1;
		
		mface = model->faceList;
		
		vertexList = model->vertexList;

		if (i != -1)
		{
			for (; i != -1; i--, mface++)
			{
				if ((char*)(poly + 1) >= (char*)gameTrackerX.primPool->lastPrim)
				{
					gameTrackerX.primPool->nextPrim = (unsigned long*)poly;
				}
				else
				{
					texture = (struct TextureMT3*)mface->color;

					gte_ldv3(&vertexList[mface->face.v0], &vertexList[mface->face.v1], &vertexList[mface->face.v2]);
					gte_rtpt();

					poly->u0 = texture->u0;
					poly->v0 = texture->v0;
					poly->clut = texture->clut;

					poly->u1 = texture->u1;
					poly->v1 = texture->v1;
					poly->tpage = texture->tpage;

					poly->u2 = texture->u2;
					poly->v2 = texture->v2;
					*(unsigned int*)&poly->pad2 = *(unsigned int*)&texture->pad1;

					gte_nclip();

					*(unsigned int*)&poly->r2 = color;
					*(unsigned int*)&poly->r1 = color;
					*(unsigned int*)&poly->r0 = color;

					gte_stopz(&clip);

					if (clip < 0)
					{
						gte_stsxy3(&poly->x0, &poly->x1, &poly->x2);
						setlen(poly, 9);

#if defined(PSXPC_VERSION)
						addPrim(drawot[1 * 2], poly);
#elif defined(PSX_VERSION)
						addPrim(drawot[1], poly);
#endif
						poly = poly + 1;
					}
				}
			}
		}
	}

	gameTrackerX.primPool->nextPrim = (unsigned long*)poly;

	PopMatrix();
}

// autogenerated function stub: 
// void /*$ra*/ fx_calc_points(struct _SVector *points /*$s1*/, int degrees /*$s0*/, int radius /*$s3*/, int radius2 /*$s4*/, int radius3 /*stack 16*/)
void fx_calc_points(struct _SVector *points, int degrees, int radius, int radius2, int radius3)
{ // line 7653, offset 0x8004ddec
	/* begin block 1 */
		// Start line: 7654
		// Start offset: 0x8004DDEC
		// Variables:
			int cosval; // $s0
			int sinval; // $v0
	/* end block 1 */
	// End offset: 0x8004DDEC
	// End Line: 7654

	/* begin block 2 */
		// Start line: 18657
	/* end block 2 */
	// End Line: 18658
			UNIMPLEMENTED();
}

long fx_get_startz(struct _SVector* position)
{
	MATRIX tmpmat;
	
	gte_ldv0(position);

	gte_rt();

	gte_stlvnl(&tmpmat.t[0]);

	SetTransMatrix(&tmpmat);

	return (tmpmat.m[2][0] < 0) ? (tmpmat.m[2][0] + 3) >> 2 : (tmpmat.m[2][0]) >> 2;
}


// autogenerated function stub: 
// void /*$ra*/ FX_DrawRing(MATRIX *wcTransform /*$s0*/, struct _SVector *position /*$s3*/, MATRIX *matrix /*$s4*/, int radius /*stack 12*/, int radius2 /*stack 16*/, int radius3 /*stack 20*/, int z1 /*stack 24*/, int z2 /*stack 28*/, int z3 /*stack 32*/, long color /*stack 36*/, int sortInWorld /*stack 40*/)
void FX_DrawRing(MATRIX *wcTransform, struct _SVector *position, MATRIX *matrix, int radius, int radius2, int radius3, int z1, int z2, int z3, long color, int sortInWorld)
{ // line 7705, offset 0x8004df54
	/* begin block 1 */
		// Start line: 7706
		// Start offset: 0x8004DF54
		// Variables:
			int n; // $s3
			struct _POLY_2G4T *poly; // $s1
			unsigned long **drawot; // stack offset -44
			struct _SVector points[3]; // stack offset -96
			long sxy[3]; // stack offset -72
			long degrees; // $s6
			long color_black; // $s4
			long sz0; // stack offset -56
			long sz1; // stack offset -52
			long sz2; // stack offset -48
			long startz; // $s7
	/* end block 1 */
	// End offset: 0x8004E1D0
	// End Line: 7782

	/* begin block 2 */
		// Start line: 18769
	/* end block 2 */
	// End Line: 18770

	/* begin block 3 */
		// Start line: 18779
	/* end block 3 */
	// End Line: 18780
			UNIMPLEMENTED();
}

void fx_setTex(DVECTOR* x, unsigned char* uv, int tx, int offset)
{
	x->vx -= tx;

	if (x->vy < 256)
	{
		uv[1] = (unsigned char)x->vy;
	}
	else
	{
		uv[1] = 255;
	}

	x->vy += offset;
}


// autogenerated function stub: 
// void /*$ra*/ FX_DrawRing2(MATRIX *wcTransform /*$s0*/, struct _SVector *position /*$s1*/, MATRIX *matrix /*$s3*/, int radius /*stack 12*/, int radius2 /*stack 16*/, int radius3 /*stack 20*/, int z1 /*stack 24*/, int z2 /*stack 28*/, int z3 /*stack 32*/, long offset /*stack 36*/, int sortInWorld /*stack 40*/)
void FX_DrawRing2(MATRIX *wcTransform, struct _SVector *position, MATRIX *matrix, int radius, int radius2, int radius3, int z1, int z2, int z3, long offset, int sortInWorld)
{ // line 7847, offset 0x8004e244
	/* begin block 1 */
		// Start line: 7848
		// Start offset: 0x8004E244
		// Variables:
			int n; // $s3
			//struct POLY_FT4 *poly; // $s2
			unsigned long **drawot; // stack offset -60
			struct _SVector points[3]; // stack offset -112
			long sxy[3]; // stack offset -88
			long degrees; // $fp
			long sz0; // stack offset -72
			long sz1; // stack offset -68
			long sz2; // stack offset -64
			long startz; // stack offset -56
			short tx; // $s0
			long dispYPos; // $s0
			int num_faces; // $s4
			int deg_change; // stack offset -52
	/* end block 1 */
	// End offset: 0x8004E5EC
	// End Line: 7939

	/* begin block 2 */
		// Start line: 19122
	/* end block 2 */
	// End Line: 19123
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_DrawFField(MATRIX *wcTransform /*$s2*/, struct _FXForceFieldEffect *field /*$s0*/)
void FX_DrawFField(MATRIX *wcTransform, struct _FXForceFieldEffect *field)
{ // line 7964, offset 0x8004e61c
	/* begin block 1 */
		// Start line: 7965
		// Start offset: 0x8004E61C
		// Variables:
			struct _Instance *instance; // $a0
			//MATRIX tmpmat; // stack offset -64
			struct _SVector position; // stack offset -32
			int size; // $s1
			short fade; // $v0
			long color; // stack offset -20
			long black; // stack offset -24
	/* end block 1 */
	// End offset: 0x8004E7F8
	// End Line: 8019

	/* begin block 2 */
		// Start line: 19458
	/* end block 2 */
	// End Line: 19459
			UNIMPLEMENTED();
}


// autogenerated function stub: 
// struct _FXForceFieldEffect * /*$ra*/ FX_StartFField(struct _Instance *instance /*$s2*/, int size /*$s3*/, _Position *offset /*$s1*/, int size_diff /*$s4*/, int size_change /*stack 16*/, int deg_change /*stack 20*/, long color /*stack 24*/)
struct _FXForceFieldEffect * FX_StartFField(struct _Instance *instance, int size, _Position *offset, int size_diff, int size_change, int deg_change, long color)
{ // line 8021, offset 0x8004e810
#if defined(PC_VERSION)
	struct _FXForceFieldEffect* result; // eax

	result = (struct _FXForceFieldEffect*)MEMPACK_Malloc(0x2Cu, 0xDu);
	if (result)
	{
		result->instance = instance;
		result->size = size;
		result->effectType = -122;
		result->type = 0;
		result->lifeTime = -1;
		result->continue_process = 0;
		*(_Position*)&result->offset.x = *offset;
		result->size_diff = size_diff;
		result->size_change = size_change;
		result->deg = 0;
		result->end_fade = 0;
		result->deg_change = deg_change;
		result->start_fade = 4096;
		result->color = color;
		result->next = ring;
		ring = (struct _FXGlowEffect*)result;
	}
	return result;
#else
	UNIMPLEMENTED();
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ FX_EndFField(struct _Instance *instance /*$a0*/)
void FX_EndFField(struct _Instance *instance)
{ // line 8048, offset 0x8004e8e4
#if defined(PC_VERSION)
	struct _FXForceFieldEffect* i; // eax
	__int16 height; // cx

	i = (struct _FXForceFieldEffect*)ring;
	if (ring)
	{
		do
		{
			if (i->instance == instance && i->effectType == 0x86)
			{
				height = i->start_fade;
				if (height)
				{
					i->start_fade = 0;
					i->end_fade = 4096 - height;
					if (4096 == height)
						i->end_fade = 1;
				}
				else
				{
					i->end_fade = 4096;
				}
			}
			i = (struct _FXForceFieldEffect*)i->next;
		} while (i);
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ FX_Draw_Glowing_Line(unsigned long **ot /*$t6*/, long otz /*$a0*/, struct DVECTOR *sxy0 /*$a2*/, struct DVECTOR *sxy1 /*$a3*/, struct DVECTOR *xy0 /*stack 16*/, struct DVECTOR *xy1 /*stack 20*/, long color /*stack 24*/, long color2 /*stack 28*/)
void FX_Draw_Glowing_Line(unsigned long **ot, long otz, DVECTOR *sxy0, DVECTOR *sxy1, DVECTOR *xy0, DVECTOR *xy1, long color, long color2)
{ // line 8071, offset 0x8004e964
#if defined(PC_VERSION)
	int v8; // esi
	struct _POLY_2G4T* nextPrim; // eax
	struct _POLY_2G4T* p_nextPrim; // ebx
	int v11; // ecx
	int v12; // ecx
	struct DVECTOR v13; // edx
	struct DVECTOR v14; // edx

	v8 = 0;
	if (otz > 0 && otz < 3072)
	{
		nextPrim = (struct _POLY_2G4T*)gameTrackerX.primPool->nextPrim;
		p_nextPrim = (struct _POLY_2G4T*)&gameTrackerX.primPool->nextPrim;
		if ((ulong*)&nextPrim[1] < gameTrackerX.primPool->lastPrim)
		{
			v11 = color;
			if ((color & 0x1000000) != 0)
			{
				v11 = color & 0xFFFFFF;
				v8 = 1;
			}
			v12 = v11 | 0x3A000000;
			*(DWORD*)&nextPrim->p1.r0 = 0x3A000000;
			*(DWORD*)&nextPrim->p1.r2 = v12;
			*(DWORD*)&nextPrim->p2.r0 = v12;
			*(DWORD*)&nextPrim->p1.r1 = 0;
			*(DWORD*)&nextPrim->p1.r3 = color2;
			*(DWORD*)&nextPrim->p2.r1 = color2;
			*(DWORD*)&nextPrim->p2.r2 = 0;
			*(DWORD*)&nextPrim->p2.r3 = 0;
			v13 = *sxy0;
			*(struct DVECTOR*)&nextPrim->p2.x0 = *sxy0;
			*(struct DVECTOR*)&nextPrim->p1.x2 = v13;
			nextPrim->p1.x0 = xy0->vx + sxy0->vx;
			nextPrim->p1.y0 = sxy0->vy - xy0->vy;
			nextPrim->p2.x2 = sxy0->vx - xy0->vx;
			nextPrim->p2.y2 = sxy0->vy + xy0->vy;
			v14 = *sxy1;
			*(struct DVECTOR*)&nextPrim->p2.x1 = *sxy1;
			*(struct DVECTOR*)&nextPrim->p1.x3 = v14;
			nextPrim->p1.x1 = xy1->vx + sxy1->vx;
			nextPrim->p1.y1 = sxy1->vy - xy1->vy;
			nextPrim->p2.x3 = sxy1->vx - xy1->vx;
			nextPrim->p2.y3 = sxy1->vy + xy1->vy;
			if (v8)
				nextPrim->drawTPage1 = 0xE1000640;
			else
				nextPrim->drawTPage1 = 0xE1000620;
			nextPrim->tag = (unsigned int)ot[otz] & 0xFFFFFF | 0x11000000;
			ot[otz] = (unsigned int*)(((unsigned int)nextPrim - primBase) & 0xFFFFFF);
			p_nextPrim->tag = (ulong)&nextPrim[1];
		}
	}
#else
	UNIMPLEMENTED();
#endif
}


// autogenerated function stub: 
// void /*$ra*/ FX_Lightning(MATRIX *wcTransform /*$s0*/, unsigned long **ot /*stack 4*/, MATRIX *mat /*stack 8*/, short deg /*$s1*/, struct _SVector *start /*stack 16*/, struct _SVector *end /*stack 20*/, int width /*stack 24*/, int small_width /*stack 28*/, int segs /*stack 32*/, int sine_size /*stack 36*/, int variation /*stack 40*/, long color /*stack 44*/, long glow_color /*stack 48*/)
void FX_Lightning(MATRIX *wcTransform, unsigned long **ot, MATRIX *mat, short deg, struct _SVector *start, struct _SVector *end, int width, int small_width, int segs, int sine_size, int variation, long color, long glow_color)
{ // line 8119, offset 0x8004eb00
	/* begin block 1 */
		// Start line: 8120
		// Start offset: 0x8004EB00
		// Variables:
			int sz0; // $s5
			int sz1; // stack offset -56
			long otz; // $s1
			int length; // $v1
			//struct DVECTOR sxy0; // stack offset -112
			//struct DVECTOR sxy1; // stack offset -104
			//struct DVECTOR xy0; // stack offset -96
			///truct DVECTOR xy1; // stack offset -88
			//struct DVECTOR small_xy0; // stack offset -80
			//struct DVECTOR small_xy1; // stack offset -72
			int n; // $s3
			int increment; // stack offset -52
			int rsin_nd2; // $s2

		/* begin block 1.1 */
			// Start line: 8154
			// Start offset: 0x8004EBB4
			// Variables:
				//SVECTORpoint; // stack offset -64

			/* begin block 1.1.1 */
				// Start line: 8162
				// Start offset: 0x8004EC04
				// Variables:
					int rsin_n4; // $s0
			/* end block 1.1.1 */
			// End offset: 0x8004ECF0
			// End Line: 8166

			/* begin block 1.1.2 */
				// Start line: 8170
				// Start offset: 0x8004ED00
				// Variables:
					int tmpdeg; // $s1
			/* end block 1.1.2 */
			// End offset: 0x8004EDC8
			// End Line: 8174

			/* begin block 1.1.3 */
				// Start line: 8188
				// Start offset: 0x8004EE30
				// Variables:
					int fx; // $s2
					int fy; // $s0
			/* end block 1.1.3 */
			// End offset: 0x8004EE78
			// End Line: 8196
		/* end block 1.1 */
		// End offset: 0x8004EF94
		// End Line: 8218
	/* end block 1 */
	// End offset: 0x8004EFC0
	// End Line: 8227

	/* begin block 2 */
		// Start line: 19793
	/* end block 2 */
	// End Line: 19794
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_LightHouse(MATRIX *wcTransform /*$s0*/, unsigned long **ot /*stack 4*/, struct _Instance *instance /*$a2*/, int startSeg /*$a3*/, int endSeg /*stack 16*/, int segs /*stack 20*/, long beam_color /*stack 24*/)
void FX_LightHouse(MATRIX *wcTransform, unsigned long **ot, struct _Instance *instance, int startSeg, int endSeg, int segs, long beam_color)
{ // line 8232, offset 0x8004eff0
	/* begin block 1 */
		// Start line: 8233
		// Start offset: 0x8004EFF0
		// Variables:
			int sz0; // $s4
			int sz1; // stack offset -72
			long otz; // $a1
			int width; // $s0
			struct _SVector start; // stack offset -136
			struct _SVector end; // stack offset -128
			//struct DVECTOR sxy0; // stack offset -120
			//struct DVECTOR sxy1; // stack offset -112
			//struct DVECTOR xy0; // stack offset -104
			//struct DVECTOR xy1; // stack offset -96
			int fade; // $a3
			int n; // $s2
			int increment; // $s6
			long black; // stack offset -64
			long color; // stack offset -68
			long color1; // stack offset -56
			long color2; // stack offset -60
			int fx; // stack offset -52
			int fy; // stack offset -48
			int length; // $s7
			int segcnt; // $s3
			int end_width; // stack offset -44
			int flag; // $fp
			//MATRIX *swTransform; // $v1

		/* begin block 1.1 */
			// Start line: 8292
			// Start offset: 0x8004F138
			// Variables:
				//SVECTORpoint; // stack offset -88

			/* begin block 1.1.1 */
				// Start line: 8303
				// Start offset: 0x8004F1B0
				// Variables:
					int newlength; // $v1
					int newfx; // $s1
					int newfy; // $s0
			/* end block 1.1.1 */
			// End offset: 0x8004F1F4
			// End Line: 8317
		/* end block 1.1 */
		// End offset: 0x8004F214
		// End Line: 8324

		/* begin block 1.2 */
			// Start line: 8335
			// Start offset: 0x8004F248
			// Variables:
				//SVECTORpoint; // stack offset -80

			/* begin block 1.2.1 */
				// Start line: 8357
				// Start offset: 0x8004F330
				// Variables:
					int x; // $v0
			/* end block 1.2.1 */
			// End offset: 0x8004F3BC
			// End Line: 8369
		/* end block 1.2 */
		// End offset: 0x8004F40C
		// End Line: 8378
	/* end block 1 */
	// End offset: 0x8004F43C
	// End Line: 8388

	/* begin block 2 */
		// Start line: 20062
	/* end block 2 */
	// End Line: 20063
					UNIMPLEMENTED();
}


// autogenerated function stub: 
// void /*$ra*/ FX_StartPassthruFX(struct _Instance *instance /*$s0*/, struct _SVector *normal /*$a1*/, struct _SVector *point /*$a2*/)
void FX_StartPassthruFX(struct _Instance *instance, struct _SVector *normal, struct _SVector *point)
{ // line 8391, offset 0x8004f46c
#if defined(PC_VERSION)
	int color; // [esp+Ch] [ebp-4h] BYREF

	instance->halvePlane.a = normal->x;
	instance->halvePlane.b = normal->y;
	instance->halvePlane.c = normal->z;
	instance->halvePlane.d = -((point->x * normal->x + normal->z * point->z + normal->y * point->y) >> 12);
	color = 0x20FF40;
	FX_DoInstancePowerRing(instance, 8400, &color, 0, 2);
	FX_DoInstancePowerRing(instance, 8400, &color, 0, 1);
#else
	UNIMPLEMENTED();
#endif
}

void FX_EndPassthruFX(struct _Instance* instance)
{
#if defined(PSX_VERSION)
	FX_EndInstanceEffects(instance);
#elif defined(PC_VERSION)
	struct _FXGlowEffect* v1; // eax
	struct _FXGlowEffect* v2; // esi
	struct _FXGlowEffect* next; // edi
	DWORD* p_next; // ecx

	v1 = ring;
	v2 = ring;
	if (ring)
	{
		do
		{
			next = (struct _FXGlowEffect*)v2->next;
			if (v2->instance == instance && v2)
			{
				p_next = 0;
				if (v1)
				{
					while (v1 != v2)
					{
						p_next = &v1->next;
						v1 = (struct _FXGlowEffect*)v1->next;
						if (!v1)
							goto LABEL_11;
					}
					if (p_next)
						*p_next = next;
					else
						ring = (struct _FXGlowEffect*)v2->next;
				}
			LABEL_11:
				if (!v2->effectType)
					MEMPACK_Free((char*)v2->colorArray);
				MEMPACK_Free((char*)v2);
				v1 = ring;
			}
			v2 = next;
		} while (next);
	}
#else
	UNIMPLEMENTED();
#endif
}