#include "CORE.H"
#include "STREAM.H"
#include "OBTABLE.H"
#include "GAMELOOP.H"
#include "SAVEINFO.H"
#include "LIGHT3D.H"
#include "SCRIPT.H"
#include "OBTABLE.H"
#include "SPLINE.H"
#include "EVENT.H"
#include "STATE.H"
#include "LIST.H"
#include "G2/ANIMG2.H"
#include "G2/INSTNCG2.H"
#include "G2/ANMG2ILF.H"
#include "MEMPACK.H"
#include "FX.H"

#ifdef PC_VERSION
#pragma warning(disable: 4101)
#endif

// autogenerated function stub: 
// void /*$ra*/ INSTANCE_ClearTfaces(struct _Instance *instance /*$a0*/)
void INSTANCE_ClearTfaces(struct _Instance* instance)
{ // line 52, offset 0x80031ed8
	instance->oldWaterFace = 0;
	instance->waterFace = 0;
	instance->waterFaceTerrain = 0;
	instance->tface = 0;
	instance->oldTFace = 0;
	instance->tfaceLevel = 0;
	instance->cachedTFace = -1;
	instance->cachedBSPTree = 0;
	instance->cachedTFaceLevel = 0;
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_Deactivate(struct _Instance *instance /*$s0*/)
void INSTANCE_Deactivate(struct _Instance* instance)
{ // line 66, offset 0x80031f04
	/* begin block 1 */
		// Start line: 67
		// Start offset: 0x80031F04
		// Variables:
	struct Object* object; // $a2
/* end block 1 */
// End offset: 0x80031FB0
// End Line: 91

/* begin block 2 */
	// Start line: 138
/* end block 2 */
// End Line: 139

}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_Reactivate(struct _Instance *instance /*$a0*/)
void INSTANCE_Reactivate(struct _Instance* instance)
{ // line 94, offset 0x80031fc0
	/* begin block 1 */
		// Start line: 95
		// Start offset: 0x80031FC0
		// Variables:
	struct Object* object; // $a2
/* end block 1 */
// End offset: 0x80032048
// End Line: 117

/* begin block 2 */
	// Start line: 201
/* end block 2 */
// End Line: 202

}

void INSTANCE_ForceActive(struct _Instance* instance)
{
#if defined(PSX_VERSION)

	if ((instance->flags2 & 0x1))
	{
		INSTANCE_Reactivate(instance);
	}

#elif defined(PC_VERSION)
	int flags2; // eax
	int flags; // edx
	struct Object* object; // esi
	int v4; // eax

	flags2 = instance->flags2;
	if ((flags2 & 1) != 0)
	{
		flags = instance->flags;
		object = instance->object;
		flags2 = flags2 & ~1;
		instance->flags2 = flags2;
		if ((flags & 0x40000) != 0)
		{
			v4 = flags2 | 0x20000000;
			instance->flags = flags & ~0x40000u;
		}
		else
		{
			v4 = flags2 & ~0x20000000u;
		}
		instance->flags2 = v4;
		if (object->animList)
		{
			if ((object->oflags2 & 0x40000000) == 0)
				G2Anim_Restore(&instance->anim);
		}
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_DeactivatedProcess(struct _Instance *instance /*$a0*/, struct GameTracker *gameTracker /*$a1*/)
void INSTANCE_DeactivatedProcess(struct _Instance* instance, struct GameTracker* gameTracker)
{ // line 130, offset 0x8003208c
	/* begin block 1 */
		// Start line: 282
	/* end block 1 */
	// End Line: 283

	/* begin block 2 */
		// Start line: 284
	/* end block 2 */
	// End Line: 285

}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_DeactivateFarInstances(struct GameTracker *gameTracker /*$s3*/)
void INSTANCE_DeactivateFarInstances(struct GameTracker* gameTracker)
{ // line 136, offset 0x80032094
#if 0//defined(PC_VERSION)
	struct _InstanceList* instanceList; // edi
	struct _Instance* first; // esi
	char* ScratchAddr; // eax
	int v4; // ecx
	int numInstances; // eax
	int v6; // edi
	int v7; // eax
	unsigned int(__stdcall * queryFunc)(); // eax
	int v9; // eax
	unsigned int(__stdcall * v10)(); // eax
	int v11; // eax
	__int16 v12; // cx
	int v13; // eax
	int v14; // eax
	struct Object* v15; // edx
	int flags2; // eax
	int v17; // eax
	int v18; // ecx
	struct Object* v19; // eax
	unsigned int v20; // edx
	unsigned int v21; // ecx
	int v22; // ecx
	struct Object* v23; // edi
	int v24; // eax
	int v25; // eax
	int v26; // ecx
	struct Object* object; // eax
	int v28; // edx
	int v29; // ecx
	unsigned int v30; // ecx
	struct Object* v31; // edx
	int v32; // eax
	int v33; // eax
	int v34; // ecx
	struct Object* v35; // eax
	unsigned int v36; // edx
	unsigned int v37; // ecx
	int flags; // ecx
	unsigned int v39; // edx
	int v40; // [esp+10h] [ebp-8h]
	struct _SVector* v41; // [esp+14h] [ebp-4h]

	instanceList = gameTracker->instanceList;
	first = instanceList->first;
	ScratchAddr = getScratchAddr(0);
	v4 = dword_C550A0;
	v41 = (struct _SVector*)ScratchAddr;
	numInstances = instanceList->numInstances;
	v6 = (instanceList->numInstances >> 3) + 1;
	v40 = v6;
	if (dword_C550A0 >= numInstances)
		v4 = 0;
	dword_C550A0 = v6 + v4;
	if (v6 + v4 >= numInstances)
		dword_C550A0 = 0;
	if (v4)
	{
		v7 = v4;
		do
		{
			first = first->next;
			--v7;
		} while (v7);
	}
	while (first)
	{
		if (!v6)
			return;
		if ((first->flags2 & 0x80)
			|| (first->object->oflags & 0x10000) != 0
			|| ((queryFunc = first->queryFunc) != 0
				? (v9 = ((int(__cdecl*)(struct _Instance*, int))queryFunc)(first, 35))
				: (v9 = 0),
				v9
				|| ((v10 = first->queryFunc) != 0
					? (v11 = ((int(__cdecl*)(struct _Instance*, int))v10)(first, 47))
					: (v11 = 0),
					v11 || first->LinkParent || !first->matrix)))
		{
			if ((first->flags2 & 1) != 0)
			{
				flags = first->flags;
				object = first->object;
				first->flags2 &= ~1u;
				if ((flags & 0x40000) != 0)
				{
					v39 = flags & ~0x40000u;
					v30 = first->flags2 | 0x20000000;
					first->flags = v39;
				}
				else
				{
					v30 = first->flags2 & ~0x20000000u;
				}
				goto LABEL_76;
			}
		}
		else
		{
			v41->x = first->position.x - theCamera.core.position.x;
			v41->y = first->position.y - theCamera.core.position.y;
			v12 = first->position.z - theCamera.core.position.z;
			v41->z = v12;
			v14 = v41->x * v41->x + v12 * v12 + v41->y * v41->y;
			if ((first->flags & 0x200) != 0)
			{
				v15 = first->object;
				if (v14 <= v15->vvRemoveDist * v15->vvRemoveDist)
				{
					if ((first->flags2 & 1) == 0)
						goto LABEL_79;
					v18 = first->flags;
					v19 = first->object;
					first->flags2 &= ~1u;
					if ((v18 & 0x40000) != 0)
					{
						v20 = v18 & ~0x40000u;
						v21 = first->flags2 | 0x20000000;
						first->flags = v20;
					}
					else
					{
						v21 = first->flags2 & ~0x20000000u;
					}
					first->flags2 = v21;
					if (!v19->animList || (v19->oflags2 & 0x40000000) != 0)
						goto LABEL_79;
					goto LABEL_78;
				}
				flags2 = first->flags2;
				if ((flags2 & 1) != 0 || (gameTrackerX.streamFlags & 0x2000000) != 0)
					goto LABEL_79;
				flags2 = flags2 | 1;
				first->flags2 = flags2;
				if ((flags2 & 0x20000000) != 0)
				{
					first->flags |= 0x40000u;
				}
				else
				{
					v17 = first->flags2 | 0x20000000;
					first->flags &= ~0x40000u;
					first->flags2 = v17;
				}
				if (!v15->animList || (v15->oflags2 & 0x40000000) != 0)
					goto LABEL_64;
				goto LABEL_31;
			}
			v22 = first->flags2;
			if ((v22 & 0x80000) != 0)
			{
				if (v14 <= gameTracker->defRemoveDist * gameTracker->defRemoveDist)
				{
					if ((v22 & 1) == 0)
						goto LABEL_79;
					v34 = first->flags;
					v35 = first->object;
					first->flags2 &= ~1u;
					if ((v34 & 0x40000) != 0)
					{
						v36 = v34 & 0xFFFBFFFF;
						v37 = first->flags2 | 0x20000000;
						first->flags = v36;
					}
					else
					{
						v37 = first->flags2 & 0xDFFFFFFF;
					}
					first->flags2 = v37;
					if (!v35->animList || (v35->oflags2 & 0x40000000) != 0)
						goto LABEL_79;
					goto LABEL_78;
				}
				if ((v22 & 1) != 0)
					goto LABEL_79;
				v31 = first->object;
				if ((gameTrackerX.streamFlags & 0x2000000) != 0)
					goto LABEL_79;
				v32 = first->flags2;
				v32 = v22 | 1;
				first->flags2 = v32;
				if ((v32 & 0x20000000) != 0)
				{
					first->flags |= 0x40000u;
				}
				else
				{
					v33 = first->flags2 | 0x20000000;
					first->flags &= ~0x40000u;
					first->flags2 = v33;
				}
				if (v31->animList && (v31->oflags2 & 0x40000000) == 0)
					G2Anim_Free(&first->anim);
			LABEL_64:
				first->oldWaterFace = 0;
				first->waterFace = 0;
				first->waterFaceTerrain = 0;
				first->tface = 0;
				first->oldTFace = 0;
				first->tfaceLevel = 0;
				first->cachedTFace = -1;
				first->cachedBSPTree = 0;
				first->cachedTFaceLevel = 0;
				goto LABEL_79;
			}
			v23 = first->object;
			if (v14 > v23->removeDist * v23->removeDist)
			{
				if ((v22 & 1) != 0 || (gameTrackerX.streamFlags & 0x2000000) != 0)
					goto LABEL_79;
				v24 = first->flags2;
				v24 = v22 | 1;
				first->flags2 = v24;
				if ((v24 & 0x20000000) != 0)
				{
					first->flags |= 0x40000u;
				}
				else
				{
					v25 = first->flags2 | 0x20000000;
					first->flags &= ~0x40000u;
					first->flags2 = v25;
				}
				if (!v23->animList || (v23->oflags2 & 0x40000000) != 0)
					goto LABEL_64;
			LABEL_31:
				G2Anim_Free(&first->anim);
				first->oldWaterFace = 0;
				first->waterFace = 0;
				first->waterFaceTerrain = 0;
				first->tface = 0;
				first->oldTFace = 0;
				first->tfaceLevel = 0;
				first->cachedTFace = -1;
				first->cachedBSPTree = 0;
				first->cachedTFaceLevel = 0;
				goto LABEL_79;
			}
			if ((v22 & 1) != 0)
			{
				v26 = first->flags;
				object = first->object;
				first->flags2 &= ~1u;
				if ((v26 & 0x40000) != 0)
				{
					v28 = v26;
					v29 = first->flags2;
					first->flags = v28 & ~0x40000u;
					v30 = v29 | 0x20000000;
				LABEL_76:
					first->flags2 = v30;
					if (!object->animList || (object->oflags2 & 0x40000000) != 0)
						goto LABEL_79;
				}
				else
				{
					first->flags2 &= ~0x20000000u;
					if (!object->animList || (object->oflags2 & 0x40000000) != 0)
						goto LABEL_79;
				}
			LABEL_78:
				G2Anim_Restore(&first->anim);
			}
		}
	LABEL_79:
		first = first->next;
		v6 = --v40;
	}
#endif
}

void INSTANCE_InitInstanceList(struct _InstanceList* list, struct _InstancePool* pool)
{
#if defined(PSX_VERSION)

	long i;

	pool->numFreeInstances = 60;
	
	for (i = 1; i < 59; i++)
	{
		pool->instance[i].next = &pool->instance[i + 1];
		pool->instance[i].prev = &pool->instance[i - 1];
	}

	pool->instance[0].next = &pool->instance[1];
	pool->instance[0].prev = NULL;

	pool->instance[59].prev = &pool->instance[58];
	pool->instance[59].next = NULL;
	
	pool->first_free = &pool->instance[0];

	list->pool = pool;
	list->numInstances = 0;
	list->first = NULL;

	for (i = 0; i < 32; i++)
	{
		list->group[i].next = NULL;
		list->group[i].prev = NULL;
	}

	pool->nextInstanceID = 1;

#elif defined(PC_VERSION)
	struct _Instance** p_next; // eax
	struct NodeType* group; // eax
	int i; // edx MAPDST

	i = 60;
	pool->numFreeInstances = 62;
	p_next = &pool->instance[1].next;
	do
	{
		*p_next = (struct _Instance*)(p_next + 152);
		p_next[1] = (struct _Instance*)(p_next - 156);
		p_next += 154;
		--i;
	} while (i);
	pool->instance[0].next = &pool->instance[1];
	pool->first_free = pool->instance;
	pool->instance[0].prev = 0;
	pool->instance[61].next = 0;
	pool->instance[61].prev = &pool->instance[60];
	list->pool = pool;
	list->numInstances = 0;
	list->first = 0;
	group = list->group;
	i = 32;
	do
	{
		group->next = 0;
		group->prev = 0;
		++group;
		--i;
	} while (i);
	pool->nextInstanceID = 1;
#endif
}

struct _Instance* INSTANCE_NewInstance(struct _InstanceList* list)
{
#if defined(PSX_VERSION)
	struct _Instance* temp;
	struct _Instance* instance;

	if (list->pool->numFreeInstances != 0)
	{
		list->pool->numFreeInstances--;
		instance = list->pool->first_free;
		list->pool->first_free = instance->next;

		temp = list->first;
		list->first = instance;
		instance->next = temp;

		if (instance->next != NULL)
		{
			list->first->prev = instance;
		}
	
		instance->prev = NULL;
		instance->instanceID = list->pool->nextInstanceID++;

		list->numInstances++;

		return instance;
	}
	
	return NULL;

#elif defined(PC_VERSION)
	struct _InstancePool* pool; // eax
	int numFreeInstances; // edx
	struct _InstancePool* v3; // edx
	struct _Instance* result; // eax
	struct _Instance* first; // edx

	pool = list->pool;
	numFreeInstances = pool->numFreeInstances;
	if (numFreeInstances)
	{
		pool->numFreeInstances = numFreeInstances - 1;
		v3 = list->pool;
		result = v3->first_free;
		v3->first_free = result->next;
		first = list->first;
		list->first = result;
		result->next = first;
		if (first)
			first->prev = result;
		result->prev = 0;
		result->instanceID = list->pool->nextInstanceID++;
		++list->numInstances;
	}
	else
	{
		GXFilePrint("ran out of instances need more than %d - contact a programmer\n", 62);
		return 0;
	}
	return result;
#endif
}


// autogenerated function stub: 
// long /*$ra*/ INSTANCE_InstanceGroupNumber(struct _Instance *instance /*$a0*/)
long INSTANCE_InstanceGroupNumber(struct _Instance* instance)
{ // line 391, offset 0x8003243c
#if defined(PC_VERSION)
	int v1; // ebx
	struct Object* object; // ecx
	int oflags; // eax

	v1 = 0;
	object = instance->object;
	oflags = object->oflags;
	if ((object->oflags & 0x80u) != 0 && (instance->flags & 0x8000u) == 0)
		v1 = 1;
	if ((oflags & 0x20) != 0 && (instance->flags & 0x2000) == 0)
		v1 |= 2u;
	if ((oflags & 0x40) != 0 && (instance->flags & 0x4000) == 0)
		v1 |= 4u;
	if ((oflags & 0x10) != 0 && (instance->flags & 0x1000) == 0)
		v1 |= 0x10u;
	if ((oflags & 1) != 0)
		return v1 | 8;
	if (strcmp(object->name, "raziel__"))
	{
		if ((v1 & 3) != 0)
		{
			printf("Object %s\n", object->name);
			FONT_Print("Object %s\n", instance->object->name);
		}
		return v1 & ~3u;
	}
	return v1;
#else
	return NULL;
#endif
}

void INSTANCE_InsertInstanceGroup(struct _InstanceList* list, struct _Instance* instance)
{
#if defined(PSX_VERSION)
	LIST_InsertFunc(&list->group[INSTANCE_InstanceGroupNumber(instance)], &instance->node);
#elif defined(PC_VERSION)
	int v2; // eax

	v2 = INSTANCE_InstanceGroupNumber(instance);
	LIST_InsertFunc(&list->group[v2], &instance->node);
#endif
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_ReallyRemoveInstance(struct _InstanceList *list /*$s1*/, struct _Instance *instance /*$s0*/, long reset /*$s2*/)
void INSTANCE_ReallyRemoveInstance(struct _InstanceList* list, struct _Instance* instance, long reset)
{ // line 499, offset 0x800325a0
#if defined(PC_VERSION)
	struct Intro* intro; // eax
	struct _Instance* prev; // ecx
	struct _Instance* next; // ecx
	struct _InstancePool* pool; // ecx
	struct _InstancePool* v7; // eax
	struct _Instance* first_free; // ecx
	int flags; // eax
	struct Object* object; // eax
	struct Object* v11; // eax
	struct _Instance* LinkChild; // edi
	void(* messageFunc)(); // ebx
	struct _Instance* LinkSibling; // ebp
	int flags2; // eax
	int v16; // ecx
	struct Object* v17; // edx
	int v18; // eax
	int i; // ecx
	struct LightInstance* lightInstances; // eax

	EVENT_RemoveInstanceFromInstanceList(instance);
	if ((instance->flags & 0x800000) != 0)
		SAVE_DoInstanceDeadDead(instance);
	if ((instance->flags & 2) == 0)
	{
		intro = instance->intro;
		if (intro)
		{
			intro->flags &= ~reset;
			instance->intro->instance = 0;
		}
	}
	prev = instance->prev;
	if (prev)
		prev->next = instance->next;
	else
		list->first = instance->next;
	next = instance->next;
	if (next)
		next->prev = instance->prev;
	instance->instanceID = 0;
	pool = list->pool;
	--list->numInstances;
	++pool->numFreeInstances;
	v7 = list->pool;
	first_free = v7->first_free;
	v7->first_free = instance;
	instance->next = first_free;
	instance->prev = 0;
	if (first_free)
		first_free->prev = instance;
	LIST_DeleteFunc(&instance->node);
	FX_EndInstanceEffects(instance);
	flags = instance->flags;
	if ((flags & 0x10000) != 0)
	{
		instance->flags = flags | 0x20000;
		OBTABLE_InstanceInit(instance);
	}
	object = instance->object;
	if (object->animList && (object->oflags2 & 0x40000000) == 0)
		G2Anim_Free(&instance->anim);
	v11 = instance->object;
	if ((v11->oflags2 & 4) != 0)
		SOUND_EndInstanceSounds(v11->soundData, instance->soundInstanceTbl);
	if (instance->LinkParent)
		INSTANCE_UnlinkFromParent(instance);
	LinkChild = instance->LinkChild;
	if (LinkChild)
	{
		do
		{
			messageFunc = instance->messageFunc;
			LinkSibling = LinkChild->LinkSibling;
			if (messageFunc)
			{
				flags2 = instance->flags2;
				if ((flags2 & 1) != 0)
				{
					v16 = instance->flags;
					v17 = instance->object;
					flags2 = flags2 & ~1;
					instance->flags2 = flags2;
					if ((v16 & 0x40000) != 0)
					{
						v18 = flags2 | 0x20000000;
						instance->flags = v16 & 0xFFFBFFFF;
					}
					else
					{
						v18 = flags2 & ~0x20000000u;
					}
					instance->flags2 = v18;
					if (v17->animList)
					{
						if ((v17->oflags2 & 0x40000000) == 0)
							G2Anim_Restore(&instance->anim);
					}
				}
				((void(__cdecl*)(struct _Instance*, int, struct _Instance*))messageFunc)(instance, 1048595, LinkChild);
			}
			LinkChild->LinkParent = 0;
			LinkChild->LinkSibling = 0;
			LinkChild = LinkSibling;
		} while (LinkSibling);
		instance->LinkChild = 0;
	}
	if (instance->hModelList)
		MEMPACK_Free((char*)instance->hModelList);
	if (instance->perVertexColor)
	{
		MEMPACK_Free((char*)instance->perVertexColor);
		instance->perVertexColor = 0;
	}
	i = 0;
	lightInstances = gameTrackerX.gameData.asmData.lightInstances;
	while (lightInstances->lightInstance != instance)
	{
		++lightInstances;
		++i;
		if ((int)lightInstances >= (int)&gameTrackerX.menu)
			return;
	}
	gameTrackerX.gameData.asmData.lightInstances[i].lightInstance = 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_CleanUpInstanceList(struct _InstanceList *list /*$s1*/, long reset /*$s2*/)
void INSTANCE_CleanUpInstanceList(struct _InstanceList* list, long reset)
{ // line 615, offset 0x800327e4
	/* begin block 1 */
		// Start line: 616
		// Start offset: 0x800327E4
		// Variables:
	struct _Instance* instance; // $a1
	struct _Instance* next; // $s0
/* end block 1 */
// End offset: 0x80032888
// End Line: 650

/* begin block 2 */
	// Start line: 1354
/* end block 2 */
// End Line: 1355

}

long INSTANCE_Introduced(struct Intro* intro, short streamUnitID)
{ 
#if defined(PSX_VERSION)
	struct _Instance* instance;
	struct _Instance* next;
	long ret;

	instance = gameTrackerX.instanceList->first;
	ret = 0;

	if (instance != NULL)
	{
		do
		{
			next = instance->next;

			if (intro->UniqueID == instance->introUniqueID)
			{
				intro->flags |= 0x8;
				ret = 1;
				break;
			}

		} while (next != NULL);
	}
	
	if (ret == 0)
	{
		if (SAVE_HasSavedIntro(intro, streamUnitID) || SAVE_IsIntroDeadDead(intro))
		{
			intro->flags |= 0x8;
			ret = 1;
		}
	}

	return ret;

#elif defined(PC_VERSION)
	struct _Instance* first; // eax
	int v3; // edi
	struct _Instance* next; // ecx
	int flags; // eax
	int v6; // eax

	first = gameTrackerX.instanceList->first;
	v3 = 0;
	if (first)
	{
		while (1)
		{
			next = first->next;
			if (intro->UniqueID == first->introUniqueID)
				break;
			first = first->next;
			if (!next)
				goto LABEL_6;
		}
		flags = intro->flags;
		v3 = 1;
		flags = flags | 8;
		intro->flags = flags;
	}
LABEL_6:
	if (!v3 && (SAVE_HasSavedIntro(intro) || SAVE_IsIntroDeadDead(intro)))
	{
		v6 = intro->flags;
		v3 = 1;
		v6 = v6 | 8;
		intro->flags = v6;
	}
	return v3;
#endif
}

struct INICommand* INSTANCE_GetIntroCommand(struct INICommand* command, int cmd)
{
#if defined(PSX_VERSION)

	if (command != NULL)
	{
		while (command->command != 0)
		{
			if (command->command != cmd)
			{
				command += command->numParameters + 1;
			}
			else
			{
				return command;
			}
		}
	}

	return 0;

#elif defined(PC_VERSION)
	struct INICommand* result; // eax
	__int16 v3; // cx

	result = command;
	if (!command)
		return 0;
	v3 = command->command;
	if (!command->command)
		return 0;
	while (v3 != cmd)
	{
		result += result->numParameters + 1;
		v3 = result->command;
		if (!result->command)
			return 0;
	}
	return result;
#endif
}


// autogenerated function stub: 
// struct INICommand * /*$ra*/ INSTANCE_FindIntroCommand(struct _Instance *instance /*$a0*/, int cmd /*$a1*/)
struct INICommand* INSTANCE_FindIntroCommand(struct _Instance* instance, int cmd)
{ // line 780, offset 0x800329a8
#if defined(PC_VERSION)
	struct INICommand* result; // eax
	__int16 command; // cx

	result = (struct INICommand*)instance->introData;
	if (!result)
		return 0;
	command = result->command;
	if (!result->command)
		return 0;
	while (command != cmd)
	{
		result += result->numParameters + 1;
		command = result->command;
		if (!result->command)
			return 0;
	}
	return result;
#else
	return NULL;
#endif
}

void INSTANCE_ProcessIntro(struct _Instance* instance)
{
#if defined(PSX_VERSION)
	struct INICommand* command;
	
	if (instance->introData != NULL)
	{
		command = (struct INICommand*)instance->introData;

		if (!(instance->flags & 0x2))
		{
			while (command->command != 0)
			{
				if (command->command == 0x12)
				{

					instance->currentModel = command->parameter[0];
					command += command->numParameters + 1;
				}
			}
		}
	}

#elif defined(PC_VERSION)
	struct INICommand* introData; // esi
	__int16 i; // ax
	__int16 v3; // ax
	struct Object* object; // ecx
	__int16 numModels; // cx
	int numParameters; // ecx

	introData = (struct INICommand*)instance->introData;
	if (introData)
	{
		if ((instance->flags & 2) == 0)
		{
			for (i = introData->command; i; introData += numParameters + 1)
			{
				if (i == 18)
				{
					v3 = introData->parameter[0];
					object = instance->object;
					instance->currentModel = v3;
					numModels = object->numModels;
					if (numModels <= v3)
						GXFilePrint(
							"Error: Specify model num %d on a instance(%s%d) with %d models.\n",
							v3,
							instance->introName,
							instance->introNum,
							numModels);
				}
				numParameters = introData->numParameters;
				i = introData[numParameters + 1].command;
			}
		}
	}
#endif
}

void INSTANCE_InitEffects(struct _Instance* instance, struct Object* object)
{
#if defined(PSX_VERSION)
	int i;
	
	if (!(object->oflags2 & 0x100))
	{
		if (object->numberOfEffects != 0 && object->numberOfEffects > 0)
		{
			for (i = 0; i < object->numberOfEffects; i++)
			{
				FX_StartInstanceEffect(instance, &object->effectList[i], 1);
			}
		}
	}

#elif 0//defined(PC_VERSION)
	__int16 numberOfEffects; // ax
	int v3; // esi

	if ((object->oflags2 & 0x100) == 0)
	{
		numberOfEffects = object->numberOfEffects;
		if (numberOfEffects)
		{
			v3 = 0;
			if (numberOfEffects > 0)
			{
				do
					FX_StartInstanceEffect(instance, (unsigned __int8*)&object->effectList[v3++], 1);
				while (v3 < object->numberOfEffects);
			}
		}
	}
#endif
}

struct _Instance* INSTANCE_IntroduceInstance(struct Intro* intro, short streamUnitID)
{
	struct Object* object;
	struct _Instance* instance;
	struct _Instance* attachInst;
	struct _ObjectTracker* objectTracker;
	struct INICommand* index;
	long attachedUniqueID;
	struct SavedIntroSpline* savedIntroSpline;
	struct MultiSpline* spline;
	struct SavedIntroSmall* savedIntroSmall;

	attachInst = NULL;
	index = NULL;

	if (!(INSTANCE_Introduced(intro, streamUnitID)))
	{
		attachedUniqueID = 0;
		index = INSTANCE_GetIntroCommand(index, 26);

		if (index != NULL)
		{
			attachedUniqueID = index->parameter[0];
		}

		objectTracker = STREAM_GetObjectTracker(intro->name);

		if (objectTracker != NULL)
		{
			object = objectTracker->object;

			if (objectTracker->objectStatus == 2)
			{
				savedIntroSmall = NULL;

				if (attachedUniqueID != 0)
				{
					attachInst = INSTANCE_Find(attachedUniqueID);
					if (attachInst == NULL)
					{
						return 0;
					}
				}


				if ((object->oflags2 & 0x10000000))
				{
					OBTABLE_InitAnimPointers(objectTracker);

					if ((object->oflags2 & 0x10000000))
					{
						return 0;
					}
				}

				instance = INSTANCE_NewInstance(gameTrackerX.instanceList);

				if (instance != NULL)
				{
					intro->flags |= 0x8;

					objectTracker->numInUse++;

					INSTANCE_DefaultInit(instance, object, 0);

					strcpy(instance->introName, intro->name);

					instance->introUniqueID = intro->UniqueID;
					instance->introNum = intro->intronum;
					instance->birthStreamUnitID = streamUnitID;
					instance->currentStreamUnitID = streamUnitID;

					intro->instance = instance;

					instance->intro = intro;
					instance->introData = intro->multiSpline;
					instance->position = intro->position;

					if (gameTrackerX.gameData.asmData.MorphType == 1)
					{
						if (intro->spectralPosition.x != 0 && intro->spectralPosition.y != 0 && intro->spectralPosition.z != 0)
						{
							instance->position.x = intro->position.x + intro->spectralPosition.x;
							instance->position.y = intro->position.y + intro->spectralPosition.y;
							instance->position.z = intro->position.z + intro->spectralPosition.z;
						}
					}

					instance->initialPos = instance->position;
					instance->oldPos = intro->position;

					LIGHT_GetAmbient((struct _ColorType*)&instance->light_color, instance);

					instance->rotation = intro->rotation;
					if ((instance->object->oflags & 0x100))
					{
						INSTANCE_BuildStaticShadow(instance);
					}

					instance->scale.x = 4096;
					instance->scale.y = 4096;
					instance->scale.z = 4096;

					if ((intro->flags & 0x2000))
					{
						instance->flags |= 0x400;
					}

					if ((intro->flags & 0x10000))
					{
						instance->flags2 |= 0x20000;
					}

					if (attachInst != NULL)
					{
						INSTANCE_ForceActive(attachInst);
						attachInst->flags2 |= 0x80;
					}

					if ((object->oflags2 & 0x80))
					{
						instance->flags |= 0x800;
					}

					if ((intro->flags & 0x800) && object->id == -1)
					{
						SCRIPTCountFramesInSpline(instance);
						SCRIPT_InstanceSplineSet(instance, -1, NULL, NULL, NULL);
						instance->flags = (instance->flags ^ 0x1000000) | 0x100000;
					}

					instance->lightGroup = (unsigned char)intro->rotation.pad;
					instance->spectralLightGroup = intro->specturalLightGroup;

					INSTANCE_InsertInstanceGroup(gameTrackerX.instanceList, instance);
					OBTABLE_GetInstanceCollideFunc(instance);
					OBTABLE_GetInstanceProcessFunc(instance);
					OBTABLE_GetInstanceQueryFunc(instance);
					OBTABLE_GetInstanceMessageFunc(instance);
					OBTABLE_GetInstanceAdditionalCollideFunc(instance);

					if (!(intro->flags & 0x10))
					{
						OBTABLE_InstanceInit(instance);
					}

					MORPH_SetupInstanceFlags(instance);

					if ((intro->flags & 0x80))
					{
						instance->flags |= 0x800;
						instance->flags2 |= 0x20000000;

						if ((object->oflags2 & 0x80000))
						{
							instance->flags2 |= 0x10000000;
						}
					}

					if (SCRIPT_GetMultiSpline(instance, NULL, NULL) == NULL)
					{
						instance->flags = (instance->flags & 0xFDFFFFFF) | 0x100000;
					}
					else
					{
						spline = SCRIPT_GetMultiSpline(instance, NULL, NULL);
						savedIntroSpline = SAVE_GetIntroSpline(instance);

						if (savedIntroSpline != NULL)
						{
							SCRIPT_InstanceSplineSet(instance, savedIntroSpline->splineKeyFrame, NULL, NULL, NULL);

							instance->oldPos = instance->position;
							instance->splineFlags = savedIntroSpline->splineFlags;
							instance->clipBeg = savedIntroSpline->splineClipBeg;
							instance->clipEnd = savedIntroSpline->splineClipEnd;

							if ((instance->splineFlags & 0x80))
							{
								instance->flags |= 0x1000000;
							}

							if ((instance->splineFlags & 0x100))
							{
								instance->flags |= 0x2000000;
							}

							if ((savedIntroSpline->splineFlags & 0x10))
							{
								if (spline->positional != NULL)
								{
									spline->positional->flags |= 0x1;
								}

								if (spline->rotational != NULL)
								{
									spline->rotational->flags |= 0x1;
								}

								if (spline->scaling != NULL)
								{
									spline->scaling->flags |= 0x1;
								}

								if (spline->color != NULL)
								{
									spline->color->flags |= 0x1;
								}
							}
							else if ((instance->splineFlags & 0x20))
							{
								if (spline->positional != NULL)
								{
									spline->positional->flags |= 0x2;
								}

								if (spline->rotational != NULL)
								{
									spline->rotational->flags |= 0x2;
								}

								if (spline->scaling != NULL)
								{
									spline->scaling->flags |= 0x2;
								}

								if (spline->color != NULL)
								{
									spline->color->flags |= 0x2;
								}
							}
							else if ((instance->splineFlags & 0x40))
							{
								if (spline->positional != NULL)
								{
									spline->positional->flags |= 0x4;
								}

								if (spline->rotational != NULL)
								{
									spline->rotational->flags |= 0x4;
								}

								if (spline->scaling != NULL)
								{
									spline->scaling->flags |= 0x4;
								}

								if (spline->color != NULL)
								{
									spline->color->flags |= 0x4;
								}
							}
						}
					}

					EVENT_AddInstanceToInstanceList(instance);

					INSTANCE_ProcessIntro(instance);
					INSTANCE_InitEffects(instance, object);

					savedIntroSmall = SAVE_GetSavedSmallIntro(instance);

					if (savedIntroSmall != NULL)
					{
						INSTANCE_Post(instance, 0x100007, SetControlSaveDataData((savedIntroSmall->shiftedSaveSize << 2) - 4, savedIntroSmall + 1));
					}

					return instance;
				}
			}
		}
	}
	return NULL;
}

void INSTANCE_AdditionalCollideFunctions(struct _InstanceList* instanceList)
{
#if defined(PSX_VERSION)

	struct _Instance* instance; // $s0

	instance = instanceList->first;

	if (instance != NULL)
	{
		//loc_800334E4
		//v1 = gameTrackerX.gameMode


	}
	//loc_800335D8
#if 0
		loc_800334E4 :
	lh      $v1, -0x40C6($gp)
		li      $v0, 6
		bne     $v1, $v0, loc_80033510
		lui     $v1, 2
		lw      $v0, 0x1C($s0)
		nop
		lw      $v0, 0($v0)
		nop
		and $v0, $v1
		beqz    $v0, loc_800335C8
		nop

		loc_80033510 :
	lw      $v0, -0x40F4($gp)//gameTrackerX.streamFlags
		lui     $v1, 0x10
		and $v0, $v1
		beqz    $v0, loc_80033540
		lui     $v1, 4
		lw      $v0, 0x1C($s0)
		nop
		lw      $v0, 0($v0)
		nop
		and $v0, $v1
		beqz    $v0, loc_800335C8
		nop

		loc_80033540 :
	lw      $v0, 0x110($s0)
		nop
		beqz    $v0, loc_800335C8
		lui     $v0, 0x2400
		lw      $a0, 0x18($s0)
		nop
		and $v0, $a0, $v0
		bnez    $v0, loc_800335C8
		nop
		lw      $v0, 0x1C($s0)
		nop
		beqz    $v0, loc_800335AC
		lui     $v1, 0x200
		lw      $v0, 0x2C($v0)
		nop
		and $v0, $v1
		beqz    $v0, loc_800335AC
		lui     $v0, 0x800
		and $v0, $a0, $v0
		beqz    $v0, loc_800335A0
		nop
		lw      $v0, -0x3FF0($gp)
		j       loc_800335B0
		nop

		loc_800335A0 :
	lw      $v0, -0x3FEC($gp)
		j       loc_800335B0
		nop

		loc_800335AC :
	lw      $v0, -0x3FF4($gp)

		loc_800335B0 :
		nop
		sw      $v0, -0x3FF8($gp)
		lw      $v0, 0x110($s0)
		addiu   $a1, $gp, -0x4238
		jalr    $v0
		move    $a0, $s0

		loc_800335C8 :
	lw      $s0, 8($s0)
		nop
		bnez    $s0, loc_800334E4
		nop

		loc_800335D8 :
	lw      $v0, -0x3FF4($gp)
		lw      $ra, 0x10 + var_s4($sp)
		lw      $s0, 0x10 + var_s0($sp)
		sw      $v0, -0x3FF8($gp)
		jr      $ra
		addiu   $sp, 0x18
#endif


#elif defined(PC_VERSION)
	struct _Instance* i; // esi
	int flags2; // ecx
	struct Object* object; // eax

	for (i = instanceList->first; i; i = i->next)
	{
		if ((gameTrackerX.gameMode != 6 || (i->object->oflags & 0x20000) != 0)
			&& ((gameTrackerX.streamFlags & 0x100000) == 0 || (i->object->oflags & 0x40000) != 0))
		{
			if (i->additionalCollideFunc)
			{
				flags2 = i->flags2;
				if ((flags2 & 0x24000000) == 0)
				{
					object = i->object;
					if (object && (object->oflags2 & 0x2000000) != 0)
					{
						if ((flags2 & 0x8000000) != 0)
							gameTrackerX.timeMult = gameTrackerX.spectralTimeMult;
						else
							gameTrackerX.timeMult = gameTrackerX.materialTimeMult;
					}
					else
					{
						gameTrackerX.timeMult = gameTrackerX.globalTimeMult;
					}
					((void(__cdecl*)(struct _Instance*, struct GameTracker*))i->additionalCollideFunc)(i, &gameTrackerX);
				}
			}
		}
	}
	gameTrackerX.timeMult = gameTrackerX.globalTimeMult;
#endif
}


// autogenerated function stub: 
// long /*$ra*/ INSTANCE_GetSplineFrameNumber(struct _Instance *instance /*$s0*/, struct MultiSpline *spline /*$a1*/)
long INSTANCE_GetSplineFrameNumber(struct _Instance* instance, struct MultiSpline* spline)
{ // line 1173, offset 0x80033318
#if defined(PC_VERSION)
	int* PosSplineDef; // eax

	PosSplineDef = SCRIPT_GetPosSplineDef(instance, spline, 0, 0);
	return SCRIPT_GetSplineFrameNumber(instance, PosSplineDef);
#else
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_ProcessFunctions(struct _InstanceList *instanceList /*$a0*/)
void INSTANCE_ProcessFunctions(struct _InstanceList* instanceList)
{ // line 1186, offset 0x80033350
	/* begin block 1 */
		// Start line: 1187
		// Start offset: 0x80033350

		/* begin block 1.1 */
			// Start line: 1193
			// Start offset: 0x80033390
			// Variables:
	struct _Instance* instance; // $s0

/* begin block 1.1.1 */
	// Start line: 1215
	// Start offset: 0x8003344C
	// Variables:
	int hidden; // $s2
	int burning; // $s1
/* end block 1.1.1 */
// End offset: 0x80033500
// End Line: 1238

/* begin block 1.1.2 */
	// Start line: 1264
	// Start offset: 0x800335D0
	// Variables:
	long prevFrame; // $s2
	struct MultiSpline* multi; // $s4

/* begin block 1.1.2.1 */
	// Start line: 1271
	// Start offset: 0x80033600
	// Variables:
	long endOfSpline; // $s6
	short direction; // $s7

/* begin block 1.1.2.1.1 */
	// Start line: 1310
	// Start offset: 0x800336C0
	// Variables:
	long frame; // $s3
	long maxFrames; // $s1
/* end block 1.1.2.1.1 */
// End offset: 0x80033900
// End Line: 1389

/* begin block 1.1.2.1.2 */
	// Start line: 1400
	// Start offset: 0x80033934
/* end block 1.1.2.1.2 */
// End offset: 0x80033958
// End Line: 1405
/* end block 1.1.2.1 */
// End offset: 0x80033AD0
// End Line: 1465
/* end block 1.1.2 */
// End offset: 0x80033AD0
// End Line: 1467

/* begin block 1.1.3 */
	// Start line: 1490
	// Start offset: 0x80033B14
	// Variables:
	int killTest; // $s1
/* end block 1.1.3 */
// End offset: 0x80033B50
// End Line: 1497
/* end block 1.1 */
// End offset: 0x80033B84
// End Line: 1509
/* end block 1 */
// End offset: 0x80033BCC
// End Line: 1523

/* begin block 2 */
	// Start line: 2550
/* end block 2 */
// End Line: 2551

}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ INSTANCE_BirthObject(struct _Instance *parent /*$s2*/, struct Object *object /*$s4*/, int modelNum /*$s1*/)
struct _Instance* INSTANCE_BirthObject(struct _Instance* parent, struct Object* object, int modelNum)
{ // line 1526, offset 0x80033bfc
#if 0//defined(PC_VERSION)
	struct _InstanceList* instanceList; // eax
	struct _InstancePool* pool; // ecx
	int numFreeInstances; // edx
	struct _InstancePool* v6; // ecx
	struct _Instance* first_free; // ebp
	struct _Instance* first; // ecx
	int v9; // esi
	struct _InstanceList* v10; // esi
	int v11; // eax
	__int16 numberOfEffects; // ax
	int v13; // esi

	if (!object)
		return 0;
	instanceList = gameTrackerX.instanceList;
	pool = gameTrackerX.instanceList->pool;
	numFreeInstances = pool->numFreeInstances;
	if (numFreeInstances)
	{
		pool->numFreeInstances = numFreeInstances - 1;
		v6 = instanceList->pool;
		first_free = v6->first_free;
		v6->first_free = first_free->next;
		first = instanceList->first;
		instanceList->first = first_free;
		first_free->next = first;
		if (first)
			first->prev = first_free;
		first_free->prev = 0;
		first_free->instanceID = instanceList->pool->nextInstanceID++;
		++instanceList->numInstances;
	}
	else
	{
		GXFilePrint("ran out of instances need more than %d - contact a programmer\n", 62);
		first_free = 0;
	}
	if (!first_free)
		return 0;
	INSTANCE_DefaultInit(first_free, object, modelNum);
	first_free->position = parent->position;
	first_free->initialPos = parent->position;
	first_free->oldPos = parent->position;
	first_free->rotation = parent->rotation;
	first_free->scale = parent->scale;
	first_free->lightGroup = parent->lightGroup;
	first_free->spectralLightGroup = parent->spectralLightGroup;
	first_free->currentStreamUnitID = parent->currentStreamUnitID;
	first_free->birthStreamUnitID = parent->birthStreamUnitID;
	first_free->introUniqueID = GlobalSave->CurrentBirthID++;
	strcpy(first_free->introName, object->name);
	v9 = 0;
	if (strlen(first_free->introName))
	{
		while (first_free->introName[v9] != 95)
		{
			if (++v9 >= strlen(first_free->introName))
				goto LABEL_13;
		}
		first_free->introName[v9] = 0;
	}
LABEL_13:
	first_free->parent = parent;
	first_free->intro = parent->intro;
	first_free->introData = parent->introData;
	LIGHT_GetAmbient((struct _ColorType*)&first_free->light_color, first_free);
	if (!SCRIPT_GetMultiSpline(first_free, 0, 0))
		first_free->flags |= 0x100000u;
	if ((parent->flags2 & 0x8000000) != 0)
		first_free->flags2 |= 0x8000000u;
	v10 = gameTrackerX.instanceList;
	v11 = INSTANCE_InstanceGroupNumber(first_free);
	LIST_InsertFunc(&v10->group[v11], &first_free->node);
	OBTABLE_GetInstanceCollideFunc(first_free);
	OBTABLE_GetInstanceProcessFunc(first_free);
	OBTABLE_GetInstanceQueryFunc(first_free);
	OBTABLE_GetInstanceMessageFunc(first_free);
	OBTABLE_GetInstanceAdditionalCollideFunc(first_free);
	first_free->flags |= 2u;
	OBTABLE_InstanceInit(first_free);
	EVENT_AddInstanceToInstanceList(first_free);
	if ((object->oflags2 & 0x100) == 0)
	{
		numberOfEffects = object->numberOfEffects;
		if (numberOfEffects)
		{
			v13 = 0;
			if (numberOfEffects > 0)
			{
				do
					FX_StartInstanceEffect(first_free, (unsigned __int8*)&object->effectList[v13++], 1);
				while (v13 < object->numberOfEffects);
			}
		}
	}
	return first_free;

#else
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_BuildStaticShadow(struct _Instance *instance /*$a0*/)
void INSTANCE_BuildStaticShadow(struct _Instance* instance)
{ // line 1615, offset 0x80033e6c
	/* begin block 1 */
		// Start line: 3230
	/* end block 1 */
	// End Line: 3231

	/* begin block 2 */
		// Start line: 3761
	/* end block 2 */
	// End Line: 3762

}

void INSTANCE_DefaultInit(struct _Instance* instance, struct Object* object, int modelNum)
{
	int i;
	int j;
	int numHPrims;
	int numModels;
	struct _HPrim* hprim;
	struct _Model** pModel;
	struct _HModel* hmodel;
	struct _Model* model;
	struct _Segment* seg;
	struct _HInfo* hinfo;
	int k;
	struct _HFace* hface;
	struct _HSphere* hsphere;
	struct _HBox* hbox;

	memset(&instance->flags, 0, sizeof(_Instance) - 0x14);
	
	instance->object = object;
	instance->currentModel = modelNum;
	instance->cachedTFace = -1;
	instance->cachedTFaceLevel = NULL;
	instance->data = object->data;

	if (object->animList != NULL && (object->oflags2 & 0x40000000))
	{
		G2Anim_Init(&instance->anim, object->modelList[modelNum]);
		G2Anim_SwitchToKeylist(&instance->anim, G2Instance_GetKeylist(instance, 0), 0);
		G2Anim_SetCallback(&instance->anim, INSTANCE_DefaultAnimCallback, instance);
	}
	
	if ((object->oflags & 0x4000000))
	{
		instance->flags2 |= 0x4;
	}
	
	if ((object->oflags & 0x2000000))
	{
		instance->flags2 |= 0x40;
	}
	
	if ((object->oflags & 0x8))
	{
		instance->flags2 |= 0x8000000;
	}
	
	if (!(object->oflags & 0x1000000))
	{
		instance->flags |= 0x2000000;
	}
	
	if ((object->oflags & 0x20000000))
	{
		instance->flags2 |= 0x20;
	}
	
	numModels = object->numModels;
	pModel = object->modelList;

	numHPrims = 0;

	for (i = numModels; i != 0; i--, pModel++)
	{
		for (j = pModel[0]->numSegments; j != 0; j--, seg++)
		{
			seg = pModel[0]->segmentList;

			if (pModel[0]->numSegments != 0)
			{
				hinfo = seg->hInfo;

				if (hinfo != NULL)
				{
					numHPrims += hinfo->numHFaces;
					numHPrims += hinfo->numHSpheres;
					numHPrims += hinfo->numHBoxes;
				}
			}
		}
	}

	if (numHPrims != 0)
	{
		hmodel = (struct _HModel*)MEMPACK_Malloc((instance->object->numModels + numHPrims) * 8, 0xE);

		instance->hModelList = hmodel;
		pModel = object->modelList;
		hprim = hmodel->hPrimList;
	
		if (i != 0)
		{
			for(i = numModels; i != 0; i--, pModel++, hmodel++)
			{
				model = pModel[0];
				hmodel->numHPrims = 0;
				hmodel->hPrimList = hprim;
				seg = model->segmentList;

				if (model->numSegments > 0)
				{
					for (j = 0; j < model->numSegments; j++, seg++)
					{
						hinfo = seg->hInfo;
						if (hinfo != NULL)
						{
							hface = hinfo->hfaceList;
							hsphere = hinfo->hsphereList;
							hbox = hinfo->hboxList;

							hmodel->numHPrims = hmodel->numHPrims + hinfo->numHFaces + hinfo->numHSpheres + hinfo->numHBoxes;
							for (k = hinfo->numHFaces; k != 0; k--, hprim++, hface++)
							{
								hprim->hpFlags = 0x4D;
								hprim->withFlags = 0x24;
								hprim->type = 2;
								hprim->segment = j;
								hprim->data.hface = hface;
							}

							for (k = hinfo->numHSpheres; k != 0; k--, hprim++, hsphere++)
							{
								hprim->hpFlags = 0x2F;
								hprim->withFlags = 0x76;
								hprim->type = 1;
								hprim->segment = j;
								hprim->data.hsphere = hsphere;
							}

							for (k = hinfo->numHBoxes; k != 0; k--, hprim++, hbox++)
							{
								hprim->hpFlags = 0x1D;
								hprim->withFlags = 0x24;
								hprim->type = 5;
								hprim->segment = j;
								hprim->data.hbox = hbox;
							}
						}
					}
				}
			}
		}
	}
	else
	{
		instance->hModelList = NULL;
		instance->flags2 |= 0x40000;
	}

	if (instance->maxCheckDistance == 0)
	{
		instance->maxCheckDistance = 12000;
	}
}



// autogenerated function stub: 
// void /*$ra*/ INSTANCE_PlainDeath(struct _Instance *instance /*$s5*/)
void INSTANCE_PlainDeath(struct _Instance* instance)
{ // line 1793, offset 0x80034230
#if defined(PC_VERSION)
	struct _Instance* v1; // edi
	int flags; // ecx
	struct Object* object; // ecx
	int flags2; // ebx
	struct _Instance* v5; // eax
	int v6; // ecx
	int v7; // eax

	v1 = instance;
	flags = instance->flags;
	flags &= ~4u;
	instance->flags = flags;
	object = instance->object;
	if ((object->oflags2 & 4) != 0)
	{
		flags2 = instance->flags2;
		flags2 |= 0x10u;
		instance->flags2 = flags2;
		SOUND_ProcessInstanceSounds(
			object->soundData,
			instance->soundInstanceTbl,
			&instance->position,
			object->oflags2 & 0x2000000,
			flags2 & 0x8000000,
			0,
			0,
			&instance->flags2);
		SOUND_ProcessInstanceSounds(
			instance->object->soundData,
			instance->soundInstanceTbl,
			&instance->position,
			instance->object->oflags2 & 0x2000000,
			instance->flags2 & 0x8000000,
			0,
			0,
			&instance->flags2);
	}
	v5 = (struct _Instance*)*((DWORD*)gameTrackerX.instanceList + 1);
	if (v5)
	{
		do
		{
			if (v5->introUniqueID == v1->attachedID)
				break;
			v5 = v5->next;
		} while (v5);
		if (v5)
		{
			v6 = v5->flags2;
			v6 = v6 & ~0x80;
			v5->flags2 = v6;
		}
	}
	SAVE_MarkDeadDead(v1);
	v7 = v1->flags;
	v7 = v7 | 0x20;
	v1->flags = v7;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_KillInstance(struct _Instance *instance /*$a0*/)
void INSTANCE_KillInstance(struct _Instance* instance)
{ // line 1838, offset 0x80034360
	if ((instance->flags & 0x20) == 0)
		INSTANCE_PlainDeath(instance);
}


// autogenerated function stub: 
// unsigned long /*$ra*/ INSTANCE_Query(struct _Instance *Inst /*$a0*/, int Query /*$a1*/)
unsigned long INSTANCE_Query(struct _Instance* Inst, int Query)
{ // line 1857, offset 0x80034394
#if defined(PC_VERSION)
	unsigned int result; // eax

	result = (unsigned int)Inst->queryFunc;
	if (result)
		return ((int(__cdecl*)(struct _Instance*, int))result)(Inst, Query);
	return result;
#else
	return 0;
#endif
}

void INSTANCE_Post(struct _Instance* Inst, int Message, int Data)
{
#if defined(PSX_VERSION)

	void (*Func)(_Instance*, unsigned long, unsigned long); // $s1

	Func = Inst->messageFunc;

	if (Func != NULL)
	{
		INSTANCE_ForceActive(Inst);

		Func(Inst, Message, Data);
	}

#elif defined(PC_VERSION)
	void(* messageFunc)(); // edi
	int flags2; // eax
	int flags; // ecx
	struct Object* object; // edx
	int v7; // eax

	messageFunc = Inst->messageFunc;
	if (messageFunc)
	{
		flags2 = Inst->flags2;
		if ((flags2 & 1) != 0)
		{
			flags = Inst->flags;
			object = Inst->object;
			flags2 = flags2 & ~1;
			Inst->flags2 = flags2;
			if ((flags & 0x40000) != 0)
			{
				v7 = flags2 | 0x20000000;
				Inst->flags = flags & ~0x40000u;
			}
			else
			{
				v7 = flags2 & ~0x20000000u;
			}
			Inst->flags2 = v7;
			if (object->animList)
			{
				if ((object->oflags2 & 0x40000000) == 0)
					G2Anim_Restore(&Inst->anim);
			}
		}
		((void(__cdecl*)(struct _Instance*, int, int))messageFunc)(Inst, Message, Data);
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_Broadcast(struct _Instance *sender /*$s2*/, long whatAmIMask /*$s3*/, int Message /*$s4*/, int Data /*$s5*/)
void INSTANCE_Broadcast(struct _Instance* sender, long whatAmIMask, int Message, int Data)
{ // line 1892, offset 0x80034434
#if defined(PC_VERSION)
	int MorphType; // ebp
	struct _Instance* i; // esi
	int queryFunc; // eax
	struct Object* object; // eax
	int v8; // eax
	void(* messageFunc)(); // edi
	int flags; // ecx
	struct Object* v11; // eax
	unsigned int v12; // edx
	unsigned int v13; // ecx

	MorphType = gameTrackerX.gameData.asmData.MorphType;
	for (i = (struct _Instance*)*((DWORD*)gameTrackerX.instanceList + 1); i; i = i->next)
	{
		if (i != sender)
		{
			queryFunc = (int)i->queryFunc;
			if (queryFunc)
				queryFunc = ((int(__cdecl*)(struct _Instance*, int))queryFunc)(i, 1);
			if ((queryFunc & whatAmIMask) != 0)
			{
				object = i->object;
				if (object)
				{
					if ((object->oflags2 & 0x2000000) == 0
						|| ((i->flags2 & 0x8000000) == 0 ? (v8 = MorphType == 0) : (v8 = MorphType), v8))
					{
						messageFunc = i->messageFunc;
						if (messageFunc)
						{
							if ((i->flags2 & 1) != 0)
							{
								flags = i->flags;
								v11 = i->object;
								i->flags2 &= ~1u;
								if ((flags & 0x40000) != 0)
								{
									v12 = flags & ~0x40000u;
									v13 = i->flags2 | 0x20000000;
									i->flags = v12;
								}
								else
								{
									v13 = i->flags2 & ~0x20000000u;
								}
								i->flags2 = v13;
								if (v11->animList)
								{
									if ((v11->oflags2 & 0x40000000) == 0)
										G2Anim_Restore(&i->anim);
								}
							}
							((void(__cdecl*)(struct _Instance*, int, int))messageFunc)(i, Message, Data);
						}
					}
				}
			}
		}
	}
#endif
}


// autogenerated function stub: 
// int /*$ra*/ INSTANCE_InPlane(struct _Instance *instance /*$a0*/, int plane /*$a1*/)
int INSTANCE_InPlane(struct _Instance* instance, int plane)
{ // line 1911, offset 0x800344e0
#if defined(PC_VERSION)
	struct Object* object; // eax
	int result; // eax

	object = instance->object;
	result = 0;
	if (object)
	{
		if ((object->oflags2 & 0x2000000) == 0)
			return 1;
		if ((instance->flags2 & 0x8000000) != 0 ? plane : plane == 0)
			return 1;
	}
	return result;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// long /*$ra*/ INSTANCE_FindWithID(long uniqueID /*$a0*/)
long INSTANCE_FindWithID(long uniqueID)
{ // line 1938, offset 0x8003453c
#if defined(PC_VERSION)
	struct _Instance* v1; // ecx
	int result; // eax
	struct _Instance* v3; // edx

	v1 = (struct _Instance*)*((DWORD*)gameTrackerX.instanceList + 1);
	result = 0;
	if (v1)
	{
		while (1)
		{
			v3 = v1->next;
			if (v1->introUniqueID == uniqueID)
				break;
			v1 = v1->next;
			if (!v3)
				return result;
		}
		return 1;
	}
	return result;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ INSTANCE_FindWithName(long areaID /*$s3*/, char *instanceName /*$s4*/, struct _Instance *startInstance /*$a2*/)
struct _Instance* INSTANCE_FindWithName(long areaID, char* instanceName, struct _Instance* startInstance)
{ // line 1995, offset 0x8003457c
#if defined(PC_VERSION)
	struct _Instance* next; // esi
	struct _Instance* v4; // edi
	struct _Instance* v6; // edi
	struct _Instance* v7; // [esp+10h] [ebp-4h]

	next = (struct _Instance*)*((DWORD*)gameTrackerX.instanceList + 1);
	v7 = 0;
	if (startInstance)
		next = startInstance->next;
	if (areaID)
	{
		if (next)
		{
			while (1)
			{
				v4 = next->next;
				if (next->birthStreamUnitID == areaID && !_strcmpi(next->introName, instanceName))
					break;
				next = v4;
				if (!v4)
					return 0;
			}
			return next;
		}
	}
	else if (next)
	{
		while (1)
		{
			v6 = next->next;
			if (!_strcmpi(next->introName, instanceName))
				break;
			next = v6;
			if (!v6)
				return 0;
		}
		return next;
	}
	return v7;
#else
	return NULL;
#endif
}


// autogenerated function stub: 
// struct Intro * /*$ra*/ INSTANCE_FindIntro(long areaID /*$a0*/, long introUniqueID /*$s1*/)
struct Intro* INSTANCE_FindIntro(long areaID, long introUniqueID)
{ // line 2065, offset 0x80034650
#if defined(PC_VERSION)
	struct Intro* v2; // ebx
	struct Level* LevelWithID; // eax
	int numIntros; // edx
	int v5; // ecx
	struct Intro* introList; // edi
	int* i; // eax

	v2 = 0;
	LevelWithID = STREAM_GetLevelWithID(areaID);
	if (LevelWithID)
	{
		numIntros = LevelWithID->numIntros;
		v5 = 0;
		if (numIntros > 0)
		{
			introList = LevelWithID->introList;
			for (i = &introList->UniqueID; introUniqueID != *i; i += 19)
			{
				if (++v5 >= numIntros)
					return 0;
			}
			return &introList[v5];
		}
	}
	return v2;
#else
	return NULL;
#endif
}

struct _Instance* INSTANCE_Find(long introUniqueID)
{
#if defined(PSX_VERSION)
	struct _Instance* instance;

	instance = gameTrackerX.instanceList->first;

	while (instance != NULL)
	{
		if (instance->introUniqueID == introUniqueID)
		{
			break;
		}

		instance = instance->next;
	}

	return instance;

#elif defined(PC_VERSION)
	struct _Instance* result; // eax

	for (result = gameTrackerX.instanceList->first; result; result = result->next)
	{
		if (result->introUniqueID == introUniqueID)
			break;
	}
	return result;
#endif
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ INSTANCE_IntroduceSavedInstance(struct _SavedIntro *savedIntro /*$s2*/, struct _StreamUnit *streamUnit /*$a1*/, int *deleted /*$fp*/)
struct _Instance* INSTANCE_IntroduceSavedInstance(struct _SavedIntro* savedIntro, struct _StreamUnit* streamUnit, int* deleted)
{ // line 2102, offset 0x80034714
#if 0//defined(PC_VERSION)
	struct _Instance* first_free; // ebp
	int v5; // esi
	struct _Instance* first; // eax
	struct _Instance* next; // ecx
	int v8; // edx
	struct _ObjectTracker* ObjectTracker; // eax
	struct _ObjectTracker* v10; // esi
	struct Object* v11; // edx
	struct _Instance* i; // eax
	struct _InstanceList* instanceList; // eax
	struct _InstancePool* pool; // ecx
	int numFreeInstances; // edx
	struct _InstancePool* v16; // ecx
	struct _Instance* v17; // ecx
	struct Level* LevelWithID; // eax
	struct _Terrain* terrain; // eax
	int numIntros; // ecx
	struct Intro* introList; // eax
	__int16 z; // ax
	struct _InstanceList* v23; // esi
	int v24; // eax
	int flags; // eax
	int v26; // ecx
	struct Object* v27; // eax
	unsigned int v28; // edx
	unsigned int v29; // ecx
	int flags2; // eax
	int v31; // eax
	unsigned int v32; // eax
	__int16* introData; // esi
	__int16 j; // ax
	__int16 v35; // ax
	struct Object* v36; // edx
	int v37; // ecx
	int v38; // eax
	void(__stdcall * messageFunc)(); // esi
	int v40; // edi
	int v41; // ecx
	struct Object* v42; // eax
	unsigned int v43; // edx
	unsigned int v44; // ecx
	__int16 numberOfEffects; // ax
	int v46; // esi
	int v47; // eax
	struct _Instance* v49; // [esp+10h] [ebp-14h]
	_Position* p_globalOffset; // [esp+14h] [ebp-10h]
	int v51; // [esp+14h] [ebp-10h]
	char name[4]; // [esp+18h] [ebp-Ch] BYREF
	int v53; // [esp+1Ch] [ebp-8h]
	char v54; // [esp+20h] [ebp-4h]
	struct _SavedIntro* savedIntroa; // [esp+28h] [ebp+4h]
	struct Object* object; // [esp+2Ch] [ebp+8h]

	first_free = 0;
	v5 = 0;
	v49 = 0;
	p_globalOffset = &streamUnit->level->terrain->BSPTreeArray->globalOffset;
	first = gameTrackerX.instanceList->first;
	if (first)
	{
		while (1)
		{
			next = first->next;
			if (first->introUniqueID == savedIntro->introUniqueID)
				break;
			first = first->next;
			if (!next)
				goto LABEL_6;
		}
		v5 = 1;
	}
LABEL_6:
	if (!v5)
	{
		v8 = *(_DWORD*)&savedIntro->name[4];
		*(_DWORD*)name = *(_DWORD*)savedIntro->name;
		v53 = v8;
		v54 = 0;
		ObjectTracker = STREAM_GetObjectTracker(name);
		v10 = ObjectTracker;
		if (ObjectTracker)
		{
			v11 = ObjectTracker->object;
			object = v11;
			if (ObjectTracker->objectStatus == 2)
			{
				if (!savedIntro->attachedUniqueID)
					goto LABEL_73;
				for (i = gameTrackerX.instanceList->first; i; i = i->next)
				{
					if (i->introUniqueID == savedIntro->attachedUniqueID)
						break;
				}
				v49 = i;
				if (i)
				{
				LABEL_73:
					if ((v11->oflags2 & 0x10000000) == 0 || (OBTABLE_InitAnimPointers(v10), (object->oflags2 & 0x10000000) == 0))
					{
						instanceList = gameTrackerX.instanceList;
						pool = gameTrackerX.instanceList->pool;
						numFreeInstances = pool->numFreeInstances;
						if (numFreeInstances)
						{
							pool->numFreeInstances = numFreeInstances - 1;
							v16 = instanceList->pool;
							first_free = v16->first_free;
							v16->first_free = first_free->next;
							v17 = instanceList->first;
							instanceList->first = first_free;
							first_free->next = v17;
							if (v17)
								v17->prev = first_free;
							first_free->prev = 0;
							first_free->instanceID = instanceList->pool->nextInstanceID++;
							++instanceList->numInstances;
						}
						else
						{
							GXFilePrint("ran out of instances need more than %d - contact a programmer\n", 62);
							first_free = 0;
						}
						if (!first_free)
							goto LABEL_69;
						++v10->numInUse;
						INSTANCE_DefaultInit(first_free, object, 0);
						strcpy(first_free->introName, name);
						first_free->introUniqueID = savedIntro->introUniqueID;
						first_free->currentStreamUnitID = savedIntro->streamUnitID;
						first_free->birthStreamUnitID = savedIntro->birthUnitID;
						LIGHT_GetAmbient((struct _ColorType*)&first_free->light_color, first_free);
						LevelWithID = STREAM_GetLevelWithID(first_free->birthStreamUnitID);
						if (LevelWithID
							&& (terrain = LevelWithID->terrain,
								numIntros = terrain->numIntros,
								introList = terrain->introList,
								numIntros))
						{
							while (introList->UniqueID != first_free->introUniqueID)
							{
								++introList;
								if (!--numIntros)
									goto LABEL_26;
							}
						}
						else
						{
						LABEL_26:
							introList = 0;
						}
						if (introList)
						{
							first_free->intro = introList;
							first_free->introData = introList->data;
						}
						else
						{
							first_free->intro = 0;
							first_free->introData = 0;
						}
						first_free->position.x = p_globalOffset->x + savedIntro->position.x;
						first_free->position.y = p_globalOffset->y + savedIntro->position.y;
						first_free->position.z = p_globalOffset->z + savedIntro->position.z;
						*(_DWORD*)&first_free->initialPos.x = *(_DWORD*)&first_free->position.x;
						first_free->initialPos.z = first_free->position.z;
						z = first_free->position.z;
						*(_DWORD*)&first_free->oldPos.x = *(_DWORD*)&first_free->position.x;
						first_free->oldPos.z = z;
						*(_SmallRotation*)&first_free->rotation.x = savedIntro->smallRotation;
						first_free->scale.x = 4096;
						first_free->scale.y = 4096;
						first_free->scale.z = 4096;
						first_free->lightGroup = savedIntro->lightGroup;
						first_free->spectralLightGroup = savedIntro->specturalLightGroup;
						v23 = gameTrackerX.instanceList;
						v24 = INSTANCE_InstanceGroupNumber(first_free);
						LIST_InsertFunc(&v23->group[v24], &first_free->node);
						OBTABLE_GetInstanceCollideFunc(first_free);
						OBTABLE_GetInstanceProcessFunc(first_free);
						OBTABLE_GetInstanceQueryFunc(first_free);
						OBTABLE_GetInstanceMessageFunc(first_free);
						OBTABLE_GetInstanceAdditionalCollideFunc(first_free);
						OBTABLE_InstanceInit(first_free);
						v51 = first_free->flags2 & 0x20000;
						flags = first_free->flags;
						first_free->flags = savedIntro->flags;
						savedIntroa = (struct _SavedIntro*)(flags & 0x20);
						first_free->flags2 = savedIntro->flags2 & ~1u;
						if (v49)
						{
							if ((v49->flags2 & 1) != 0)
							{
								v26 = v49->flags;
								v27 = v49->object;
								v49->flags2 &= ~1u;
								if ((v26 & 0x40000) != 0)
								{
									v28 = v26 & ~0x40000u;
									v29 = v49->flags2 | 0x20000000;
									v49->flags = v28;
								}
								else
								{
									v29 = v49->flags2 & ~0x20000000u;
								}
								v49->flags2 = v29;
								if (v27->animList)
								{
									if ((v27->oflags2 & 0x40000000) == 0)
										G2Anim_Restore(&v49->anim);
								}
							}
							flags2 = v49->flags2;
							LOBYTE(flags2) = flags2 | 0x80;
							v49->flags2 = flags2;
						}
						v31 = first_free->flags2;
						if ((first_free->flags & 0x40000) != 0)
							v32 = v31 | 0x20000000;
						else
							v32 = v31 & ~0x20000000u;
						first_free->flags2 = v32;
						first_free->flags = first_free->flags & ~0x2140000u | 0x100000;
						MORPH_SetupInstanceFlags(first_free);
						if (first_free->intro)
						{
							introData = (__int16*)first_free->introData;
							if (introData)
							{
								if ((first_free->flags & 2) == 0)
								{
									for (j = *introData; j; introData += 2 * v37 + 2)
									{
										if (j == 18)
										{
											v35 = introData[2];
											v36 = first_free->object;
											first_free->currentModel = v35;
											if (v36->numModels <= v35)
												GXFilePrint(
													"Error: Specify model num %d on a instance(%s%d) with %d models.\n",
													first_free->currentModel,
													first_free->introName,
													first_free->introNum,
													v36->numModels);
										}
										v37 = introData[1];
										j = introData[2 * v37 + 2];
									}
								}
							}
						}
						if (savedIntro->shiftedSaveSize > 0xAu)
						{
							v38 = SetControlSaveDataData(4 * savedIntro->shiftedSaveSize - 40, &savedIntro[1]);
							messageFunc = first_free->messageFunc;
							v40 = v38;
							if (messageFunc)
							{
								if ((first_free->flags2 & 1) != 0)
								{
									v41 = first_free->flags;
									v42 = first_free->object;
									first_free->flags2 &= ~1u;
									if ((v41 & 0x40000) != 0)
									{
										v43 = v41 & 0xFFFBFFFF;
										v44 = first_free->flags2 | 0x20000000;
										first_free->flags = v43;
									}
									else
									{
										v44 = first_free->flags2 & 0xDFFFFFFF;
									}
									first_free->flags2 = v44;
									if (v42->animList)
									{
										if ((v42->oflags2 & 0x40000000) == 0)
											G2Anim_Restore(&first_free->anim);
									}
								}
								((void(__cdecl*)(struct _Instance*, int, int))messageFunc)(first_free, 1048583, v40);
							}
						}
						EVENT_AddInstanceToInstanceList(first_free);
						if ((object->oflags2 & 0x100) == 0)
						{
							numberOfEffects = object->numberOfEffects;
							if (numberOfEffects)
							{
								v46 = 0;
								if (numberOfEffects > 0)
								{
									do
										FX_StartInstanceEffect(first_free, (unsigned __int8*)&object->effectList[v46++], 1);
									while (v46 < object->numberOfEffects);
								}
							}
						}
						if (savedIntroa)
						{
							v47 = first_free->flags;
							LOBYTE(v47) = v47 | 0x20;
							first_free->flags = v47;
						}
						if (v51)
						{
							first_free->flags2 |= 0x20000u;
							SAVE_DeleteInstance(first_free);
							*deleted = 1;
						}
					}
				}
			}
		}
		if (!first_free)
			LABEL_69:
		SAVE_BufferIntro(savedIntro);
	}
	return first_free;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ INSTANCE_IntroduceSavedInstanceWithIntro(struct _SavedIntroWithIntro *savedIntro /*$s4*/, struct _StreamUnit *streamUnit /*$s6*/, int *deleted /*stack 8*/)
struct _Instance* INSTANCE_IntroduceSavedInstanceWithIntro(struct _SavedIntroWithIntro* savedIntro, struct _StreamUnit* streamUnit, int* deleted)
{ // line 2327, offset 0x80034b8c
	/* begin block 1 */
		// Start line: 2328
		// Start offset: 0x80034B8C
		// Variables:
	struct _ObjectTracker* objectTracker; // $s1
	struct Object* object; // $s7
	struct _Instance* instance; // $s0
	_Position* levelOffset; // $fp
	struct Level* level; // $v1
	struct Intro* intro; // $s2
	struct _Instance* attachedInst; // $s5

/* begin block 1.1 */
	// Start line: 2372
	// Start offset: 0x80034CC4
	// Variables:
	int remove; // $s1
	int nosave; // $s2

/* begin block 1.1.1 */
	// Start line: 2376
	// Start offset: 0x80034CC4
	// Variables:
	short _x0; // $v0
	short _y0; // $a0
	short _z0; // $v1
	short _x1; // $a1
	short _y1; // $a2
	short _z1; // $a3
	_Position* _v; // $v0
	_Position* _v0; // $v1
/* end block 1.1.1 */
// End offset: 0x80034CC4
// End Line: 2376

/* begin block 1.1.2 */
	// Start line: 2513
	// Start offset: 0x80034F4C
/* end block 1.1.2 */
// End offset: 0x80034F68
// End Line: 2524
/* end block 1.1 */
// End offset: 0x80034F9C
// End Line: 2533
/* end block 1 */
// End offset: 0x80034FCC
// End Line: 2549

/* begin block 2 */
	// Start line: 5380
/* end block 2 */
// End Line: 5381

	return null;
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_SpatialRelationships(struct _InstanceList *instanceList /*$s4*/)
void INSTANCE_SpatialRelationships(struct _InstanceList* instanceList)
{ // line 2596, offset 0x80035000
	/* begin block 1 */
		// Start line: 2597
		// Start offset: 0x80035000
		// Variables:
	struct _Instance* instance; // $s1
	struct _Instance* checkee; // $s0

/* begin block 1.1 */
	// Start line: 2606
	// Start offset: 0x8003504C
	// Variables:
	//MATRIX* lookMatrix; // $s0
	long checkMask; // $s3

/* begin block 1.1.1 */
	// Start line: 2615
	// Start offset: 0x80035074
	// Variables:
	//MATRIX invMatrix; // stack offset -80

/* begin block 1.1.1.1 */
	// Start line: 2624
	// Start offset: 0x800350D0
	// Variables:
	//struct evCollideInstanceStatsData data; // stack offset -48
	//MATRIX* mat; // $a2
/* end block 1.1.1.1 */
// End offset: 0x80035124
// End Line: 2634
/* end block 1.1.1 */
// End offset: 0x80035134
// End Line: 2636
/* end block 1.1 */
// End offset: 0x80035134
// End Line: 2637
/* end block 1 */
// End offset: 0x80035144
// End Line: 2639

/* begin block 2 */
	// Start line: 5192
/* end block 2 */
// End Line: 5193

}


// autogenerated function stub: 
// int /*$ra*/ INSTANCE_SetStatsData(struct _Instance *instance /*$s1*/, struct _Instance *checkee /*$s5*/, struct _Vector *checkPoint /*$s2*/, struct evCollideInstanceStatsData *data /*$s3*/, MATRIX *mat /*stack 16*/)
int INSTANCE_SetStatsData(struct _Instance* instance, struct _Instance* checkee, struct _Vector* checkPoint, struct evCollideInstanceStatsData* data, MATRIX* mat)
{ // line 2643, offset 0x80035164
#if defined(PC_VERSION)
	unsigned int v5; // ebp
	SVECTOR* ScratchAddr; // esi

	v5 = MATH3D_LengthXYZ(
		instance->position.x - checkPoint->x,
		instance->position.y - checkPoint->y,
		instance->position.z - checkPoint->z);
	if (v5 >= instance->maxCheckDistance)
		return 0;
	ScratchAddr = (SVECTOR*)getScratchAddr(0);
	ScratchAddr->vx = checkPoint->x - instance->position.x;
	ScratchAddr->vy = checkPoint->y - instance->position.y;
	ScratchAddr->vz = checkPoint->z - instance->position.z;
	ApplyMatrixSV(mat, ScratchAddr, (SVECTOR*)&data->relativePosition);
	data->distance = v5;
	data->instance = checkee;
	data->zDelta = ScratchAddr->vz;
	data->xyDistance = MATH3D_LengthXY(ScratchAddr->vx, ScratchAddr->vy);
	return 1;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_LinkToParent(struct _Instance *instance /*$s0*/, struct _Instance *parent /*$s1*/, int node /*$a2*/)
void INSTANCE_LinkToParent(struct _Instance* instance, struct _Instance* parent, int node)
{ // line 2672, offset 0x80035274
#if defined(PC_VERSION)
	int x; // eax
	struct _Instance* i; // edi
	void(* messageFunc)(); // edi
	int flags2; // eax
	int flags; // ecx
	struct Object* object; // edx
	int v9; // eax
	int v10; // eax

	instance->LinkSibling = parent->LinkChild;
	parent->LinkChild = instance;
	x = instance->scale.x;
	instance->LinkParent = parent;
	instance->ParentLinkNode = node;
	instance->scale.x = (x << 12) / parent->scale.x;
	instance->scale.y = (instance->scale.y << 12) / parent->scale.y;
	instance->scale.z = (instance->scale.z << 12) / parent->scale.z;
	for (i = parent->LinkChild; i; i = i->LinkSibling)
	{
		i->currentStreamUnitID = parent->currentStreamUnitID;
		INSTANCE_UpdateFamilyStreamUnitID(i);
	}
	messageFunc = parent->messageFunc;
	if (messageFunc)
	{
		flags2 = parent->flags2;
		if ((flags2 & 1) != 0)
		{
			flags = parent->flags;
			object = parent->object;
			flags2 = flags2 & ~1;
			parent->flags2 = flags2;
			if ((flags & 0x40000) != 0)
			{
				v9 = flags2 | 0x20000000;
				parent->flags = flags & ~0x40000u;
			}
			else
			{
				v9 = flags2 & 0xDFFFFFFF;
			}
			parent->flags2 = v9;
			if (object->animList && (object->oflags2 & 0x40000000) == 0)
				G2Anim_Restore(&parent->anim);
		}
		((void(__cdecl*)(struct _Instance*, int, struct _Instance*))messageFunc)(parent, 0x100012, instance);
	}
	v10 = instance->flags2;
	v10 = v10 | 8;
	instance->flags2 = v10;
#endif
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_UnlinkFromParent(struct _Instance *instance /*$s0*/)
void INSTANCE_UnlinkFromParent(struct _Instance* instance)
{ // line 2693, offset 0x80035330
	/* begin block 1 */
		// Start line: 2694
		// Start offset: 0x80035330
		// Variables:
	struct _Instance* parent; // $s1

/* begin block 1.1 */
	// Start line: 2698
	// Start offset: 0x80035354
	// Variables:
	//struct _G2EulerAngles_Type ea; // stack offset -24

/* begin block 1.1.1 */
	// Start line: 2706
	// Start offset: 0x80035370
	// Variables:
	struct _Instance* sibling; // $v1
/* end block 1.1.1 */
// End offset: 0x800353A4
// End Line: 2712
/* end block 1.1 */
// End offset: 0x80035480
// End Line: 2732
/* end block 1 */
// End offset: 0x80035480
// End Line: 2733

/* begin block 2 */
	// Start line: 6228
/* end block 2 */
// End Line: 6229

}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_UnlinkChildren(struct _Instance *instance /*$s2*/)
void INSTANCE_UnlinkChildren(struct _Instance* instance)
{ // line 2735, offset 0x80035494
#if defined(PC_VERSION)
	struct _Instance* child; // edi
	void(*messageFunc)(); // ebx
	struct _Instance* sibling; // ebp
	int flags2; // eax
	int flags; // ecx
	struct Object* object; // edx
	int v7; // eax

	child = instance->LinkChild;
	if (child)
	{
		do
		{
			messageFunc = instance->messageFunc;
			sibling = child->LinkSibling;
			if (messageFunc)
			{
				flags2 = instance->flags2;
				if ((flags2 & 1) != 0)
				{
					flags = instance->flags;
					object = instance->object;
					flags2 = flags2 & ~1;
					instance->flags2 = flags2;
					if ((flags & 0x40000) != 0)
					{
						v7 = flags2 | 0x20000000;
						instance->flags = flags & ~0x40000u;
					}
					else
					{
						v7 = flags2 & ~0x20000000u;
					}
					instance->flags2 = v7;
					if (object->animList && (object->oflags2 & 0x40000000) == 0)
						G2Anim_Restore(&instance->anim);
				}
				((void(__cdecl*)(struct _Instance*, int, struct _Instance*))messageFunc)(instance, 0x100013, child);
			}
			child->LinkParent = 0;
			child->LinkSibling = 0;
			child = sibling;
		} while (sibling);
	}
	instance->LinkChild = 0;
#endif
}

void INSTANCE_UpdateFamilyStreamUnitID(struct _Instance* instance)
{
#if defined(PSX_VERSION)
	struct _Instance* child;
	
	child = instance->LinkChild;

	while (child != NULL)
	{
		child->currentStreamUnitID = instance->currentStreamUnitID;
		INSTANCE_UpdateFamilyStreamUnitID(child);
		child = child->LinkSibling;
	}

#elif defined(PC_VERSION)
	struct _Instance* child; // esi

	for (child = instance->LinkChild; child; child = child->LinkSibling)
	{
		child->currentStreamUnitID = instance->currentStreamUnitID;
		INSTANCE_UpdateFamilyStreamUnitID(child);
	}
#endif
}


// autogenerated function stub: 
// void /*$ra*/ INSTANCE_ReallyRemoveAllChildren(struct _Instance *instance /*$a0*/)
void INSTANCE_ReallyRemoveAllChildren(struct _Instance* instance)
{ // line 2769, offset 0x80035558
#if defined(PC_VERSION)
	struct _Instance* LinkChild; // esi
	struct _Instance* LinkSibling; // edi

	LinkChild = instance->LinkChild;
	if (LinkChild)
	{
		do
		{
			LinkSibling = LinkChild->LinkSibling;
			INSTANCE_ReallyRemoveAllChildren(LinkChild);
			INSTANCE_ReallyRemoveInstance(gameTrackerX.instanceList, LinkChild, 0);
			LinkChild = LinkSibling;
		} while (LinkSibling);
	}
#endif
}


// autogenerated function stub: 
// struct _Instance * /*$ra*/ INSTANCE_GetChildLinkedToSegment(struct _Instance *instance /*$a0*/, int segment /*$a1*/)
struct _Instance* INSTANCE_GetChildLinkedToSegment(struct _Instance* instance, int segment)
{ // line 2785, offset 0x800355b4
	struct _Instance* child; // eax

	for (child = instance->LinkChild; child; child = child->LinkSibling)
	{
		if (child->ParentLinkNode == segment)
			break;
	}
	return child;
}


// autogenerated function stub: 
// int /*$ra*/ INSTANCE_Linked(struct _Instance *instance1 /*$a0*/, struct _Instance *instance2 /*$a1*/)
int INSTANCE_Linked(struct _Instance* instance1, struct _Instance* instance2)
{ // line 2801, offset 0x800355ec
	struct _Instance* root1; // edx
	struct _Instance* p0; // eax
	struct _Instance* root2; // ecx
	struct _Instance* p1; // eax

	root1 = instance1;
	for (p0 = instance1->LinkParent; p0; p0 = p0->LinkParent)
		root1 = p0;
	root2 = instance2;
	for (p1 = instance2->LinkParent; p1; p1 = p1->LinkParent)
		root2 = p1;
	return root1 == root2;
}


// autogenerated function stub: 
// int /*$ra*/ INSTANCE_GetFadeValue(struct _Instance *instance /*$s1*/)
int INSTANCE_GetFadeValue(struct _Instance* instance)
{ // line 2819, offset 0x8003563c
#if defined(PC_VERSION)
	int result; // eax
	int v2; // esi
	struct _Instance* LinkParent; // eax
	int v4; // eax

	result = instance->fadeValue;
	if (gameTrackerX.gameData.asmData.MorphTime != 1000)
	{
		v2 = 4096 - result;
		if (MEMPACK_MemoryValidFunc((char*)instance->object))
		{
			if ((instance->object->oflags2 & 0x2000000) != 0
				|| (LinkParent = instance->LinkParent) != 0 && (LinkParent->object->oflags2 & 0x2000000) != 0)
			{
				if ((instance->flags2 & 0x8000000) != 0)
					v4 = gameTrackerX.spectral_fadeValue * v2;
				else
					v4 = gameTrackerX.material_fadeValue * v2;
				v2 = v4 / 4096;
			}
		}
		return 4096 - v2;
	}
	return result;
#else
	return 0;
#endif
}


// autogenerated function stub: 
// unsigned long /*$ra*/ INSTANCE_DefaultAnimCallback(struct _G2Anim_Type *anim /*$a0*/, int sectionID /*$a1*/, enum _G2AnimCallbackMsg_Enum message /*$a2*/, long messageDataA /*$s4*/, long messageDataB /*stack 16*/, struct _Instance *instance /*stack 20*/)
unsigned long INSTANCE_DefaultAnimCallback(struct _G2Anim_Type* anim, int sectionID, enum _G2AnimCallbackMsg_Enum message, long messageDataA, long messageDataB, struct _Instance* instance)
{ // line 2855, offset 0x80035720
#if defined(PC_VERSION)
	int v7; // esi
	int v8; // edi

	if (message == G2ANIM_MSG_PLAYEFFECT)
	{
		if (messageDataA)
		{
			if (messageDataA == 1)
			{
				FX_StartInstanceEffect(instance, (unsigned __int8*)messageDataB, 0);
				return 1;
			}
		}
		else if (messageDataB)
		{
			v7 = *(__int16*)(messageDataB + 2);
			if (v7 > 999)
			{
				v8 = v7 / 1000;
				v7 += 200 * (4 * (v7 / -1000) - v7 / 1000);
				if (v8 != HUMAN_TypeOfHuman(instance))
					return 0;
			}
			SOUND_Play3dSound(
				&instance->position,
				*(__int16*)messageDataB,
				*(__int16*)(messageDataB + 4),
				v7,
				*(__int16*)(messageDataB + 6));
		}
	}
	return messageDataA;
#else
	return 0;
#endif
}




